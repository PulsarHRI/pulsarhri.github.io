{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the PULSAR HRI documentation! This documentation contains everything you need to begin working with the PULSAR HRI Actuators or PULSAR HRI Motors. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the packages, and accessing the documentation and examples.</p> <p>The PULSAR HRI packages is designed to provide a robust and flexible interface for controlling and monitoring PULSAR HRI hardware. It includes:</p> <ul> <li>A Python package for controlling the real hardware</li> <li>A Python package for controlling the digital twin (AUGUR)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"#overview-of-the-pulsar-hri-ecosystem","title":"Overview of the PULSAR HRI ecosystem","text":"<p>Note</p> <ul> <li>When we refer to motors we refer to direct drive motors without transmission</li> <li>When we refer to actuators we refer to motors with a transmission</li> </ul> <p>PULSAR HRI develops best-in-class actuation systems to enable the next generation of robotic capabilities. Our aim is to provide the highest possible performance in motors and actuators, defining excellence through novel metrics involving agility, torque-density, and efficiency. Our model-based design approach enables us to deliver high-performance actuators alongside high-fidelity digital twins (AUGUR). This documentation contains all the necessary resources to set up either a simulation or a physical configuration using our products.</p> <p></p>"},{"location":"electrical_interfaces/","title":"Electrical Interfaces","text":""},{"location":"electrical_interfaces/#power-bus","title":"Power bus","text":"<p>The power bus requirements are:</p> <ul> <li>Voltage: 48V DC</li> <li>Current: up to 30A</li> </ul> <p>Keep in mind that the actuators usually draw much less current (less than 1A without load), but you should still ensure that your power supply can provide the maximum current, or limit the current if the device is demanding more than the power supply can provide.</p> <p>The device has a XT30 male connector for power input. The pinout is as follows:</p> <p></p>"},{"location":"electrical_interfaces/#can-bus","title":"CAN bus","text":"<p>Pulsar devices are compatible with CAN-FD 1Mbit/s|5Mbit/s. We also provide a CAN to USB adapter. CAN specifications require termination resistors (usually 120 Ohm) at both ends of the bus. This is particularly important for high-speed communication. All Pulsar devices have dual CAN connectors, so you can daisy-chain them easily. Ensure to connect the provided termination resistors at both ends of the bus.</p> <p>This is an example of a CAN bus connection between two Pulsar actuators and a Pulsar CAN to USB adapter:</p> <p></p> <p>The connectors are 3-pin PicoBlade from Molex, and the pinout is as follows:</p> <p></p>"},{"location":"electrical_interfaces/#usb","title":"USB","text":"<p>Pulsar devices also include a USB connector. The USB interface is intended for configuration and firmware updates.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Coming soon ...</p>"},{"location":"gui/","title":"Desktop App","text":"<p>The most straightforward way to use a Pulsar Actuator is through the graphical user interface (GUI). It allows you to easily configure and control the actuator without needing to write any code. This desktop application is available for Windows, Mac, and Linux. The Actuator needs to be powered and connected to the computer via USB.</p> <p></p>"},{"location":"led/","title":"LED Status Indicators","text":"<p>The device features an RGB LED that provides visual feedback about its current operational state. This LED helps users quickly identify the device status without needing to connect to a computer.</p>"},{"location":"led/#color-codes","title":"Color Codes","text":"<p>The following colors indicate different device states:</p> <p>\u25cf White: Device is powering up and initializing systems.</p> <p>\u25cf Blue: Device is idle and ready, waiting for PCP commands over CAN bus.</p> <p>\u25cf Purple: USB connection established, device is waiting for commands via USB interface.</p> <p>\u25cf Green: Device is actively processing commands and operating normally.</p> <p>\u25cf Red: Device has encountered an error and requires attention.</p> <p>\u25cf Off: Device is in firmware update mode.</p> <p>Note: LED colors transition automatically based on device state changes. If the LED remains red, consult the troubleshooting guide or check system logs for error details.</p>"},{"location":"mechanical_interfaces/","title":"Mechanical Interfaces","text":""},{"location":"mechanical_interfaces/#p98","title":"P98","text":""},{"location":"mechanical_interfaces/#3d-models","title":"3D Models","text":"<p>Before integrating the Pulsar Actuator into your system, we recommend attaching it to a generic bracket, so you can familiarize yourself with the usage and perform some tests. We provide some 3D printable files.</p> Base Bracket Shaft Download Download Download"},{"location":"support/","title":"Support","text":"<p>If you encounter any issues or have any questions regarding the use of any product, please do not hesitate to reach out to our support team. </p> <ul> <li>Support Email: support.dt@pulsarhri.com</li> <li>Support Hours: Monday to Thursday, 8:00 AM - 5:00 PM (GMT) and Friday, 8:00 AM - 1:00 PM (GMT) </li> </ul> <p>For additional resources and troubleshooting tips, please contact our support team. Thank you for choosing our product. We are committed to providing you with the best possible experience.</p> <p>You can also create an issue reporting a bug or requesting a new feature.</p>"},{"location":"why_pulsar/","title":"Why PULSAR HRI motors and actuators?","text":""},{"location":"why_pulsar/#how-are-pulsar-hri-motors-and-actuators-different-from-the-others","title":"How are PULSAR HRI motors and actuators different from the others?","text":"<p>Robotic applications require motors and actuators which can produce high torques at low speeds, while being able to change speed and torque in a reliable and agile manner. A key performance indicator often overlooked is dynamic efficiency, a critical requirement for mobile robots. </p>"},{"location":"why_pulsar/#motors","title":"Motors","text":"<p>We provide our motors both on frameless and framed configurations. Your motor, your choice. Our range covers different sizes and torques to fit multiple applications, all of them delivering dynamic response (bandwidth) and torque density, while requiring low current to drive them. Both second electrical generation motors and custom design services can be unlocked by joining our Vanguard Program.\u200b</p>"},{"location":"why_pulsar/#actuators","title":"Actuators","text":"<p>We design Quasi-Direct Drive (QDD) actuators offer a well-balanced alternative to traditional high-gear solutions.</p> <p>Design specifics also matter. Therefore, we decided to design our transmissions with a very low gear ratio to increase the total bandwidth, boost backdrivability, improve proprioceptiveness and better respond to highly-dynamic intermittent operations.</p> <p></p>"},{"location":"control/00-control-modes-overview/","title":"Control modes overview","text":""},{"location":"control/00-control-modes-overview/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"control/00-control-modes-overview/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"control/00-control-modes-overview/#electromagnetic-torque-control","title":"Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p> <p></p>"},{"location":"control/00-control-modes-overview/#speed-control","title":"Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p> <p></p>"},{"location":"control/00-control-modes-overview/#position-control","title":"Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul> <p></p>"},{"location":"control/00-control-modes-overview/#impedance-control-under-development","title":"Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p> <p></p>"},{"location":"control/00-control-modes-overview/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"control/00-control-modes-overview/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"control/00-control-modes-overview/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p> <p></p>"},{"location":"control/00-control-modes-overview/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p> <p></p>"},{"location":"control/00-control-modes-overview/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p> <p></p>"},{"location":"control/01-control-modes-parameters/","title":"Which control parameters can be used in each mode?","text":"<p>Not all the available parameters are useful in all the control modes, the following table shows a summary of which control parameters are compatibles with each control mode.</p> <p>Table \u2013 Use of the parameters depending on the control type</p> Parameter Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque loop performance Yes Yes Yes Yes No No No No Speed loop performance No Yes Yes No No No No No Kp position No No Yes No No No No No Kp speed No Yes (if custom selected) Yes (if custom selected) No No No No No Ki speed No Yes (if custom selected) Yes (if custom selected) No No No No No Stiffness gain No No No Yes No No No No Damping gain No No No Yes No No No No FF torque No No No Yes No No No No Max positive speed (rad/s) (Profile) No No Yes No No No No No Min negative speed (rad/s) (Profile) No No Yes No No No No No Max acceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max deceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max speed (rad/s) No Yes Yes No No No No No Min speed (rad/s) No Yes Yes No No No No No Max position (rad) No No Yes Yes No No No No Min position (rad) No No Yes Yes No No No No Max absolute torque (Nm) Yes Yes Yes Yes Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus)"},{"location":"digital_twin/digital_twin/","title":"How to Use AUGUR Digital Twin","text":"<p>Coming soon ...</p>"},{"location":"python_api/class_PCP_over_USB/","title":"PCP_over_USB","text":"<p>PCP (Pulsar Communication Protocol) adapter for USB connections.</p> <p>This class provides USB serial communication for the PCP protocol, sending messages, receiving incoming messages in a thread for asynchronous communication</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>class PCP_over_USB:\n    \"\"\"\n    PCP (Pulsar Communication Protocol) adapter for USB connections.\n\n    This class provides USB serial communication for the PCP protocol, sending messages,\n    receiving incoming messages in a thread for asynchronous communication\n    \"\"\"\n\n    def __init__(self, port: Optional[str] = None, connect_on_init: bool = True, logger: Optional[logging.Logger] = None) -&gt; None:\n        \"\"\"\n        Initialize PCP over USB communication adapter.\n\n        Args:\n            port: Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.\n            connect_on_init: Whether to automatically connect during initialization\n            logger: Optional logger for debugging messages\n        \"\"\"\n        ...\n\n    def connect(self, port: Optional[str] = None) -&gt; bool:\n        \"\"\"\n        Establish a connection to the device.\n\n        Args:\n            port (str, optional): Serial port name. If None, uses previously set port or auto-discovery.\n\n        Returns:\n            bool: True if connection successful, False otherwise\n        \"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnect from the USB serial port and stop background threads.\n\n        Cleanly shuts down the polling thread and closes the serial connection.\n        \"\"\"\n        ...\n\n    def close(self) -&gt; None:\n        \"\"\"\n        Alias for disconnect() method.\n\n        Provided for compatibility and explicit resource cleanup.\n        \"\"\"\n        ...\n\n    def setCallback(self, address: int, callback: Callable[[int, List[int]], None]) -&gt; None:\n        \"\"\"\n        Register a callback function for messages from a specific PCP address.\n\n        Args:\n            address: PCP address to listen for (1-16382)\n            callback: Function to call when messages are received from this address.\n                     Callback signature: callback(address: int, data: List[int])\n        \"\"\"\n        ...\n\n    def send_PCP(self, address: int, data: List[int]) -&gt; bool:\n        \"\"\"\n        Send a PCP message to the specified address.\n\n        Args:\n            address: Target PCP address (1-16382)\n            data: List of bytes to send as message payload\n\n        Returns:\n            True if message was sent successfully, False otherwise\n        \"\"\"\n        ...\n\n    @staticmethod\n    def get_ports() -&gt; List[str]:\n        \"\"\"\n        Get list of available USB serial ports from Pulsar HRI devices.\n\n        Automatically filters serial ports to only include those manufactured\n        by Pulsar HRI, which are compatible with PCP over USB.\n\n        Returns:\n            List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows\n            or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)\n        \"\"\"\n        ...\n\n    @staticmethod\n    def get_port() -&gt; str:\n        \"\"\"\n        Auto-discover a single USB serial port for PCP communication.\n\n        Attempts to automatically find a suitable serial port. If exactly one\n        Pulsar HRI port is found, returns it. Otherwise, returns empty string.\n\n        Returns:\n            Serial port name if exactly one suitable port is found, empty string otherwise\n        \"\"\"\n        ...\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Check if the USB connection is active.\n\n        Returns:\n            True if connected, False otherwise\n        \"\"\"\n        ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if the USB connection is active.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if connected, False otherwise</p>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.__init__","title":"<code>__init__(port=None, connect_on_init=True, logger=None)</code>","text":"<p>Initialize PCP over USB communication adapter.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.</p> <code>None</code> <code>connect_on_init</code> <code>bool</code> <p>Whether to automatically connect during initialization</p> <code>True</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger for debugging messages</p> <code>None</code> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def __init__(self, port: Optional[str] = None, connect_on_init: bool = True, logger: Optional[logging.Logger] = None) -&gt; None:\n    \"\"\"\n    Initialize PCP over USB communication adapter.\n\n    Args:\n        port: Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.\n        connect_on_init: Whether to automatically connect during initialization\n        logger: Optional logger for debugging messages\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.close","title":"<code>close()</code>","text":"<p>Alias for disconnect() method.</p> <p>Provided for compatibility and explicit resource cleanup.</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Alias for disconnect() method.\n\n    Provided for compatibility and explicit resource cleanup.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.connect","title":"<code>connect(port=None)</code>","text":"<p>Establish a connection to the device.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port name. If None, uses previously set port or auto-discovery.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def connect(self, port: Optional[str] = None) -&gt; bool:\n    \"\"\"\n    Establish a connection to the device.\n\n    Args:\n        port (str, optional): Serial port name. If None, uses previously set port or auto-discovery.\n\n    Returns:\n        bool: True if connection successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the USB serial port and stop background threads.</p> <p>Cleanly shuts down the polling thread and closes the serial connection.</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the USB serial port and stop background threads.\n\n    Cleanly shuts down the polling thread and closes the serial connection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.get_port","title":"<code>get_port()</code>  <code>staticmethod</code>","text":"<p>Auto-discover a single USB serial port for PCP communication.</p> <p>Attempts to automatically find a suitable serial port. If exactly one Pulsar HRI port is found, returns it. Otherwise, returns empty string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Serial port name if exactly one suitable port is found, empty string otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>@staticmethod\ndef get_port() -&gt; str:\n    \"\"\"\n    Auto-discover a single USB serial port for PCP communication.\n\n    Attempts to automatically find a suitable serial port. If exactly one\n    Pulsar HRI port is found, returns it. Otherwise, returns empty string.\n\n    Returns:\n        Serial port name if exactly one suitable port is found, empty string otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.get_ports","title":"<code>get_ports()</code>  <code>staticmethod</code>","text":"<p>Get list of available USB serial ports from Pulsar HRI devices.</p> <p>Automatically filters serial ports to only include those manufactured by Pulsar HRI, which are compatible with PCP over USB.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows</p> <code>List[str]</code> <p>or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>@staticmethod\ndef get_ports() -&gt; List[str]:\n    \"\"\"\n    Get list of available USB serial ports from Pulsar HRI devices.\n\n    Automatically filters serial ports to only include those manufactured\n    by Pulsar HRI, which are compatible with PCP over USB.\n\n    Returns:\n        List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows\n        or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.send_PCP","title":"<code>send_PCP(address, data)</code>","text":"<p>Send a PCP message to the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Target PCP address (1-16382)</p> required <code>data</code> <code>List[int]</code> <p>List of bytes to send as message payload</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully, False otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def send_PCP(self, address: int, data: List[int]) -&gt; bool:\n    \"\"\"\n    Send a PCP message to the specified address.\n\n    Args:\n        address: Target PCP address (1-16382)\n        data: List of bytes to send as message payload\n\n    Returns:\n        True if message was sent successfully, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.setCallback","title":"<code>setCallback(address, callback)</code>","text":"<p>Register a callback function for messages from a specific PCP address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>PCP address to listen for (1-16382)</p> required <code>callback</code> <code>Callable[[int, List[int]], None]</code> <p>Function to call when messages are received from this address.      Callback signature: callback(address: int, data: List[int])</p> required Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def setCallback(self, address: int, callback: Callable[[int, List[int]], None]) -&gt; None:\n    \"\"\"\n    Register a callback function for messages from a specific PCP address.\n\n    Args:\n        address: PCP address to listen for (1-16382)\n        callback: Function to call when messages are received from this address.\n                 Callback signature: callback(address: int, data: List[int])\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/","title":"PulsarActuator","text":"<p>Main class for controlling Pulsar actuators via PCP (Pulsar Control Protocol).</p> <p>This class provides high-level methods to control actuator modes, setpoints, feedback configuration, and parameter management.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PulsarActuator:\n    \"\"\"\n    Main class for controlling Pulsar actuators via PCP (Pulsar Control Protocol).\n\n    This class provides high-level methods to control actuator modes, setpoints,\n    feedback configuration, and parameter management.\n    \"\"\"\n\n    class Mode(Enum):\n        \"\"\"Control modes available for the Pulsar actuator.\"\"\"\n        TORQUE = 0x05\n        SPEED = 0x06\n        POSITION = 0x07\n        IMPEDANCE = 0x08\n        # These modes are only for testing purposes\n        FVI = 0x02\n        OPEN_LOOP = 0x03\n        DVI = 0x04         # Field oriented voltage injection\n\n    class Rates(Enum):\n        \"\"\"Feedback update rates for high/low frequency data streams.\"\"\"\n        DISABLED = 0       # Feedback disabled\n        RATE_1KHZ = 10     # 1kHz update rate (1000 Hz)\n        RATE_100HZ = 100\n        RATE_50HZ = 200\n        RATE_10HZ = 1_000\n        RATE_5HZ = 2_000\n        RATE_2HZ = 5_000\n        RATE_1HZ = 10_000\n\n    class TorquePerformance(Enum):\n        \"\"\"Performance settings for torque control mode.\"\"\"\n        AGGRESSIVE = 1     # Fast, responsive torque control\n        BALANCED = 2       # Balanced torque control\n        SOFT = 3          # Smooth, gentle torque control\n\n    class SpeedPerformance(Enum):\n        \"\"\"Performance settings for speed control mode.\"\"\"\n        AGGRESSIVE = 1     # Fast, responsive speed control\n        BALANCED = 2       # Balanced speed control\n        SOFT = 3          # Smooth, gentle speed control\n        CUSTOM = 4        # Custom speed control parameters\n\n    class PCP_Parameters(Enum):\n        \"\"\"Available parameters that can be read/written on the actuator.\"\"\"\n        K_DAMPING = 0x01              # Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control)\n        K_STIFFNESS = 0x02            # Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control)\n        TORQUE_FF = 0x03              # Feedforward Torque Value (Nm)\n        LIM_TORQUE = 0x04             # Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm)\n        LIM_POSITION_MAX = 0x05       # Max. Position Limit (rad)\n        LIM_POSITION_MIN = 0x06       # Min. Position Limit (rad)\n        LIM_SPEED_MAX = 0x07          # Max. Speed Limit (rad/s)\n        LIM_SPEED_MIN = 0x08          # Min. Speed Limit (rad/s)\n        PROFILE_POSITION_MAX = 0x09   # Max. Positive Speed (rad/s) in Position control configuration\n        PROFILE_POSITION_MIN = 0x0A   # Min. Negative Speed (rad/s) in Position control configuration\n        PROFILE_SPEED_MAX = 0x0B      # Max. Acceleration (rad/s^2) in Speed control configuration\n        PROFILE_SPEED_MIN = 0x0C      # Max. Deceleration (rad/s^2) in Speed control configuration\n        KP_SPEED = 0x0D               # Kp speed control constant P value\n        KI_SPEED = 0x0E               # Ki speed control constant I value\n        KP_POSITION = 0x0F            # Kp position control constant P value\n        MODE = 0x30                   # Operation Mode (read-only, must be set via CHANGE_MODE)\n        SETPOINT = 0x31               # Setpoint, Position (rad), Speed (rad/s), Torque (Nm)\n        TORQUE_PERFORMANCE = 0x40     # Torque performance setting\n        SPEED_PERFORMANCE = 0x41      # Speed performance setting\n        PROFILE_SPEED_MAX_RAD_S = 0x42    # Maximum profile speed in rad/s\n        PROFILE_TORQUE_MAX_NM = 0x43      # Maximum profile torque in Nm\n        FIRMWARE_VERSION = 0x80       # Firmware version (read-only)\n        PCP_ADDRESS = 0x81            # device PCP address\n        SERIAL_NUMBER = 0x82          # Device serial number (read-only)\n        DEVICE_MODEL = 0x83           # Device model identifier (read-only)\n        CONTROL_VERSION = 0x84        # Control software version (read-only)\n\n    class PCP_Items(Enum):\n        \"\"\"Feedback items available for monitoring actuator state.\"\"\"\n        ENCODER_INT = 0x41            # Internal encoder position\n        ENCODER_INT_RAW = 0x42        # Raw internal encoder counts\n        ENCODER_EXT = 0x43            # External encoder position\n        ENCODER_EXT_RAW = 0x44        # Raw external encoder counts\n        SPEED_FB = 0x45               # Speed feedback\n        IA = 0x46                     # Phase A current\n        IB = 0x47                     # Phase B current\n        IC = 0x48                     # Phase C current\n        TORQUE_SENS = 0x49            # Torque sensor reading\n        TORQUE_SENS_RAW = 0x4A        # Raw torque sensor reading\n        POSITION_REF = 0x4B           # Position reference/command\n        POSITION_FB = 0x4C            # Position feedback\n        SPEED_REF = 0x4D              # Speed reference/command\n        ID_REF = 0x4F                 # D-axis current reference\n        ID_FB = 0x50                  # D-axis current feedback\n        IQ_REF = 0x51                 # Q-axis current reference\n        IQ_FB = 0x52                  # Q-axis current feedback\n        VD_REF = 0x53                 # D-axis voltage reference\n        VQ_REF = 0x54                 # Q-axis voltage reference\n        TORQUE_REF = 0x55             # Torque reference/command\n        TORQUE_FB = 0x56              # Torque feedback\n        ERRORS_ENCODER_INT = 0x60     # Internal encoder error flags\n        ERRORS_ENCODER_EXT = 0x61     # External encoder error flags\n        ERRORS_OVERRUN = 0x62         # Control loop overrun errors\n        VBUS = 0x70                   # Bus voltage\n        TEMP_PCB = 0x71               # PCB temperature\n        TEMP_MOTOR = 0x72             # Motor temperature\n\n    def __init__(self, adapter_handler: Any, address: int, logger: Optional[logging.Logger] = None) -&gt; None:\n        \"\"\"\n        Initialize a PulsarActuator instance.\n\n        Args:\n            adapter_handler: Communication adapter for PCP protocol\n            address: PCP network address of the actuator (1-16382)\n            logger: Optional logger for debugging messages\n        \"\"\"\n        ...\n\n    def connect(self, timeout: float = 1.0) -&gt; bool:\n        \"\"\"\n        Establish connection to the actuator.\n\n        Args:\n            timeout: Connection timeout in seconds\n\n        Returns:\n            True if connection successful, False otherwise\n        \"\"\"\n        ...\n\n    def set_feedback_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Set callback function to receive feedback data.\n\n        Args:\n            callback: Function to call when feedback data is received\n        \"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the actuator and clean up resources.\"\"\"\n        ...\n\n    def get_feedback(self) -&gt; Dict[Any, Any]:\n        \"\"\"\n        Get the latest feedback data.\n\n        Returns:\n            Dictionary containing latest feedback values\n        \"\"\"\n        ...\n\n    def send_ping(self, timeout: float = 1.0) -&gt; bool:\n        \"\"\"\n        Send ping to verify actuator connectivity.\n\n        Args:\n            timeout: Response timeout in seconds\n\n        Returns:\n            True if ping successful, False otherwise\n        \"\"\"\n        ...\n\n    def changeAddress(self, new_address: int) -&gt; None:\n        \"\"\"\n        Change the PCP network address of the actuator.\n\n        Args:\n            new_address: New PCP address (1-16382)\n        \"\"\"\n        ...\n\n    def start(self) -&gt; None:\n        \"\"\"Enable the actuator control system.\"\"\"\n        ...\n\n    def stop(self) -&gt; None:\n        \"\"\"Disable the actuator control system.\"\"\"\n        ...\n\n    def change_mode(self, mode: 'PulsarActuator.Mode') -&gt; None:\n        \"\"\"\n        Change the actuator control mode.\n\n        Args:\n            mode: Desired control mode (TORQUE, SPEED, POSITION, or IMPEDANCE)\n        \"\"\"\n        ...\n\n    def change_setpoint(self, setpoint: float) -&gt; None:\n        \"\"\"\n        Set the control setpoint for the current mode.\n\n        Args:\n            setpoint: Target value (units depend on current mode)\n                     - Torque mode: Nm\n                     - Speed mode: rad/s  \n                     - Position mode: rad\n                     - Impedance mode: rad\n        \"\"\"\n        ...\n\n    def save_config(self) -&gt; None:\n        \"\"\"Save current configuration to non-volatile memory.\"\"\"\n        ...\n\n    def setHighFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n        \"\"\"\n        Configure which items to include in high frequency feedback stream.\n\n        Args:\n            items: List of PCP_Items to monitor at high frequency\n        \"\"\"\n        ...\n\n    def setHighFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n        \"\"\"\n        Set the update rate for high frequency feedback.\n\n        Args:\n            rate: Desired update rate from Rates enum\n        \"\"\"\n        ...\n\n    def setLowFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n        \"\"\"\n        Configure which items to include in low frequency feedback stream.\n\n        Args:\n            items: List of PCP_Items to monitor at low frequency\n        \"\"\"\n        ...\n\n    def setLowFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n        \"\"\"\n        Set the update rate for low frequency feedback.\n\n        Args:\n            rate: Desired update rate from Rates enum\n        \"\"\"\n        ...\n\n    def reset_encoder_position(self) -&gt; None:\n        \"\"\"Reset the encoder position to zero.\"\"\"\n        ...\n\n    def set_parameters(self, parameters: Dict['PulsarActuator.PCP_Parameters', float]) -&gt; None:\n        \"\"\"\n        Set multiple actuator parameters.\n\n        Args:\n            parameters: Dictionary mapping PCP_Parameters to their values\n        \"\"\"\n        ...\n\n    def get_parameters(self, parameters: List['PulsarActuator.PCP_Parameters'], timeout: float = 1.0) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n        \"\"\"\n        Read multiple actuator parameters.\n\n        Args:\n            parameters: List of parameters to read\n            timeout: Response timeout in seconds\n\n        Returns:\n            Dictionary mapping parameters to their current values\n        \"\"\"\n        ...\n\n    def get_parameters_all(self) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n        \"\"\"\n        Read all available actuator parameters.\n\n        Returns:\n            Dictionary containing all parameter values\n        \"\"\"\n        ...\n\n    def set_torque_performance(self, performance: 'PulsarActuator.TorquePerformance') -&gt; None:\n        \"\"\"\n        Set torque control performance level.\n\n        Args:\n            performance: Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)\n        \"\"\"\n        ...\n\n    def set_speed_performance(self, performance: 'PulsarActuator.SpeedPerformance') -&gt; None:\n        \"\"\"\n        Set speed control performance level.\n\n        Args:\n            performance: Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.Mode","title":"<code>Mode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Control modes available for the Pulsar actuator.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class Mode(Enum):\n    \"\"\"Control modes available for the Pulsar actuator.\"\"\"\n    TORQUE = 0x05\n    SPEED = 0x06\n    POSITION = 0x07\n    IMPEDANCE = 0x08\n    # These modes are only for testing purposes\n    FVI = 0x02\n    OPEN_LOOP = 0x03\n    DVI = 0x04         # Field oriented voltage injection\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.PCP_Items","title":"<code>PCP_Items</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Feedback items available for monitoring actuator state.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PCP_Items(Enum):\n    \"\"\"Feedback items available for monitoring actuator state.\"\"\"\n    ENCODER_INT = 0x41            # Internal encoder position\n    ENCODER_INT_RAW = 0x42        # Raw internal encoder counts\n    ENCODER_EXT = 0x43            # External encoder position\n    ENCODER_EXT_RAW = 0x44        # Raw external encoder counts\n    SPEED_FB = 0x45               # Speed feedback\n    IA = 0x46                     # Phase A current\n    IB = 0x47                     # Phase B current\n    IC = 0x48                     # Phase C current\n    TORQUE_SENS = 0x49            # Torque sensor reading\n    TORQUE_SENS_RAW = 0x4A        # Raw torque sensor reading\n    POSITION_REF = 0x4B           # Position reference/command\n    POSITION_FB = 0x4C            # Position feedback\n    SPEED_REF = 0x4D              # Speed reference/command\n    ID_REF = 0x4F                 # D-axis current reference\n    ID_FB = 0x50                  # D-axis current feedback\n    IQ_REF = 0x51                 # Q-axis current reference\n    IQ_FB = 0x52                  # Q-axis current feedback\n    VD_REF = 0x53                 # D-axis voltage reference\n    VQ_REF = 0x54                 # Q-axis voltage reference\n    TORQUE_REF = 0x55             # Torque reference/command\n    TORQUE_FB = 0x56              # Torque feedback\n    ERRORS_ENCODER_INT = 0x60     # Internal encoder error flags\n    ERRORS_ENCODER_EXT = 0x61     # External encoder error flags\n    ERRORS_OVERRUN = 0x62         # Control loop overrun errors\n    VBUS = 0x70                   # Bus voltage\n    TEMP_PCB = 0x71               # PCB temperature\n    TEMP_MOTOR = 0x72             # Motor temperature\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.PCP_Parameters","title":"<code>PCP_Parameters</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Available parameters that can be read/written on the actuator.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PCP_Parameters(Enum):\n    \"\"\"Available parameters that can be read/written on the actuator.\"\"\"\n    K_DAMPING = 0x01              # Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control)\n    K_STIFFNESS = 0x02            # Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control)\n    TORQUE_FF = 0x03              # Feedforward Torque Value (Nm)\n    LIM_TORQUE = 0x04             # Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm)\n    LIM_POSITION_MAX = 0x05       # Max. Position Limit (rad)\n    LIM_POSITION_MIN = 0x06       # Min. Position Limit (rad)\n    LIM_SPEED_MAX = 0x07          # Max. Speed Limit (rad/s)\n    LIM_SPEED_MIN = 0x08          # Min. Speed Limit (rad/s)\n    PROFILE_POSITION_MAX = 0x09   # Max. Positive Speed (rad/s) in Position control configuration\n    PROFILE_POSITION_MIN = 0x0A   # Min. Negative Speed (rad/s) in Position control configuration\n    PROFILE_SPEED_MAX = 0x0B      # Max. Acceleration (rad/s^2) in Speed control configuration\n    PROFILE_SPEED_MIN = 0x0C      # Max. Deceleration (rad/s^2) in Speed control configuration\n    KP_SPEED = 0x0D               # Kp speed control constant P value\n    KI_SPEED = 0x0E               # Ki speed control constant I value\n    KP_POSITION = 0x0F            # Kp position control constant P value\n    MODE = 0x30                   # Operation Mode (read-only, must be set via CHANGE_MODE)\n    SETPOINT = 0x31               # Setpoint, Position (rad), Speed (rad/s), Torque (Nm)\n    TORQUE_PERFORMANCE = 0x40     # Torque performance setting\n    SPEED_PERFORMANCE = 0x41      # Speed performance setting\n    PROFILE_SPEED_MAX_RAD_S = 0x42    # Maximum profile speed in rad/s\n    PROFILE_TORQUE_MAX_NM = 0x43      # Maximum profile torque in Nm\n    FIRMWARE_VERSION = 0x80       # Firmware version (read-only)\n    PCP_ADDRESS = 0x81            # device PCP address\n    SERIAL_NUMBER = 0x82          # Device serial number (read-only)\n    DEVICE_MODEL = 0x83           # Device model identifier (read-only)\n    CONTROL_VERSION = 0x84        # Control software version (read-only)\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.Rates","title":"<code>Rates</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Feedback update rates for high/low frequency data streams.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class Rates(Enum):\n    \"\"\"Feedback update rates for high/low frequency data streams.\"\"\"\n    DISABLED = 0       # Feedback disabled\n    RATE_1KHZ = 10     # 1kHz update rate (1000 Hz)\n    RATE_100HZ = 100\n    RATE_50HZ = 200\n    RATE_10HZ = 1_000\n    RATE_5HZ = 2_000\n    RATE_2HZ = 5_000\n    RATE_1HZ = 10_000\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.SpeedPerformance","title":"<code>SpeedPerformance</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Performance settings for speed control mode.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class SpeedPerformance(Enum):\n    \"\"\"Performance settings for speed control mode.\"\"\"\n    AGGRESSIVE = 1     # Fast, responsive speed control\n    BALANCED = 2       # Balanced speed control\n    SOFT = 3          # Smooth, gentle speed control\n    CUSTOM = 4        # Custom speed control parameters\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.TorquePerformance","title":"<code>TorquePerformance</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Performance settings for torque control mode.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class TorquePerformance(Enum):\n    \"\"\"Performance settings for torque control mode.\"\"\"\n    AGGRESSIVE = 1     # Fast, responsive torque control\n    BALANCED = 2       # Balanced torque control\n    SOFT = 3          # Smooth, gentle torque control\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.__init__","title":"<code>__init__(adapter_handler, address, logger=None)</code>","text":"<p>Initialize a PulsarActuator instance.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_handler</code> <code>Any</code> <p>Communication adapter for PCP protocol</p> required <code>address</code> <code>int</code> <p>PCP network address of the actuator (1-16382)</p> required <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger for debugging messages</p> <code>None</code> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def __init__(self, adapter_handler: Any, address: int, logger: Optional[logging.Logger] = None) -&gt; None:\n    \"\"\"\n    Initialize a PulsarActuator instance.\n\n    Args:\n        adapter_handler: Communication adapter for PCP protocol\n        address: PCP network address of the actuator (1-16382)\n        logger: Optional logger for debugging messages\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.changeAddress","title":"<code>changeAddress(new_address)</code>","text":"<p>Change the PCP network address of the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>new_address</code> <code>int</code> <p>New PCP address (1-16382)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def changeAddress(self, new_address: int) -&gt; None:\n    \"\"\"\n    Change the PCP network address of the actuator.\n\n    Args:\n        new_address: New PCP address (1-16382)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.change_mode","title":"<code>change_mode(mode)</code>","text":"<p>Change the actuator control mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Mode</code> <p>Desired control mode (TORQUE, SPEED, POSITION, or IMPEDANCE)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def change_mode(self, mode: 'PulsarActuator.Mode') -&gt; None:\n    \"\"\"\n    Change the actuator control mode.\n\n    Args:\n        mode: Desired control mode (TORQUE, SPEED, POSITION, or IMPEDANCE)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.change_setpoint","title":"<code>change_setpoint(setpoint)</code>","text":"<p>Set the control setpoint for the current mode.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>float</code> <p>Target value (units depend on current mode)      - Torque mode: Nm      - Speed mode: rad/s      - Position mode: rad      - Impedance mode: rad</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def change_setpoint(self, setpoint: float) -&gt; None:\n    \"\"\"\n    Set the control setpoint for the current mode.\n\n    Args:\n        setpoint: Target value (units depend on current mode)\n                 - Torque mode: Nm\n                 - Speed mode: rad/s  \n                 - Position mode: rad\n                 - Impedance mode: rad\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.connect","title":"<code>connect(timeout=1.0)</code>","text":"<p>Establish connection to the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Connection timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def connect(self, timeout: float = 1.0) -&gt; bool:\n    \"\"\"\n    Establish connection to the actuator.\n\n    Args:\n        timeout: Connection timeout in seconds\n\n    Returns:\n        True if connection successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the actuator and clean up resources.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the actuator and clean up resources.\"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_feedback","title":"<code>get_feedback()</code>","text":"<p>Get the latest feedback data.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dictionary containing latest feedback values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_feedback(self) -&gt; Dict[Any, Any]:\n    \"\"\"\n    Get the latest feedback data.\n\n    Returns:\n        Dictionary containing latest feedback values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_parameters","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Read multiple actuator parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>List[PCP_Parameters]</code> <p>List of parameters to read</p> required <code>timeout</code> <code>float</code> <p>Response timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Dict[PCP_Parameters, float]</code> <p>Dictionary mapping parameters to their current values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_parameters(self, parameters: List['PulsarActuator.PCP_Parameters'], timeout: float = 1.0) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n    \"\"\"\n    Read multiple actuator parameters.\n\n    Args:\n        parameters: List of parameters to read\n        timeout: Response timeout in seconds\n\n    Returns:\n        Dictionary mapping parameters to their current values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Read all available actuator parameters.</p> <p>Returns:</p> Type Description <code>Dict[PCP_Parameters, float]</code> <p>Dictionary containing all parameter values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_parameters_all(self) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n    \"\"\"\n    Read all available actuator parameters.\n\n    Returns:\n        Dictionary containing all parameter values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.reset_encoder_position","title":"<code>reset_encoder_position()</code>","text":"<p>Reset the encoder position to zero.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def reset_encoder_position(self) -&gt; None:\n    \"\"\"Reset the encoder position to zero.\"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.save_config","title":"<code>save_config()</code>","text":"<p>Save current configuration to non-volatile memory.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def save_config(self) -&gt; None:\n    \"\"\"Save current configuration to non-volatile memory.\"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.send_ping","title":"<code>send_ping(timeout=1.0)</code>","text":"<p>Send ping to verify actuator connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Response timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ping successful, False otherwise</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def send_ping(self, timeout: float = 1.0) -&gt; bool:\n    \"\"\"\n    Send ping to verify actuator connectivity.\n\n    Args:\n        timeout: Response timeout in seconds\n\n    Returns:\n        True if ping successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setHighFreqFeedbackItems","title":"<code>setHighFreqFeedbackItems(items)</code>","text":"<p>Configure which items to include in high frequency feedback stream.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[PCP_Items]</code> <p>List of PCP_Items to monitor at high frequency</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setHighFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n    \"\"\"\n    Configure which items to include in high frequency feedback stream.\n\n    Args:\n        items: List of PCP_Items to monitor at high frequency\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setHighFreqFeedbackRate","title":"<code>setHighFreqFeedbackRate(rate)</code>","text":"<p>Set the update rate for high frequency feedback.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Rates</code> <p>Desired update rate from Rates enum</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setHighFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n    \"\"\"\n    Set the update rate for high frequency feedback.\n\n    Args:\n        rate: Desired update rate from Rates enum\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setLowFreqFeedbackItems","title":"<code>setLowFreqFeedbackItems(items)</code>","text":"<p>Configure which items to include in low frequency feedback stream.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[PCP_Items]</code> <p>List of PCP_Items to monitor at low frequency</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setLowFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n    \"\"\"\n    Configure which items to include in low frequency feedback stream.\n\n    Args:\n        items: List of PCP_Items to monitor at low frequency\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setLowFreqFeedbackRate","title":"<code>setLowFreqFeedbackRate(rate)</code>","text":"<p>Set the update rate for low frequency feedback.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Rates</code> <p>Desired update rate from Rates enum</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setLowFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n    \"\"\"\n    Set the update rate for low frequency feedback.\n\n    Args:\n        rate: Desired update rate from Rates enum\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_feedback_callback","title":"<code>set_feedback_callback(callback)</code>","text":"<p>Set callback function to receive feedback data.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to call when feedback data is received</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_feedback_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Set callback function to receive feedback data.\n\n    Args:\n        callback: Function to call when feedback data is received\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_parameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Set multiple actuator parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[PCP_Parameters, float]</code> <p>Dictionary mapping PCP_Parameters to their values</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_parameters(self, parameters: Dict['PulsarActuator.PCP_Parameters', float]) -&gt; None:\n    \"\"\"\n    Set multiple actuator parameters.\n\n    Args:\n        parameters: Dictionary mapping PCP_Parameters to their values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_speed_performance","title":"<code>set_speed_performance(performance)</code>","text":"<p>Set speed control performance level.</p> <p>Parameters:</p> Name Type Description Default <code>performance</code> <code>SpeedPerformance</code> <p>Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_speed_performance(self, performance: 'PulsarActuator.SpeedPerformance') -&gt; None:\n    \"\"\"\n    Set speed control performance level.\n\n    Args:\n        performance: Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_torque_performance","title":"<code>set_torque_performance(performance)</code>","text":"<p>Set torque control performance level.</p> <p>Parameters:</p> Name Type Description Default <code>performance</code> <code>TorquePerformance</code> <p>Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_torque_performance(self, performance: 'PulsarActuator.TorquePerformance') -&gt; None:\n    \"\"\"\n    Set torque control performance level.\n\n    Args:\n        performance: Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.start","title":"<code>start()</code>","text":"<p>Enable the actuator control system.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Enable the actuator control system.\"\"\"\n    ...\n</code></pre>"},{"location":"python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.stop","title":"<code>stop()</code>","text":"<p>Disable the actuator control system.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Disable the actuator control system.\"\"\"\n    ...\n</code></pre>"},{"location":"python_api/cli/","title":"Command line interface (CLI)","text":"<p>The Command Line Interface (CLI) is included in the python package. It provides a convenient way to interact with the actuator directly from a terminal. This is particularly useful for quick communication test and for scanning devices on a CAN bus.</p>"},{"location":"python_api/cli/#verifying-the-installation","title":"Verifying the Installation","text":"<p>The CLI is installed along the python package. To confirm that the CLI is working correctly, you can run the following command:</p> <p><pre><code>pulsar-cli -h\n</code></pre> This should print the help message.</p>"},{"location":"python_api/cli/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides several commands to interact with the Pulsar actuator. Here are some common commands:</p>"},{"location":"python_api/cli/#scan-for-devices","title":"Scan for Devices","text":"<p><pre><code>pulsar-cli scan -p &lt;port&gt;\n</code></pre> This command scans the CAN bus for connected Pulsar devices and lists their IDs and statuses. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the CAN to USB adapter (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows). Use the <code>-h</code> flag to see more options</p>"},{"location":"python_api/cli/#get-device-parameters","title":"Get Device parameters","text":"<p><pre><code>pulsar-cli params -p &lt;port&gt;\n</code></pre> When connected to a device via USB, you can retrieve all the parameters of the device. This command will display the current configuration of the actuator. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the actuator (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows).</p>"},{"location":"python_api/example_advanced_features/","title":"Advanced Features","text":"<p>This example demonstrates advanced configuration and control of a PULSAR HRI actuator. It builds upon the basic example.</p> <p>In this document you will learn how to:</p> <ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"python_api/example_advanced_features/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>The code shows several features of the PULSAR HRI actuator:</p>"},{"location":"python_api/example_advanced_features/#changes-the-actuators-address","title":"Changes the actuator's address","text":"<p>Sets a new address. This gets stored in the actuator's persistent memory, so it will be retained across power cycles. For actuators we recommend to use addresses from 0x10 (16) Lower addresses are reserved for adapters and special purposes.</p> <pre><code>actuator.changeAddress(0x15)\n</code></pre>"},{"location":"python_api/example_advanced_features/#resets-the-encoder-to-define-a-new-zero-position","title":"Resets the encoder to define a new zero position","text":"<pre><code>actuator.reset_encoder_position()\n</code></pre>"},{"location":"python_api/example_advanced_features/#applies-performance-profiles-for-torque-and-speed","title":"Applies performance profiles for torque and speed","text":"<p>The available performance profiles are defined in the <code>PulsarActuator.TorquePerformance</code> and <code>PulsarActuator.SpeedPerformance</code></p> <pre><code>actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\nactuator.set_speed_performance(PulsarActuator.SpeedPerformance.BALANCED)\n</code></pre>"},{"location":"python_api/example_advanced_features/#sets-custom-control-parameters","title":"Sets custom control parameters","text":"<p>The available parameters are defined in the <code>PulsarActuator.PCP_Parameters</code></p> <pre><code>actuator.set_parameters({\n    PulsarActuator.PCP_Parameters.K_DAMPING: 7.7,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS: 8.8,\n})\n</code></pre>"},{"location":"python_api/example_advanced_features/#saves-the-configuration-to-persistent-memory","title":"Saves the configuration to persistent memory","text":"<p>This will save the current configuration to the actuator's persistent memory, so it will be retained across power cycles.</p> <pre><code>actuator.save_config()\n</code></pre>"},{"location":"python_api/example_advanced_features/#reads-back-parameters","title":"Reads back parameters","text":"<p>This will read back the current configuration from the actuator.</p> <pre><code>params = actuator.get_parameters([\n    PulsarActuator.PCP_Parameters.MODE,\n    PulsarActuator.PCP_Parameters.SETPOINT,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS,\n])\n# params = actuator.get_parameters_all()\npprint(params)\n</code></pre>"},{"location":"python_api/example_advanced_features/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection\n\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\n\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator 0x{actuator.address:X} ({actuator.address})\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to {actuator.model} at address 0x{actuator.address:X} ({actuator.address})  firmware: v{actuator.firmware_version}\")\n\n# Define actual position as zero position\nactuator.reset_encoder_position()\n\n# Change the actuator's address\nactuator.changeAddress(0x15)\n\n# Set performance modes\nactuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\nactuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n# Set control parameters\nactuator.set_parameters({\n    PulsarActuator.PCP_Parameters.K_DAMPING: 7.7,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS: 8.8,\n})\n\n# Optional: Save configuration to persistent memory\n# actuator.save_config()\n\n# Read back parameters \nparams = actuator.get_parameters([\n    PulsarActuator.PCP_Parameters.MODE,\n    PulsarActuator.PCP_Parameters.SETPOINT,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS,\n])\n# params = actuator.get_parameters_all()\npprint(params)\n\nadapter.close()\n</code></pre>"},{"location":"python_api/example_log_to_csv/","title":"Log Data to CSV","text":"<p>This script is an example of how to log data from a PULSAR HRI actuator. It doesn't show live data, but instead logs it to a CSV file for later analysis. The full example is at the bottom of the page.</p>"},{"location":"python_api/example_log_to_csv/#common-code","title":"Common code","text":"<p>Most of the code is common to all examples, so we will not repeat it here. You can find the common code in the first example.</p>"},{"location":"python_api/example_log_to_csv/#select-the-items-to-log","title":"Select the items to log","text":"<p>You can put the items to log from the actuator, in a list. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>POSITION_FB</code>, <code>TORQUE_SENS</code>, <code>SPEED_FB</code>, ... In this example, we will log the current in the three phases of the motor, which are <code>IA</code>, <code>IB</code>, and <code>IC</code>. </p> <pre><code>itemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n</code></pre>"},{"location":"python_api/example_log_to_csv/#preparing-csv-logging","title":"Preparing CSV Logging","text":"<p>This opens a CSV file for writing. The key thing is to order the items in the same way they are logged. As the items are defined in an enum, you can sort them by name to ensure a consistent order.</p> <pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"python_api/example_log_to_csv/#callback-function-for-feedback","title":"Callback function for feedback","text":"<p>The callback function, instead of showing the feedback in real-time, like the other examples, it directly logs the data into a file, which allows for higher rates. The feedback data is a dictionary, where the keys are <code>PulsarActuator.PCP_Items</code> and the values are the corresponding values. Again, we sort the keys by name to ensure a consistent order in the CSV file.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n</code></pre>"},{"location":"python_api/example_log_to_csv/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<p>We are going to use only high-frequency feedback at 1kHz.</p> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"python_api/example_log_to_csv/#start-actuator","title":"Start Actuator","text":"<p>Like in the other examples, we can choose the control mode, setpoint, other parameters (not shown here) and start the actuator. In this example, we are going the let it run for 3 seconds.</p> <pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\nsleep(3)  # actuator_feedback() should be triggered during this time\n</code></pre>"},{"location":"python_api/example_log_to_csv/#run-and-cleanup","title":"Run and Cleanup","text":"<p>Make sure to close the file, stop the actuator and  close the adapter at the end. </p> <pre><code>actuator.disconnect()  # also stops the actuator\nadapter.close()\nfile.close()\n</code></pre>"},{"location":"python_api/example_log_to_csv/#example-output","title":"Example output","text":"<p>This code will generate a CSV file named <code>log.csv</code> with the logged data. The first column is the timestamp, and the subsequent columns are the values of the items you logged. The output will look like this:</p> Timestamp IA IB IC 1642780800.123 0.15 -0.08 0.12 1642780800.124 0.16 -0.09 0.13 1642780800.125 0.17 -0.10 0.14"},{"location":"python_api/example_log_to_csv/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n\n\nitemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, 0)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\nactuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\nfile = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n\n\nactuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\ntry:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre>"},{"location":"python_api/example_several_actuators/","title":"Controlling Several Devices","text":"<p>This example demonstrates how to control multiple PULSAR HRI actuators. We will walk through the steps of connecting to the CAN to USB adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p> <p>The physical connection for this example (two actuators and the CAN to USB adapter) is shown in the image below. The actuators are connected to the CAN bus via an adapter, which is connected to the host computer via USB.</p> <p></p> <p>Warning</p> <p>Do not forget the termination resistors (TR) at the ends of the CAN bus.</p> <p>The schema shows actuators with addresses 0x10 and 0x11, but you need to find out the actual addresses of your devices. For that you can either use the CLI scan command or use the Desktop App to change their address.</p>"},{"location":"python_api/example_several_actuators/#import-necessary-modules","title":"Import necessary modules","text":"<p>We import the necessary modules.</p> <pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"python_api/example_several_actuators/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>We auto-detect the USB port to which the CAN to USB adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> <pre><code>ACTUATOR_ADDRESSES = [0x10, 0x11]  # Use the actual addresses of your actuators\n\n# Auto-detect CAN to USB adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"python_api/example_several_actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. You can define individual functions for each actuator, or use a single function for all actuators. In this example, we are going to extract the position from the feedback dict, and prints it along with the actuator's address.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"python_api/example_several_actuators/#initialize-actuators-and-set-common-configuration","title":"Initialize Actuators and set common configuration","text":"<p>We create a loop to initialize each actuator using its address. Each actuator is connected, configured for high-frequency feedback, and set to SPEED mode. The same feedback callback function is registered to handle incoming feedback from the actuators. (Individual callback functions is also possible)</p> <pre><code>actuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n        # Add other items if needed\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    # Add the actuator to the list\n    actuators.append(actuator)\n</code></pre>"},{"location":"python_api/example_several_actuators/#individual-actuator-configuration","title":"Individual Actuator Configuration","text":"<p>We assign different configuration to each actuator. In this case, only the speed.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n</code></pre>"},{"location":"python_api/example_several_actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We start all actuators and let them run. The feedback will be printed in the console. When the program is interrupted (e.g., via Ctrl+C ), we ensure all actuators are properly disconnected and the adapter is closed.</p> <pre><code># Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    while True:\n        sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"python_api/example_several_actuators/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n# Example PCP addresses for two actuators\nACTUATOR_ADDRESSES = [0x10, 0x11]\n\ndef actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n\n# Auto-detect CAN to USB adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n\nactuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n\n# Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    while True:\n        sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"python_api/example_single_actuator/","title":"Controlling One Device","text":"<p>Learn how to control a Pulsar actuator through a step-by-step walkthrough covering connection setup, configuration, and basic motion control. The full example is at the bottom of the page.</p>"},{"location":"python_api/example_single_actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"python_api/example_single_actuator/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>Pulsar devices understand the PCP protocol, which can be transmitted over USB or CAN. The devices have a built-in USB interface, so you can connect directly to the actuator via USB. Alternatively, you can use a CAN to USB adapter to connect to the actuator over a CAN bus. This adapter is connected to the host computer via USB, so in both cases, you will use the <code>PCP_over_USB</code> class to create the adapter.</p> <pre><code>port = \"COM1\"  # you need to specify the port of the device or the CAN to USB adapter\n# port = PCP_over_USB.get_port()  # there is also an auto-detect system that will find the first available port\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"python_api/example_single_actuator/#instantiate-the-actuator","title":"Instantiate the actuator","text":"<p>You can instantiate as many actuators as you want with the same CAN adapter. In this example we are going to control only one actuator, connected directly via USB. If you are using a CAN adapter, you need to specify the PCP address of the actuator. The PCP address is a unique identifier for each actuator. You can find this address with the  CLI scan command. If you are connecting directly via USB, use <code>0</code> as the address.</p> <pre><code>ACTUATOR_ADDRESS = 0  # 0 for direct USB connection, or use the actuator address if using CAN adapter\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\nactuator.connect()\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n</code></pre>"},{"location":"python_api/example_single_actuator/#configure-feedback","title":"Configure feedback","text":"<p>First, define a function to handle the feedback from the actuator. This function will be called whenever new feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n</code></pre> <p>Set up the feedback configuration:</p> <ul> <li>High-frequency feedback for data like speed, position, torque, ...</li> <li>Low-frequency feedback for data like bus voltage, temperatures....</li> </ul> <p>You can set the feedback items you want to receive. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>SPEED_FB</code>, <code>POSITION_FB</code>, <code>TORQUE_FB</code>, <code>VBUS</code>, <code>TEMP_MOTOR</code>, etc.</p> <p>You can set the feedback rate for each type of feedback. The rates are defined in <code>PulsarActuator.Rates</code>, and you can choose from <code>RATE_1HZ</code>, <code>RATE_10HZ</code>, <code>RATE_100HZ</code>, <code>RATE_1KHZ</code>, or <code>DISABLED</code> to disable the feedback.</p> Configure feedback and control settings<pre><code>actuator.setHighFreqFeedbackItems([\n    PulsarActuator.PCP_Items.SPEED_FB,\n    PulsarActuator.PCP_Items.POSITION_FB,\n    PulsarActuator.PCP_Items.TORQUE_FB,\n    # You can add more items as needed\n])\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n# Low-frequency feedback includes bus voltage and motor temperature.\nactuator.setLowFreqFeedbackItems([\n    PulsarActuator.PCP_Items.VBUS,\n    PulsarActuator.PCP_Items.TEMP_MOTOR,\n])\nactuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n# Set the feedback callback function to handle the feedback data\nactuator.set_feedback_callback(actuator_feedback)\n\n# feedback_callback can be set to None to disable it\n# and read the feedback manually with actuator.get_feedback()\n</code></pre> <p>As an alternative, do not set a callback function or call <code>actuator.set_feedback_callback(None)</code> and read the feedback manually using <code>feedback = actuator.get_feedback()</code>, but using a callback function is more efficient and allows you to process the feedback in real-time.</p>"},{"location":"python_api/example_single_actuator/#configure-control-settings","title":"Configure control settings","text":"<p>You can choose from different control modes, such as <code>SPEED</code>, <code>POSITION</code>, or <code>TORQUE</code>. These are defined in <code>PulsarActuator.Mode</code> In this example, we will use the speed mode. You can now set the setpoint for the actuator, which is the target speed in this case. The units are in SI (International System of Units), so the speed is in radians per second (rad/s), position in radians, and torque in Newton-meters (Nm).</p> SpeedTorquePosition Configure control speed<pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)  # rad/s\n</code></pre> Configure control torque<pre><code>actuator.change_mode(PulsarActuator.Mode.TORQUE)\nactuator.change_setpoint(2.0)  # Nm\n</code></pre> Configure control position<pre><code>actuator.change_mode(PulsarActuator.Mode.POSITION)\nactuator.reset_encoder_position()  # current position will be treated as 0\nactuator.change_setpoint(3.1416)  # rad\n</code></pre>"},{"location":"python_api/example_single_actuator/#start-the-actuator","title":"Start the actuator","text":"<p>You can start the actuator with the current configuration with the <code>start()</code> method. This will begin the control loop and the actuator will start moving according to the setpoint you defined. The feedback will be received at the rates you configured earlier. Its advisable to put these logic in a try-except block to ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C)</p> Shutdown<pre><code>try:\n    # Put the configuration and control code here\n    actuator.start()\n    # The loop will keep running until interrupted (e.g., via Ctrl+C).\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # will also stop the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"python_api/example_single_actuator/#full-example","title":"Full Example","text":"SpeedTorquePosition Full code Speed<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre> Full code Torque<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    actuator.change_mode(PulsarActuator.Mode.TORQUE)\n    actuator.change_setpoint(2.0)  # Nm\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre> Full code Position<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n\n    actuator.change_mode(PulsarActuator.Mode.POSITION)\n    actuator.reset_encoder_position()  # current position will be treated as 0\n    actuator.change_setpoint(3.1416)  # rad\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"python_api/install_python_api/","title":"Install Python API","text":"<p>In this document we will guide you through the installation of the PULSAR HRI Python API, which allows you to programmatically control and interact with PULSAR actuators.</p>"},{"location":"python_api/install_python_api/#installation","title":"Installation","text":"<p>You can use a virtual environment to install this and other packages for your project. There are several ways to create a virtual environments. In this guide, we will skip the virtual environment and install the PULSAR HRI Python API globally.</p> <pre><code>pip install pcp_api\n</code></pre>"},{"location":"python_api/install_python_api/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>pip show pcp_api\n</code></pre> This should provide information about the installed package, including its version and location. If you see this information, the installation was successful.</p>"},{"location":"python_api/install_python_api/#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Use the Command line interface to quickly interact with the PULSAR hardware.</li> <li>Run the example scripts</li> <li>Explore the code documentation for detailed usage instructions.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please open an issue issue.</p>"}]}