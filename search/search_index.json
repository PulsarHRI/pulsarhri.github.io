{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Classes-02-ConnectionAndAdress/","title":"Connection and Address Management","text":"<p>The <code>PulsarActuator</code> class provides methods to establish and terminate communication with an actuator, verify its availability, and configure its CAN address.</p>"},{"location":"Classes-02-ConnectionAndAdress/#connecting-to-the-actuator","title":"Connecting to the Actuator","text":"<p>To initiate communication with an actuator, use the <code>connect()</code> method. * Description: Sends a PING message to the actuator and waits for a PONG response within the specified timeout period.</p> <ul> <li>Parameters: timeout (float, optional): Maximum time to wait for a response, in seconds. Default is 1.0.</li> <li>Returns: True if the actuator responds within the timeout window, False otherwise.</li> <li>Usage Example: <pre><code>if actuator.connect():\n    print(\"Actuator connected successfully.\")\nelse:\n    print(\"Failed to connect to actuator.\")\n</code></pre></li> </ul>"},{"location":"Classes-02-ConnectionAndAdress/#disconnecting-from-the-actuator","title":"Disconnecting from the Actuator","text":"<p>To safely terminate communication, use the <code>disconnect()</code> method:</p> <ul> <li>Description: Sends a STOP command to the actuator to halt any ongoing operations and ensure a safe disconnection.</li> <li>Usage Example:  <pre><code>actuator.disconnect()\n</code></pre></li> </ul>"},{"location":"Classes-02-ConnectionAndAdress/#pinging-the-actuator","title":"Pinging the Actuator","text":"<p>To check if a specific CAN address is active and responsive, use the send_ping() method. * Description: Sends a PING message and waits for a PONG response.</p> <ul> <li>Parameters: timeout (float, optional): Time to wait for a response, in seconds. Default is 1.0. Returns: True if a response is received within the timeout, False otherwise.</li> </ul> <p>Usage Example: <pre><code>if actuator.send_ping():\n    print(\"Actuator is responsive.\")\nelse:\n    print(\"No response from actuator.\")\n</code></pre></p>"},{"location":"Classes-02-ConnectionAndAdress/#changing-the-actuators-can-address","title":"Changing the Actuator's CAN Address","text":"<p>By default, actuators may start with a randomly assigned CAN address. To integrate the actuator into a known network configuration, you can assign it a specific address using: <pre><code>changeAddress(new_address)\n</code></pre> * Parameters: new_address (int): The new CAN address to assign. Must be within the valid range: <pre><code>0x10 \u2264 new_address \u2264 0x3FFE\n</code></pre> * Usage Example:  <pre><code>actuator.changeAddress(0x20)\n</code></pre></p> <p>Important</p> <p>Make sure to assign a unique CAN address to each actuator to avoid communication conflicts on the network.</p>"},{"location":"Classes-03-Feedback/","title":"Feedback Configuration from the PULSAR HRI Actuator","text":"<p>To efficiently manage data flow and avoid saturating the CAN bus, the PulsarActuator API supports two feedback channels with configurable update rates:</p> <ul> <li>High-Frequency Feedback: For fast-changing signals (e.g., torque, speed).</li> <li>Low-Frequency Feedback: For slower or less critical signals (e.g., temperature, voltage). Each channel allows you to specify:</li> <li>Which feedback items to receive.</li> <li>The rate at which they are updated.</li> </ul>"},{"location":"Classes-03-Feedback/#high-frequency-feedback","title":"\ud83d\udd01 High-Frequency Feedback","text":""},{"location":"Classes-03-Feedback/#sethighfreqfeedbackitemsitems-list","title":"setHighFreqFeedbackItems(items: list)","text":"<p>Sets the list of feedback items to be sent at high frequency.</p> <ul> <li>Parameters: <code>items</code> A list of PulsarActuator.PCP_Items enums (see Table 1).</li> </ul>"},{"location":"Classes-03-Feedback/#sethighfreqfeedbackraterate-rates","title":"setHighFreqFeedbackRate(rate: Rates)","text":"<p>Sets the update rate for high-frequency feedback.</p> <ul> <li>Parameters: <code>rate</code> A value from the PulsarActuator.Rates enum (see Table 2).</li> </ul>"},{"location":"Classes-03-Feedback/#low-frequency-feedback","title":"\ud83d\udd52 Low-Frequency Feedback","text":""},{"location":"Classes-03-Feedback/#setlowfreqfeedbackitemsitems-list","title":"setLowFreqFeedbackItems(items: list)","text":"<p>Sets the list of feedback items to be sent at low frequency.</p> <ul> <li>Parameters: <code>items</code> A list of PulsarActuator.PCP_Items enums.</li> </ul>"},{"location":"Classes-03-Feedback/#setlowfreqfeedbackraterate-rates","title":"setLowFreqFeedbackRate(rate: Rates)","text":"<p>Sets the update rate for low-frequency feedback.</p> <ul> <li>Parameters: <code>rate</code> A value from the PulsarActuator.Rates enum.</li> </ul>"},{"location":"Classes-03-Feedback/#receiving-feedback","title":"\ud83d\udce1 Receiving Feedback","text":"<p>To handle incoming feedback, you can register a callback function.</p>"},{"location":"Classes-03-Feedback/#set_feedback_callbackcallback-callable-none","title":"set_feedback_callback(callback: callable) -&gt; None","text":"<p>Registers a function to be called whenever new feedback is received. * Parameters: <code>callback</code> A callable that will be executed with each feedback update.</p>"},{"location":"Classes-03-Feedback/#table-1-configurable-feedback-items-pcp_items-enum","title":"\ud83d\udcd8 Table 1 \u2013 Configurable Feedback Items (<code>PCP_Items</code> Enum)","text":"Enum Name Code Description <code>ENCODER_INT</code> 0x41 Internal encoder position (rads) <code>ENCODER_INT_RAW</code> 0x42 Raw internal encoder value (uint32) <code>ENCODER_EXT</code> 0x43 External encoder position (rads) <code>ENCODER_EXT_RAW</code> 0x44 Raw external encoder value (uint32) <code>SPEED_FB</code> 0x45 Output speed (rad/s) <code>IA</code>, <code>IB</code>, <code>IC</code> 0x46\u20130x48 Phase currents A, B, C (Amps) <code>TORQUE_SENS</code> 0x49 Measured torque (Nm) <code>TORQUE_SENS_RAW</code> 0x4A Raw torque sensor value (uint32) <code>POSITION_REF</code> 0x4B Position mode command (rads) <code>POSITION_FB</code> 0x4C Actual position (rads) <code>SPEED_REF</code> 0x4D Speed mode command (rad/s) <code>ID_REF</code>, <code>ID_FB</code> 0x4F\u20130x50 Direct current reference and feedback (Amps) <code>IQ_REF</code>, <code>IQ_FB</code> 0x51\u20130x52 Quadrature current reference and feedback (Amps) <code>VD_REF</code>, <code>VQ_REF</code> 0x53\u20130x54 DVI mode voltage references (Volts) <code>TORQUE_REF</code>, <code>TORQUE_FB</code> 0x55\u20130x56 Torque command and feedback (Nm) <code>ENABLE</code> 0x57 Actuator enabled state (0/1) <code>ERRORS_ENCODER_INT</code> 0x60 Internal encoder error count <code>ERRORS_ENCODER_EXT</code> 0x61 External encoder error count <code>ERRORS_OVERRUN</code> 0x62 Loop overrun count <code>VBUS</code> 0x70 Bus voltage <code>TEMP_PCB</code> 0x71 PCB temperature <code>TEMP_MOTOR</code> 0x72 Motor winding temperature"},{"location":"Classes-03-Feedback/#table-2-feedback-rates-rates-enum","title":"\u23f1\ufe0f Table 2 \u2013 Feedback Rates (<code>Rates</code> Enum)","text":"Enum Name Value Update Frequency <code>DISABLED</code> 0 Disabled <code>RATE_1KHZ</code> 10 1,000 Hz <code>RATE_100HZ</code> 100 100 Hz <code>RATE_50HZ</code> 200 50 Hz <code>RATE_10HZ</code> 1,000 10 Hz <code>RATE_5HZ</code> 2,000 5 Hz <code>RATE_2HZ</code> 5,000 2 Hz <code>RATE_1HZ</code> 10,000 1 Hz <p>Important</p> <p>To optimize CAN bus performance, only enable the feedback items and rates necessary for your application.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/","title":"Reading and Modifying Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#reading-actuator-parameters","title":"Reading Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Retrieve all configuration parameters of the actuator at once.</p> <p>Returns: - <code>dict</code>: A dictionary containing all parameters and their values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#get_parametersparameters-timeout10","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Retrieve specific parameters from the actuator.</p> <p>Parameters: - <code>parameters</code> (list): A list of parameters to request (see Table 3). - <code>timeout</code> (float, optional): Maximum time to wait for a response, in seconds. Default is <code>1.0</code>.</p> <p>Returns: - <code>dict</code>: A dictionary containing the requested parameters and their values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#modifying-actuator-parameters","title":"Modifying Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#set_parametersparameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Modify specific parameters of the actuator.</p> <p>Parameters: - <code>parameters</code> (dict): A dictionary with <code>PCP_Parameters</code> enums as keys and their corresponding values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#table-3-pcp_parameters-enum","title":"Table 3 \u2013 <code>PCP_Parameters</code> Enum","text":"Enum Name Code Description <code>K_DAMPING</code> 0x01 Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control) <code>K_STIFFNESS</code> 0x02 Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control) <code>TORQUE_FF</code> 0x03 Feedforward Torque Value (Nm) <code>LIM_TORQUE</code> 0x04 Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm) <code>LIM_POSITION_MAX</code> 0x05 Max. Position Limit (rad) <code>LIM_POSITION_MIN</code> 0x06 Min. Position Limit (rad) <code>LIM_SPEED_MAX</code> 0x07 Max. Speed Limit (rad/s) <code>LIM_SPEED_MIN</code> 0x08 Min. Speed Limit (rad/s) <code>PROFILE_POSITION_MAX</code> 0x09 Max. Positive Speed (rad/s) in Position control configuration <code>PROFILE_POSITION_MIN</code> 0x0A Min. Negative Speed (rad/s) in Position control configuration <code>PROFILE_SPEED_MAX</code> 0x0B Max. Acceleration (rad/s^2) in Speed control configuration <code>PROFILE_SPEED_MIN</code> 0x0C Max. Deceleration (rad/s^2) in Speed control configuration <code>KP_SPEED</code> 0x0D Kp speed control constant P value <code>KI_SPEED</code> 0x0E Ki speed control constant I value <code>KP_POSITION</code> 0x0F Kp position control constant P value <code>MODE</code> 0x30 Operation Mode (read-only, must be set via <code>CHANGE_MODE</code>) <code>SETPOINT</code> 0x31 Setpoint, Position (rad), Speed (rad/s), Torque (Nm) <code>FIRMWARE_VERSION</code> 0x80 Firmware version <p>Important</p> <p>Ensure that the parameters you modify are within the valid range and do not conflict with other settings to avoid improper actuator behavior.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#use-of-profiles-and-limits","title":"Use of profiles and limits","text":"<p>The use of position, speed or torque limits apply a saturation to the input reference of the corresponding control.</p> <p>The profile options provide the posibility of doing trapezoidal reference changes. Below there are some examples.</p> <ul> <li>Setting the Max positive speed (rad/s) to 5 rad/s and using the position control.</li> </ul> <p></p> <p>Speed (rad/s) = (0.5 \u00b7 2 \u00b7 pi) / 0.630 = 5 (rad/s)</p> <ul> <li>Setting the Max acceleration (rad/s2) to 100 rad/s2 and using the speed control.</li> </ul> <p></p> <p>Acceleration (rad/s^2) = 2.33 / 0.0234 = 100 (rad/s^2)</p>"},{"location":"Classes-05-PerformanceProfiles/","title":"Predefined Performance Profiles for Actuator Control","text":"<p>The actuator provides a set of predefined performance profiles for both torque and speed control loops. These profiles allow users to easily configure the system's responsiveness without manually tuning low-level control parameters. Each profile adjusts the bandwidth and stability of the inner control loops, which is essential for achieving optimal behavior in dynamic or high-precision applications.</p>"},{"location":"Classes-05-PerformanceProfiles/#torque-control-loop-performance","title":"Torque Control Loop Performance","text":"<p>This setting determines how quickly and aggressively the actuator responds to torque commands. The available profiles are:</p>"},{"location":"Classes-05-PerformanceProfiles/#aggressive","title":"AGGRESSIVE","text":"<ul> <li>Bandwidth: ~1000 Hz  </li> <li>Behavior: Maximizes responsiveness and torque application speed.  </li> <li>Use Case: Ideal for dynamic tasks such as impedance control or joint torque control.  </li> <li>Trade-off: May reduce steady-state precision.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#balanced","title":"BALANCED","text":"<ul> <li>Bandwidth: ~500 Hz  </li> <li>Behavior: Offers a compromise between responsiveness and stability.  </li> <li>Use Case: Suitable for general-purpose applications.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#soft","title":"SOFT","text":"<ul> <li>Bandwidth: ~100 Hz  </li> <li>Behavior: Prioritizes smoothness and precision over speed.  </li> <li>Use Case: Best for tasks requiring high torque fidelity and low noise.  </li> <li>Trade-off: Lower responsiveness.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#custom-if-supported","title":"CUSTOM (if supported)","text":"<ul> <li>Behavior: Allows manual tuning of control gains.  </li> <li>Use Case: For advanced users with specialized requirements.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#api-command","title":"API Command","text":"<p><pre><code>set_torque_performance(self, performance: TorquePerformance)\n</code></pre> - Parameter: <code>performance</code>   - Type: <code>PulsarActuator.TorquePerformance</code>   - Description: Sets the desired torque control profile.</p>"},{"location":"Classes-05-PerformanceProfiles/#table-4-torqueperformance-enum","title":"Table 4 \u2013 <code>TorquePerformance</code> (Enum)","text":"Name Value Bandwidth (Hz) Description AGGRESSIVE 1 ~1000 Hz Fast response, less precision in steady state BALANCED 2 ~500 Hz Balanced between response and stability SOFT 3 ~100 Hz Stable and quiet, low responsiveness"},{"location":"Classes-05-PerformanceProfiles/#speed-loop-performance","title":"Speed Loop Performance","text":"<p>The speed control loop uses the same predefined profiles as the torque loop, ensuring consistent behavior tuning across both control domains.</p>"},{"location":"Classes-05-PerformanceProfiles/#aggressive_1","title":"AGGRESSIVE","text":"<ul> <li>Behavior: Enables rapid speed tracking with minimal delay and short settling time.</li> <li>Use Case: High-speed applications where quick velocity changes are required.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#balanced_1","title":"BALANCED","text":"<ul> <li>Behavior: Provides a well-rounded compromise between speed and stability.</li> <li>Use Case: Suitable for general-purpose motion control tasks.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#soft_1","title":"SOFT","text":"<ul> <li>Behavior: Emphasizes smooth, accurate motion over speed.</li> <li>Use Case: Ideal for applications requiring low noise and precise velocity regulation.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#custom","title":"CUSTOM","text":"<ul> <li>Behavior: Grants full control over PI controller gains.</li> <li>Use Case: Advanced tuning for specialized systems or experimental setups.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#api-command_1","title":"API Command","text":"<p>To configure the speed loop performance, use the following API method:</p> <pre><code>set_speed_performance(self, performance: SpeedPerformance)\n</code></pre>"},{"location":"Classes-05-PerformanceProfiles/#parameter-performance","title":"Parameter: <code>performance</code>","text":"<ul> <li>Type: <code>PulsarActuator.SpeedPerformance</code></li> <li>Description: Sets the desired speed control profile.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#table-5-speedperformance-enum","title":"Table 5 \u2013 <code>SpeedPerformance</code> (Enum)","text":"Name Value Description AGGRESSIVE 1 Aggressive speed control profile BALANCED 2 Balanced speed control profile SOFT 3 Soft speed control profile CUSTOM 4 Custom-defined profile"},{"location":"Classes-06-ActuatorOperation/","title":"Actuator Operation: Startup, Shutdown, and Control Modes","text":""},{"location":"Classes-06-ActuatorOperation/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"Classes-06-ActuatorOperation/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>Important</p> <p>DO NOT USE THIS MODE UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>When the actuator is powered on with the control mode set to Calibration, the system performs an automatic offset calibration. This process aligns the electrical position of the motor with the mechanical position of the encoder, ensuring accurate motion control.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"Classes-06-ActuatorOperation/#1-electromagnetic-torque-control","title":"1. Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p>"},{"location":"Classes-06-ActuatorOperation/#2-speed-control","title":"2. Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p>"},{"location":"Classes-06-ActuatorOperation/#3-position-control","title":"3. Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#4-impedance-control-under-development","title":"4. Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p>"},{"location":"Classes-06-ActuatorOperation/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"Classes-06-ActuatorOperation/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p>"},{"location":"Classes-06-ActuatorOperation/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p>"},{"location":"Classes-06-ActuatorOperation/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p>"},{"location":"Classes-06-ActuatorOperation/#changing-control-modes","title":"Changing Control Modes","text":"<p>To switch between control modes, use the following method:</p> <p>Parameters:</p> <ul> <li><code>mode (PulsarActuatorMode)</code>: The desired control mode to activate. Refer to Table 6 for a complete list of available modes and their descriptions.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#table-6-mode-enum","title":"Table 6 \u2013 Mode (Enum)","text":"Mode Name Enum Value Description CALIBRATION <code>0x01</code> Calibration mode FVI <code>0x02</code> Fixed Voltage Injection OPEN_LOOP <code>0x03</code> Open-loop control DVI <code>0x04</code> Direct Voltage Injection (field-oriented) TORQUE <code>0x05</code> Electromagnetic Torque Control SPEED <code>0x06</code> Speed Control POSITION <code>0x07</code> Position Control IMPEDANCE <code>0x08</code> Impedance Control"},{"location":"Classes-06-ActuatorOperation/#set-zero-position","title":"Set Zero Position","text":"<p>The Set Zero Position command is used to redefine the actuator's current physical location as the new reference point, or \"zero\" position, for all subsequent position-based operations. For Position or Impedance Mode, defining a consistent starting point is critical. Therefore, before commanding absolute positions, you must perform a zero-positioning action to establish the actuator's current location as the reference zero. Failure to do so will result in unpredictable or incorrect absolute positioning.</p> <p><code>reset_encoder_position(self)</code>: Resets the encoder absolute position to 0.</p>"},{"location":"Classes-06-ActuatorOperation/#actuator-control-start-and-stop","title":"Actuator Control: Start and Stop","text":"<p>Once the actuator has been configured with the desired control mode and setpoint, these methods are used to initiate and cease its motion. </p> <p>To initiate the actuator's operation, causing it to reach and maintain its configured setpoint according to the active control mode, use the following command: </p> <p><code>start()</code>:  Starts the actuator. </p> <p>To halt the actuator's current motion and operation, use the following command: </p> <p><code>stop()</code>: Stops the actuator. </p>"},{"location":"Classes-06-ActuatorOperation/#save-configuration","title":"Save configuration","text":"<p>After configuring the actuator parameters (e.g., control mode, gains, limits), it is important to store the current settings to ensure they persist after a power cycle. The command that saves the current actuator configuration to non-volatile memory\u2014making it the default startup configuration\u2014is: </p> <p><code>save_config(self)</code>: Saves the current configuration of the actuator in the non-volatile memory.</p>"},{"location":"Classes-06-ActuatorOperation/#actuator-calibration","title":"Actuator calibration","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero. This command should not be used.</p> <p>The command to perform the actuator calibration is: </p> <p><code>calibrate()</code>: Calibrates the actuator.</p> <p>Important</p> <p>Note that not all parameters apply to every control mode; refer to Table 7 for specific usage information. </p>"},{"location":"Classes-06-ActuatorOperation/#table-7-use-of-the-parameters-depending-on-the-control-type","title":"Table 7 \u2013 Use of the parameters depending on the control type","text":"Parameter Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Torque loop performance No No No No Yes Yes Yes Yes Speed loop performance No No No No No Yes Yes No Kp position No No No No No No Yes No Kp speed No No No No No Yes (if custom selected) Yes (if custom selected) No Ki speed No No No No No Yes (if custom selected) Yes (if custom selected) No Stiffness gain No No No No No No No Yes Damping gain No No No No No No No Yes FF torque No No No No No No No Yes Max positive speed (rad/s) (Profile) No No No No No No Yes No Min negative speed (rad/s) (Profile) No No No No No No Yes No Max acceleration (rad/s\u00b2) (Profile) No No No No No Yes Yes No Max deceleration (rad/s\u00b2) (Profile) No No No No No Yes Yes No Max speed (rad/s) No No No No No Yes Yes No Min speed (rad/s) No No No No No Yes Yes No Max position (rad) No No No No No No Yes Yes Min position (rad) No No No No No No Yes Yes Max absolute torque (Nm) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes Yes Yes Yes"},{"location":"classes-01-InitialisationContrustor/","title":"Initialization and Constructor","text":"<p>To create an instance of the <code>PulsarActuator</code> class, you must provide a CAN bus handler (commonly referred to as an adapter) and the actuator\u2019s CAN address. Optionally, you may also supply a custom logger for debugging and monitoring purposes.</p>"},{"location":"classes-01-InitialisationContrustor/#python-usage","title":"Python Usage","text":"<pre><code>PulsarActuator(canbus_handler, address: int, logger=None)\n</code></pre>"},{"location":"classes-01-InitialisationContrustor/#parameters","title":"Parameters","text":"<ul> <li>canbus_handler (object):An object responsible for managing communication over the CAN bus. This handler must implement the method: <pre><code>setCallback(address, callback_fn)\n</code></pre> This method is used to register a callback function that processes incoming CAN messages for the specified actuator address.</li> <li>address(int): The unique CAN address assigned to the actuator. This address is used to identify and communicate with the specific device on the CAN network.</li> <li>logger(Logger,optional): A Python Logger instance used for logging internal events, warnings, and errors. If not provided, the class defaults to using Python\u2019s root logger.</li> </ul>"},{"location":"classes/","title":"Class Definitions","text":""},{"location":"classes/#overview-of-the-pulsaractuator-communication-interface","title":"Overview of the PulsarActuator Communication Interface","text":"<p>At the core of PCP (Pulsar Control Protocol) communication lies the PulsarActuator class. This class serves as the primary high-level interface for interacting with and managing a PULSAR HRI motor or actuator controller via the CAN (Controller Area Network) bus. It abstracts the complexities of low-level communication, providing developers with a streamlined and intuitive API for real-time control and monitoring.</p>"},{"location":"classes/#key-capabilities-of-the-pulsaractuator-api","title":"Key Capabilities of the PulsarActuator API","text":"<p>The PulsarActuator class offers a comprehensive suite of features designed to facilitate robust and flexible actuator control. These include:</p> <ul> <li>Real-Time Command and Control: Send precise control commands to the actuator in real time.</li> <li>Mode Switching: Seamlessly transition between various control modes such as torque, velocity, position, and impedance.</li> <li>Live Feedback Monitoring: Continuously receive and process real-time feedback from the actuator via CAN messages.</li> <li>Parameter Configuration and Management: Set, retrieve, and persist actuator parameters for fine-tuned performance.</li> <li>Diagnostics and Health Monitoring: Access diagnostic data to evaluate actuator status and detect potential issues.</li> </ul>"},{"location":"classes/#what-this-class-definition-covers","title":"What This Class Definition Covers","text":"<p>This manual provides detailed guidance on how to effectively use the PulsarActuator class to:</p>"},{"location":"classes/#operate-the-actuator-in-multiple-control-modes-including","title":"Operate the actuator in multiple control modes, including:","text":"<ul> <li>Torque Control: Apply a specific torque to the actuator.</li> <li>Speed Control: Regulate the actuator\u2019s rotational velocity.</li> <li>Position Control: Move the actuator to a defined position.</li> <li>Impedance Control: Combine position and force control for compliant motion.</li> </ul>"},{"location":"classes/#configure-and-query-actuator-parameters-such-as","title":"Configure and query actuator parameters, such as:","text":"<ul> <li>PID gains</li> <li>Safety limits</li> <li>Communication settings</li> </ul>"},{"location":"classes/#receive-and-interpret-real-time-feedback-including","title":"Receive and interpret real-time feedback, including:","text":"<ul> <li>Position, velocity, and torque readings</li> <li>Temperature and voltage levels</li> <li>Error and status flags</li> </ul>"},{"location":"classes/#modify-actuator-settings-and-perform-diagnostics-enabling","title":"Modify actuator settings and perform diagnostics, enabling:","text":"<ul> <li>Firmware updates</li> <li>Fault detection and recovery</li> <li>System calibration and tuning</li> </ul>"},{"location":"cli/","title":"CLI","text":"<p>The Command Line Interface (CLI) for the Pulsar API provides a convenient way to interact with the actuator directly from a terminal. This is particularly useful for quick communication test and for scanning devices on a CAN bus.</p>"},{"location":"cli/#verifying-the-installation","title":"Verifying the Installation","text":"<p>The CLI is installed along the python package. To confirm that the CLI is working correctly, you can run the following command:</p> <p><pre><code>pulsar-cli -h\n</code></pre> This should print the help message.</p>"},{"location":"cli/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides several commands to interact with the Pulsar actuator. Here are some common commands:</p>"},{"location":"cli/#scan-for-devices","title":"Scan for Devices","text":"<p><pre><code>pulsar-cli scan -p &lt;port&gt;\n</code></pre> This command scans the CAN bus for connected Pulsar devices and lists their IDs and statuses. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the CAN adapter (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows). Use the <code>-h</code> flag to see more options</p>"},{"location":"cli/#get-device-parameters","title":"Get Device parameters","text":"<p><pre><code>pulsar-cli params -p &lt;port&gt;\n</code></pre> Then connected to a device via USB, you can retrieve all the parameters of the device. This command will display the current configuration and status of the actuator. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the actuator (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows).</p>"},{"location":"00-home/00-home/","title":"Home","text":"<p>Welcome to the PULSAR HRI documentation! This documentation contains everything you need to begin working with the PULSAR HRI Actuators or PULSAR HRI Motors. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the packages, and accessing the documentation and examples.</p> <p>The PULSAR HRI packages is designed to provide a robust and flexible interface for controlling and monitoring PULSAR HRI hardware. It includes:</p> <ul> <li>A Python package for controlling the real hardware</li> <li>A Python package for controlling the digital twin (AUGUR)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"00-home/00-home/#overview-of-the-pulsar-hri-ecosystem","title":"Overview of the PULSAR HRI ecosystem","text":"<p>Note</p> <ul> <li>When we refer to motors we refer to direct drive motors without transmission</li> <li>When we refer to actuators we refer to motors with a transmission</li> </ul> <p>PULSAR HRI develops best-in-class actuation systems to enable the next generation of robotic capabilities. Our aim is to provide the highest possible performance in motors and actuators, defining excellence through novel metrics involving agility, torque-density, and efficiency. Our model-based design approach enables us to deliver high-performance actuators alongside high-fidelity digital twins (AUGUR). This documentation contains all the necessary resources to set up either a simulation or a physical configuration using our products.</p> <p></p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/","title":"How are PULSAR HRI motors and actuators different from the others?","text":"<p>Robotic applications require motors and actuators which can produce high torques at low speeds, while being able to change speed and torque in a reliable and agile manner. A key performance indicator often overlooked is dynamic efficiency, a critical requirement for mobile robots. </p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/#motors","title":"Motors","text":"<p>We provide our motors both on frameless and framed configurations. Your motor, your choice. Our range covers different sizes and torques to fit multiple applications, all of them delivering dynamic response (bandwidth) and torque density, while requiring low current to drive them. Both second electrical generation motors and custom design services can be unlocked by joining our Vanguard Program.\u200b</p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/#actuators","title":"Actuators","text":"<p>We design Quasi-Direct Drive (QDD) actuators offer a well-balanced alternative to traditional high-gear solutions.</p> <p>Design specifics also matter. Therefore, we decided to design our transmissions with a very low gear ratio to increase the total bandwidth, boost backdrivability, improve proprioceptiveness and better respond to highly-dynamic intermittent operations.</p> <p></p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/","title":"Installing the PULSAR HRI actuator API (pcp_api)","text":"<p>To ensure a clean and manageable development setup, we strongly recommend using a virtual environment. This helps isolate your dependencies and avoid conflicts with other Python packages on your system. All examples and functionality have been tested on Windows 11 using Python 3.12.10.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#installation","title":"Installation","text":""},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-1-create-a-virtual-environment","title":"Step 1: Create a Virtual Environment","text":"<p>Open your terminal or command prompt and run:</p> <p><pre><code>python -m venv .venv\n</code></pre> This will create a new virtual environment in a folder named .venv within your project directory.</p> <p>Warning</p> <p>The installation can be done in the root environment but we do not recommend it.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-2-activate-the-virtual-environment","title":"Step 2: Activate the Virtual Environment","text":"<p>Before installing the PULSAR HRI API, activate the virtual environment. The activation command depends on your operating system:</p> Linux/macOSWindows (PowerShell) <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Once activated, your terminal prompt should change to indicate that you're working inside the virtual environment.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-3-install-the-pulsar-hri-api","title":"Step 3: Install the PULSAR HRI API","text":"<p>With the virtual environment active, install the PULSAR HRI API package using <code>pip</code>:</p> <p><pre><code>pip install pcp_api\n</code></pre> This command will download and install the latest version of the pcp_api package from PyPI or your configured package index. </p> <p>Tip</p> <p>Every time you want to use the PULSAR HRI API or run the example scripts, make sure to activate your virtual environment first. If you close your terminal or restart your system, you\u2019ll need to reactivate it.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>pip show pcp_api\n</code></pre> This should provide information about the installed package, including its version and location. If you see this information, the installation was successful.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Use the CLI (command line interface) to quickly interact with the PULSAR hardware.</li> <li>Run example scripts provided in the examples directory.</li> <li>Explore the documentation for detailed usage instructions.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please open an issue in this repository project repository.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/","title":"Examples overview to control real hardware","text":"<p>Welcome to the Examples Overview section, where we guide you through practical applications of controlling real hardware using the PULSAR HRI API. Whether you're a beginner or an experienced developer, these examples will help you harness the full potential of our advanced actuation systems.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Controlling One Device: Start with the basics by learning how to control a single actuator in close loop speed control. This example will introduce you to fundamental commands and setup procedures.</li> <li>Controlling Two Devices: Learn how to manage two actuators simultaneously. Understand synchronization and coordination between multiple hardware components.</li> <li>Advanced Features: Explore the advanced functionalities of our actuators, including different control modes and real-time control.</li> <li>Log Data to CSV: Learn how to log actuator data to CSV files for analysis and troubleshooting. This example will show you how to capture and utilize performance data effectively.</li> </ul>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/#why-these-examples-matter","title":"Why These Examples Matter","text":"<p>These examples are designed to provide you with hands-on experience and a deeper understanding of how to control real hardware using the PULSAR HRI API. By following these guides, you'll be able to:</p> <ul> <li>Improve Efficiency: Optimize the performance of your robotic systems.</li> <li>Enhance Precision: Achieve greater accuracy in actuator control.</li> <li>Expand Capabilities: Unlock new possibilities for your projects.</li> </ul> <p>Dive into each example and start mastering the art of hardware control with PULSAR HRI!</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/","title":"Controlling One Device","text":"<p>This notebook demonstrates how to connect to a Pulsar actuator using the pcp_api library and PCP_over_USB, configure feedback settings, and control one actuator in speed mode.</p> <p>The full example is at the bottom of the page.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>Pulsar devices understand the PCP protocol, which can be communicated over USB or CAN. The devices has a built-in USB interface, so you can connect directly to the actuator via USB. Alternatively, you can use a CAN adapter to connect to the actuator over a CAN bus. This can adapter is connected to the host computer via USB, so in both cases, you will use the <code>PCP_over_USB</code> class to create the adapter.</p> <pre><code>port = \"COM1\"  # you need to specify the port of the device or the CAN adapter\n# port = PCP_over_USB.get_port()  # there is also an auto-detect system that will find the first available port\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#instantiate-the-actuator","title":"Instantiate the actuator","text":"<p>You can instantiate as many actuators as you want with the same adapter. In this example we are going to control only one actuator, connected directly via USB. If you are using a CAN adapter, you need to specify the PCP address of the actuator. The PCP address is a unique identifier for each actuator on the CAN bus. You can find this address with the  CLI scan command. If you are connecting directly via USB, you can use <code>0</code> as the address.</p> <pre><code>ACTUATOR_ADDRESS = 0  # 0 for direct USB connection, or use the actuator address if using CAN adapter\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\nactuator.connect()\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#configure-feedback","title":"Configure feedback","text":"<p>first define in the top a function to handle the feedback from the actuator. This function will be called whenever new feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n</code></pre> <p>Set up the feedback configuration and control mode:</p> <ul> <li>High-frequency feedback for data like speed, position, torque, ...</li> <li>Low-frequency feedback for data like bus voltage, temperatures....</li> </ul> Configure feedback and control settings<pre><code>actuator.setHighFreqFeedbackItems([\n    PulsarActuator.PCP_Items.SPEED_FB,\n    PulsarActuator.PCP_Items.POSITION_FB,\n    PulsarActuator.PCP_Items.TORQUE_FB,\n    # You can add more items as needed\n])\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n# Low-frequency feedback includes bus voltage and motor temperature.\nactuator.setLowFreqFeedbackItems([\n    PulsarActuator.PCP_Items.VBUS,\n    PulsarActuator.PCP_Items.TEMP_MOTOR,\n])\nactuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\nactuator.set_feedback_callback(actuator_feedback)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#configure-control-settings","title":"Configure control settings","text":"Configure control settings<pre><code>    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n    actuator.start()\n    # The actuator is started and feedback is monitored in a loop.\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#shutdown","title":"Shutdown","text":"<p>Ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C or notebook stop if running from a Jupyter notebook).</p> Shutdown<pre><code>try:\n    # Put the configuration and control code here\n    while True:\n        sleep(0.1)\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # will also stop the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#full-example","title":"Full Example","text":"Full Example<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s because mode is SPEED\n\n    # params = actuator.get_parameters([\n    #     PulsarActuator.PCP_Parameters.FIRMWARE_VERSION,\n    #     PulsarActuator.PCP_Parameters.MODE,\n    #     PulsarActuator.PCP_Parameters.SETPOINT,\n    # ])\n    params = actuator.get_parameters_all()\n    pprint(params)\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/","title":"Controlling Two Devices","text":"<p>This notebook demonstrates how to control multiple PULSAR HRI actuators using the PCP_over_USB interface. We will walk through the steps of connecting to the USB-CAN adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#import-necessary-modules","title":"Import necessary modules","text":"<p>We import the necessay modules. Import<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the CSP (CANopen Slave Protocol) addresses for the two actuators. These addresses are used to uniquely identify each actuator on the CAN bus.</p> Define Constants and Feedback Function<pre><code># Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. It extracts the position feedback (in radians) and prints it along with the actuator's address.</p> Define a feedback callback function<pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We auto-detect the USB port to which the CAN adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> Connect to USB-CAN Adapter<pre><code># Auto-detect the port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#initialize-and-configure-actuators","title":"Initialize and Configure Actuators","text":"<p>For each actuator address, we:</p> <ul> <li>Create a PulsarActuator instance.</li> <li>Attempt to connect to the actuator.</li> <li>Configure high-frequency feedback to report position at 10 Hz.</li> <li>Disable low-frequency feedback.</li> <li>Set the actuator to SPEED mode.</li> <li>Register the feedback callback function.</li> </ul> <p>Each successfully initialized actuator is added to a list for later control.</p> Initialize and Configure Actuators<pre><code>actuators = []\n\nfor address in CSP_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#set-setpoints-and-start-actuators","title":"Set Setpoints and Start Actuators","text":"<p>We assign different speed setpoints to each actuator and start them. This allows both actuators to run simultaneously at different speeds.</p> Set Setpoints and Start Actuators<pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We let the actuators run briefly to allow feedback to be printed. When the program is interrupted (e.g., via Ctrl+C if running from a Jupyter notebook), we ensure all actuators are properly disconnected and the adapter is closed.</p> Run and Cleanup<pre><code>try:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-two-actuators/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n\n# Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n\ndef actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n\n# Auto-detect the port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n\nactuators = []\n\nfor address in CSP_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n\n# Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\ntry:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/","title":"Advanced Features","text":"<p>This notebook demonstrates advanced configuration and control of a PULSAR HRI actuator using the pcp_api library. It builds upon the basic example, which covers:</p> <ul> <li>Connecting to the actuator</li> <li>Setting feedback items and rates</li> <li>Running in speed mode with a fixed setpoint</li> </ul> <p>In this advanced tutorial, you will learn how to:</p> <ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#import-required-modules","title":"Import Required Modules","text":"<p>We begin by importing the necessary modules to interact with the actuator, manage the CAN interface, and handle timing and output formatting. Import Required Modules<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#detect-and-connect-to-the-can-adapter","title":"Detect and Connect to the CAN Adapter","text":"<p>This section automatically detects the USB port where the CAN adapter is connected and initializes the adapter for communication. Detect and Connect to the CAN Adapter<pre><code># Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>We create an instance of the actuator using address 0 and attempt to establish a connection. If the connection fails, the program exits gracefully. Initialize the Actuator<pre><code># Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#define-the-control-parameters","title":"Define the control parameters","text":"<p>Here we define the performance profiles and control parameters:</p> <ul> <li>Torque performance is set to BALANCED for fast torque response.</li> <li>Speed performance is also set to BALANCED for quick speed adjustments.</li> <li>Control parameters like damping and stiffness are set to custom values to fine-tune the actuator's dynamic behavior.</li> </ul> Define the control parameters<pre><code>K_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>This block performs several advanced configuration steps:</p> <ul> <li>Resets the encoder to define a new zero position.</li> <li>Changes the actuator's address (optional).</li> <li>Applies performance profiles for torque and speed.</li> <li>Sets custom control parameters.</li> <li>Optionally saves the configuration to persistent memory.</li> </ul> Apply Advanced Configuration<pre><code>try:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#run-and-verify-that-the-motor-control-behaves-as-required","title":"Run and Verify That the Motor Control Behaves as Required","text":"<p>This section reinitializes the actuator and sets it up for real-time feedback monitoring. It demonstrates how to verify that the actuator behaves as expected after applying the advanced configuration.</p> Run and Verify That the Motor Control Behaves as Required<pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = PCP_over_USB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n\n# Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n\n# Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n\nK_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n\ntry:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = PCP_over_USB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/","title":"Log Data to CSV","text":"<p>This script is designed to connect to a PULSAR HRI actuator using a CAN-over-USB adapter. It logs high-frequency sensor data and saves it to a CSV file for later analysis.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#import-required-modules","title":"Import Required Modules","text":"Import Required Modules<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#connect-to-the-can-adapter","title":"Connect to the CAN Adapter","text":"Connect to the CAN Adapter<pre><code># Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>This creates an actuator object at address 0 Initialize the Actuator<pre><code>actuator = PulsarActuator(adapter, 0)\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#specify-the-logging-variables","title":"Specify the Logging Variables","text":"<p>Specifies which sensor data to log (e.g., torque sensor, PCB temperature)</p> Specify the Logging Variables<pre><code>if not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<ul> <li>Sets up high-frequency feedback (1kHz) for selected items.</li> <li>Disables low-frequency feedback.</li> </ul> Configuration of the Feedback Rates<pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#preparing-csv-logging","title":"Preparing CSV Logging","text":"<p>This opens a CSV file for writing</p> <p>Preparing CSV Logging<pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n</code></pre> Adding a header row with the timestamp and item names</p> Preparing CSV Logging<pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#define-feedback-callback","title":"Define Feedback Callback","text":"<p>This function is called whenever new feedback data is recieved</p> Define Feedback Callback<pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#start-actuator","title":"Start Actuator","text":"Start Actuator<pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#run-and-cleanup","title":"Run and Cleanup","text":"<p>This runs for 3 seconds, then disconnects and closes everything</p> <p>Run and Cleanup<pre><code>try:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre> The CSV is updated for postprocessing.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n\n# Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n\nactuator = PulsarActuator(adapter, 0)\n\nitemsToLog = [\n    PulsarActuator.PCP_Items.TORQUE_SENS_RAW,\n    PulsarActuator.PCP_Items.TEMP_PCB,\n]\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address}\")\n\nactuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\nfile = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n\n# add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n\ndef actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys())])  # sorted keys for consistent order\n    csv_writer.writerow(line)\n\nactuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\n\ntry:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/00-DT-pulsar-digital-twin-context/","title":"What is the digital twin (AUGUR)?","text":"<p>The Digital Twin (Augur) is an advanced simulation technology developed by PULSAR HRI. It allows users to create a virtual replica of their actuators and motors, enabling them to simulate and test their performance in a digital environment before deploying them in real-world scenarios. This technology helps in refining control strategies, optimizing performance, and troubleshooting potential issues without the need for physical hardware.</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/01-DT-how-to-install-digital-twin/","title":"Installing the digital twin into your own Environment","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/00-DT-examples-overview/","title":"Examples overview to control the digital twin","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/01-DT-raw-telemetry-plotting/","title":"Raw telemetry and plotting","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/02-DT-mujoco-integration-pendulum/","title":"Mujoco integration example with a simple pendulum","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/03-DT-mujoco-integration-arm/","title":"Mujoco integration example with a robotic arm","text":"<p>Coming soon ...</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/","title":"Control modes overview","text":""},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#electromagnetic-torque-control","title":"Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#speed-control","title":"Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#position-control","title":"Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#impedance-control-under-development","title":"Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/01-control-modes-parameters/","title":"Which control parameters can be used in each mode?","text":"<p>Not all the available parameters are useful in all the control modes, the following table shows a summary of which control parameters are compatibles with each control mode.</p> <p>Table \u2013 Use of the parameters depending on the control type</p> Parameter Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque loop performance Yes Yes Yes Yes No No No No Speed loop performance No Yes Yes No No No No No Kp position No No Yes No No No No No Kp speed No Yes (if custom selected) Yes (if custom selected) No No No No No Ki speed No Yes (if custom selected) Yes (if custom selected) No No No No No Stiffness gain No No No Yes No No No No Damping gain No No No Yes No No No No FF torque No No No Yes No No No No Max positive speed (rad/s) (Profile) No No Yes No No No No No Min negative speed (rad/s) (Profile) No No Yes No No No No No Max acceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max deceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max speed (rad/s) No Yes Yes No No No No No Min speed (rad/s) No Yes Yes No No No No No Max position (rad) No No Yes Yes No No No No Min position (rad) No No Yes Yes No No No No Max absolute torque (Nm) Yes Yes Yes Yes Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus)"},{"location":"04-functions-explained/00-functions-overview/","title":"Actuator class overview","text":"<p>The PulsarActuator class is the core of the Pulsar Control Protocol (PCP) communication interface. It provides a high-level API for interacting with and managing PULSAR HRI motors or actuators via the CAN bus. Key capabilities include:</p> <ul> <li>Real-Time Command and Control: Send precise control commands to the actuator in real time.</li> <li>Mode Switching: Seamlessly transition between various control modes such as torque, velocity, position, and impedance.</li> <li>Live Feedback Monitoring: Continuously receive and process real-time feedback from the actuator via CAN messages.</li> <li>Parameter Configuration and Management: Set, retrieve, and persist actuator parameters for fine-tuned performance.</li> <li>Diagnostics and Health Monitoring: Access diagnostic data to evaluate actuator status and detect potential issues.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#initialization-and-constructor","title":"Initialization and Constructor","text":"<p>To create an instance of the PulsarActuator class, you need to provide a CAN bus handler and the actuator\u2019s CAN address. Optionally, you can supply a custom logger for debugging and monitoring purposes. Create an instance of the PulsarActuator class<pre><code>PulsarActuator(canbus_handler, address: int, logger=None)\n</code></pre></p>"},{"location":"04-functions-explained/00-functions-overview/#connection-and-address-management","title":"Connection and Address Management","text":"<ul> <li>Connecting to the Actuator: Use the connect() method to initiate communication.</li> <li>Disconnecting from the Actuator: Use the disconnect() method to safely terminate communication.</li> <li>Pinging the Actuator: Use the send_ping() method to check if a specific CAN address is active and responsive.</li> <li>Changing the Actuator's CAN Address: Use the changeAddress(new_address) method to assign a specific address.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#predefined-performance-profiles","title":"Predefined Performance Profiles","text":"<p>The actuator provides predefined performance profiles for both torque and speed control loops:</p> <ul> <li>Torque Control Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT.</li> <li>Speed Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT, and CUSTOM. In this case all the profiles have a similar response time without load, making it more agressive implies a faster rejection time of a perturbation. The parameters are obtained for the no-load motor operation.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#torque-control-loop-performance","title":"Torque Control Loop Performance","text":"<p>This setting determines how quickly and aggressively the actuator responds to torque commands. The available profiles are:</p>"},{"location":"04-functions-explained/00-functions-overview/#aggressive","title":"AGGRESSIVE","text":"<ul> <li>Bandwidth: ~1000 Hz  </li> <li>Behavior: Maximizes responsiveness and torque application speed.  </li> <li>Use Case: Ideal for dynamic tasks such as impedance control or joint torque control.  </li> <li>Trade-off: May reduce steady-state precision.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#balanced","title":"BALANCED","text":"<ul> <li>Bandwidth: ~500 Hz  </li> <li>Behavior: Offers a compromise between responsiveness and stability.  </li> <li>Use Case: Suitable for general-purpose applications.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#soft","title":"SOFT","text":"<ul> <li>Bandwidth: ~100 Hz  </li> <li>Behavior: Prioritizes smoothness and precision over speed.  </li> <li>Use Case: Best for tasks requiring high torque fidelity and low noise.  </li> <li>Trade-off: Lower responsiveness.</li> </ul> <p>Table \u2013 TorquePerformance</p> Name Value Bandwidth (Hz) Description AGGRESSIVE 1 ~1000 Hz Fast response, less precision in steady state BALANCED 2 ~500 Hz Balanced between response and stability SOFT 3 ~100 Hz Stable and quiet, low responsiveness"},{"location":"04-functions-explained/00-functions-overview/#changing-control-modes","title":"Changing Control Modes","text":"<p>Use the change_mode(mode) method to switch between control modes such as CALIBRATION, FVI, OPEN_LOOP, DVI, TORQUE, SPEED, POSITION, and IMPEDANCE.</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-control-start-and-stop","title":"Actuator Control: Start and Stop","text":"<ul> <li>Start: Use the start() method to initiate the actuator's operation.</li> <li>Stop: Use the stop() method to halt the actuator's current motion.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#save-configuration","title":"Save Configuration","text":"<p>Use the save_config() method to store the current settings in non-volatile memory.</p>"},{"location":"04-functions-explained/00-functions-overview/#feedback-configuration","title":"Feedback Configuration","text":"<p>The PulsarActuator API supports two feedback channels with configurable update rates: * High-Frequency Feedback: For fast-changing signals (e.g., torque, speed). * Low-Frequency Feedback: For slower or less critical signals (e.g., temperature, voltage).</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-calibration","title":"Actuator Calibration","text":"<p>Use the calibrate() method to perform internal calibration routines.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/","title":"Actuator parameters","text":"<p>In this section we will show the different parameters that are available in an actuator and their description, see Table \u2013 PCP_Parameters Enum. Moreover, the functions to read and change them will be presented. The use of setpoint profiles and how to set limits to the actuator is also included here.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#table-pcp_parameters-enum","title":"Table \u2013 PCP_Parameters Enum","text":"Enum Name Code Description <code>K_DAMPING</code> 0x01 Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control) <code>K_STIFFNESS</code> 0x02 Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control) <code>TORQUE_FF</code> 0x03 Feedforward Torque Value (Nm) <code>LIM_TORQUE</code> 0x04 Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm) <code>LIM_POSITION_MAX</code> 0x05 Max. Position Limit (rad) <code>LIM_POSITION_MIN</code> 0x06 Min. Position Limit (rad) <code>LIM_SPEED_MAX</code> 0x07 Max. Speed Limit (rad/s) <code>LIM_SPEED_MIN</code> 0x08 Min. Speed Limit (rad/s) <code>PROFILE_POSITION_MAX</code> 0x09 Max. Positive Speed (rad/s) in Position control configuration <code>PROFILE_POSITION_MIN</code> 0x0A Min. Negative Speed (rad/s) in Position control configuration <code>PROFILE_SPEED_MAX</code> 0x0B Max. Acceleration (rad/s^2) in Speed control configuration <code>PROFILE_SPEED_MIN</code> 0x0C Max. Deceleration (rad/s^2) in Speed control configuration <code>KP_SPEED</code> 0x0D Kp speed control constant P value <code>KI_SPEED</code> 0x0E Ki speed control constant I value <code>KP_POSITION</code> 0x0F Kp position control constant P value <code>MODE</code> 0x30 Operation Mode (read-only, must be set via <code>CHANGE_MODE</code>) <code>SETPOINT</code> 0x31 Setpoint, Position (rad), Speed (rad/s), Torque (Nm) <code>FIRMWARE_VERSION</code> 0x80 Firmware version"},{"location":"04-functions-explained/01-actuator-parameters-explained/#reading-actuator-parameters","title":"Reading Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Retrieve all configuration parameters of the actuator at once.</p> <p>Returns: - <code>dict</code>: A dictionary containing all parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parametersparameters-timeout10","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Retrieve specific parameters from the actuator.</p> <p>Parameters: - <code>parameters</code> (list): A list of parameters to request (see Table \u2013 PCP_Parameters Enum). - <code>timeout</code> (float, optional): Maximum time to wait for a response, in seconds. Default is <code>1.0</code>.</p> <p>Returns: - <code>dict</code>: A dictionary containing the requested parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#modifying-actuator-parameters","title":"Modifying Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#set_parametersparameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Modify specific parameters of the actuator.</p> <p>Parameters: - <code>parameters</code> (dict): A dictionary with <code>PCP_Parameters</code> enums as keys and their corresponding values.</p> <p>Warning</p> <p>Ensure that the parameters you modify are within the valid range and do not conflict with other settings to avoid improper actuator behavior.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#use-of-profiles-and-limits","title":"Use of profiles and limits","text":"<p>The use of position, speed or torque limits apply a saturation to the input reference of the corresponding control.</p> <p>The profile options provide the posibility of doing trapezoidal reference changes. Below there are some examples.</p> <ul> <li>Setting the Max positive speed \\((rad/s)\\) to 5 \\(rad/s\\) and using the position control.</li> </ul> <p></p> \\[ \\text{Speed (rad/s)} = \\frac{0.5 \\cdot 2 \\cdot \\pi}{0.630} = 5 \\, \\text{(rad/s)} \\] <ul> <li>Setting the Max acceleration \\((rad/s^2)\\) to 100 \\(rad/s^2\\) and using the speed control.</li> </ul> <p></p> \\[ \\text{Acceleration }(rad/s^2) = \\frac{2.33}{0.0234} = 100 \\, (rad/s^2) \\]"},{"location":"04-functions-explained/02-pcp-api-functions/","title":"Real hardware functions explained","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#communication","title":"Communication","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#connecttimeout10-bool","title":"connect(timeout=1.0) - bool","text":"<p>Info</p> <p>Initiates communication with the actuator by sending a PING message and waiting for a PONG response.</p> <p>Args: timeout (float, optional): Maximum time to wait for a response, in seconds. Default is 1.0. Returns: True if the actuator responds within the timeout window, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#disconnect","title":"disconnect()","text":"<p>Info</p> <p>Safely terminates communication by sending a STOP command to halt any ongoing operations.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#send_pingtimeout10-bool","title":"send_ping(timeout=1.0) - bool","text":"<p>Info</p> <p>Sends a PING message and waits for a PONG response within a specified timeout.</p> <p>Args: timeout (float, optional): The maximum time to wait for a pong response, in seconds. Default is 1.0 second. Returns: True if a pong response is received within the timeout period, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#changeaddressnew_address","title":"changeAddress(new_address)","text":"<p>Info</p> <p>Assigns a new CAN address to the actuator.</p> <p>Args: new_address (int): The new CAN address to assign. Must be within the valid range 0x10 \u2264 new_address \u2264 0x3FFE.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#control","title":"Control","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#start","title":"start()","text":"<p>Info</p> <p>Starts the actuator's operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#stop","title":"stop()","text":"<p>Info</p> <p>Stops the actuator's current motion and operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_modemode-mode","title":"change_mode(mode: Mode)","text":"<p>Info</p> <p>Changes the mode of the actuator.</p> <p>Args: mode (PulsarActuator.Mode): The mode to be set.</p> <p>Modes:</p> <ul> <li>PulsarActuator.Mode.CALIBRATION</li> <li>PulsarActuator.Mode.FVI</li> <li>PulsarActuator.Mode.OPEN_LOOP</li> <li>PulsarActuator.Mode.DVI</li> <li>PulsarActuator.Mode.TORQUE</li> <li>PulsarActuator.Mode.SPEED</li> <li>PulsarActuator.Mode.POSITION</li> <li>PulsarActuator.Mode.IMPEDANCE</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_setpointsetpoint","title":"change_setpoint(setpoint)","text":"<p>Info</p> <p>Changes the setpoint of the actuator.</p> <p>Args: setpoint (float): The setpoint to be set. The units of all the setpoints are in international system units (rad, rad/s, Nm)</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_torque_performanceperformance-torqueperformance","title":"set_torque_performance(performance: TorquePerformance)","text":"<p>Info</p> <p>Sets the torque performance.</p> <p>Args: performance (PulsarActuator.TorquePerformance): The torque performance to be set.</p> <p>Torque performance options:</p> <ul> <li>PulsarActuator.TorquePerformance.AGRESSIVE</li> <li>PulsarActuator.TorquePerformance.BALANCED</li> <li>PulsarActuator.TorquePerformance.SOFT</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_speed_performanceperformance-speedperformance","title":"set_speed_performance(performance: SpeedPerformance)","text":"<p>Info</p> <p>Sets the speed performance.</p> <p>Args: performance (PulsarActuator.SpeedPerformance): The speed performance to be set.</p> <p>Speed performance options:</p> <ul> <li>PulsarActuator.SpeedPerformance.AGRESSIVE</li> <li>PulsarActuator.SpeedPerformance.BALANCED</li> <li>PulsarActuator.SpeedPerformance.SOFT</li> <li>PulsarActuator.SpeedPerformance.CUSTOM To be able to set the values of KP_SPEED and KI_SPEED manually using set_parameters you should first set this speed performance option.</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#reset_encoder_position","title":"reset_encoder_position()","text":"<p>Info</p> <p>Resets the encoder absolute position to 0. Do this before using the position based controls.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#save_config","title":"save_config()","text":"<p>Info</p> <p>Saves the current configuration of the actuator in non-volatile memory.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#calibrate","title":"calibrate()","text":"<p>Info</p> <p>Performs internal calibration routines to align the motor\u2019s electrical position with the mechanical position of the encoder and get the ADCs offsets.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#logging","title":"Logging","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_feedback_callbackcallback-callable-none","title":"set_feedback_callback(callback: callable) - None","text":"<p>Info</p> <p>Registers a function to be called whenever new feedback is received.</p> <p>Args: callback (callable): The function to be executed with each feedback update.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_feedback-dict","title":"get_feedback() - dict","text":"<p>Info</p> <p>Returns the feedback dictionary containing real-time data from the actuator.</p> <p>Returns: dict: The feedback dictionary.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackitemsitems-list","title":"setHighFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the high-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackitemsitems-list","title":"setLowFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the low-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackraterate-rates","title":"setHighFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the high-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackraterate-rates","title":"setLowFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the low-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p> <p>Rates:</p> <ul> <li>PulsarActuator.Rates.DISABLED</li> <li>PulsarActuator.Rates.RATE_1KHZ</li> <li>PulsarActuator.Rates.RATE_100HZ</li> <li>PulsarActuator.Rates.RATE_50HZ</li> <li>PulsarActuator.Rates.RATE_10HZ</li> <li>PulsarActuator.Rates.RATE_5HZ</li> <li>PulsarActuator.Rates.RATE_2HZ</li> <li>PulsarActuator.Rates.RATE_1HZ</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#read-and-set-parameters","title":"Read and set parameters","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_parametersparameters","title":"set_parameters(parameters)","text":"<p>Info</p> <p>Set parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parametersparameters-timeout10","title":"get_parameters(parameters, timeout=1.0)","text":"<p>Info</p> <p>Get parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parameters_all","title":"get_parameters_all()","text":"<p>Info</p> <p>Get all parameters.</p>"},{"location":"04-functions-explained/03-DT-functions/","title":"Digital twin functions explained","text":"<p>Coming soon ...</p>"},{"location":"05-actuator-digital-twin-download/00-DT-download/","title":"Download section of the compiled version of the digital twin","text":"<p>Coming soon ...</p>"},{"location":"06-licensing-and-support/00-licensing/","title":"Licensing","text":""},{"location":"06-licensing-and-support/01-support/","title":"Support","text":"<p>If you encounter any issues or have any questions regarding the use of any product, please do not hesitate to reach out to our support team. </p> <ul> <li>Support Email: support.dt@pulsarhri.com</li> <li>Support Hours: Monday to Thursday, 8:00 AM - 5:00 PM (GMT) and Friday, 8:00 AM - 1:00 PM (GMT) </li> </ul> <p>For additional resources and troubleshooting tips, please contact our support team. Thank you for choosing our product. We are committed to providing you with the best possible experience.</p> <p>You can also create an issue in the repository reporting a bug or requesting a new feature.</p>"},{"location":"07-faq/00-faq/","title":"FAQ","text":"<p>Coming soon ...</p>"}]}