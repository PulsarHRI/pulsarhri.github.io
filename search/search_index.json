{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"cli/","title":"CLI","text":"<p>The Command Line Interface (CLI) for the Pulsar API provides a convenient way to interact with the actuator directly from a terminal. This is particularly useful for quick communication test and for scanning devices on a CAN bus.</p>"},{"location":"cli/#verifying-the-installation","title":"Verifying the Installation","text":"<p>The CLI is installed along the python package. To confirm that the CLI is working correctly, you can run the following command:</p> <p><pre><code>pulsar-cli -h\n</code></pre> This should print the help message.</p>"},{"location":"cli/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides several commands to interact with the Pulsar actuator. Here are some common commands:</p>"},{"location":"cli/#scan-for-devices","title":"Scan for Devices","text":"<p><pre><code>pulsar-cli scan -p &lt;port&gt;\n</code></pre> This command scans the CAN bus for connected Pulsar devices and lists their IDs and statuses. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the CAN adapter (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows). Use the <code>-h</code> flag to see more options</p>"},{"location":"cli/#get-device-parameters","title":"Get Device parameters","text":"<p><pre><code>pulsar-cli params -p &lt;port&gt;\n</code></pre> Then connected to a device via USB, you can retrieve all the parameters of the device. This command will display the current configuration and status of the actuator. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the actuator (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows).</p>"},{"location":"00-home/00-home/","title":"Home","text":"<p>Welcome to the PULSAR HRI documentation! This documentation contains everything you need to begin working with the PULSAR HRI Actuators or PULSAR HRI Motors. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the packages, and accessing the documentation and examples.</p> <p>The PULSAR HRI packages is designed to provide a robust and flexible interface for controlling and monitoring PULSAR HRI hardware. It includes:</p> <ul> <li>A Python package for controlling the real hardware</li> <li>A Python package for controlling the digital twin (AUGUR)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"00-home/00-home/#overview-of-the-pulsar-hri-ecosystem","title":"Overview of the PULSAR HRI ecosystem","text":"<p>Note</p> <ul> <li>When we refer to motors we refer to direct drive motors without transmission</li> <li>When we refer to actuators we refer to motors with a transmission</li> </ul> <p>PULSAR HRI develops best-in-class actuation systems to enable the next generation of robotic capabilities. Our aim is to provide the highest possible performance in motors and actuators, defining excellence through novel metrics involving agility, torque-density, and efficiency. Our model-based design approach enables us to deliver high-performance actuators alongside high-fidelity digital twins (AUGUR). This documentation contains all the necessary resources to set up either a simulation or a physical configuration using our products.</p> <p></p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/","title":"How are PULSAR HRI motors and actuators different from the others?","text":"<p>Robotic applications require motors and actuators which can produce high torques at low speeds, while being able to change speed and torque in a reliable and agile manner. A key performance indicator often overlooked is dynamic efficiency, a critical requirement for mobile robots. </p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/#motors","title":"Motors","text":"<p>We provide our motors both on frameless and framed configurations. Your motor, your choice. Our range covers different sizes and torques to fit multiple applications, all of them delivering dynamic response (bandwidth) and torque density, while requiring low current to drive them. Both second electrical generation motors and custom design services can be unlocked by joining our Vanguard Program.\u200b</p>"},{"location":"01-how-to-control-hardware-actuators/00-R-pulsar-hardware-context/#actuators","title":"Actuators","text":"<p>We design Quasi-Direct Drive (QDD) actuators offer a well-balanced alternative to traditional high-gear solutions.</p> <p>Design specifics also matter. Therefore, we decided to design our transmissions with a very low gear ratio to increase the total bandwidth, boost backdrivability, improve proprioceptiveness and better respond to highly-dynamic intermittent operations.</p> <p></p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/","title":"Installing the PULSAR HRI actuator API (pcp_api)","text":"<p>To ensure a clean and manageable development setup, we strongly recommend using a virtual environment. This helps isolate your dependencies and avoid conflicts with other Python packages on your system. All examples and functionality have been tested on Windows 11 using Python 3.12.10.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#installation","title":"Installation","text":""},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-1-create-a-virtual-environment","title":"Step 1: Create a Virtual Environment","text":"<p>Open your terminal or command prompt and run:</p> <p><pre><code>python -m venv .venv\n</code></pre> This will create a new virtual environment in a folder named .venv within your project directory.</p> <p>Warning</p> <p>The installation can be done in the root environment but we do not recommend it.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-2-activate-the-virtual-environment","title":"Step 2: Activate the Virtual Environment","text":"<p>Before installing the PULSAR HRI API, activate the virtual environment. The activation command depends on your operating system:</p> Linux/macOSWindows (PowerShell) <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Once activated, your terminal prompt should change to indicate that you're working inside the virtual environment.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#step-3-install-the-pulsar-hri-api","title":"Step 3: Install the PULSAR HRI API","text":"<p>With the virtual environment active, install the PULSAR HRI API package using <code>pip</code>:</p> <p><pre><code>pip install pcp_api\n</code></pre> This command will download and install the latest version of the pcp_api package from PyPI or your configured package index. </p> <p>Tip</p> <p>Every time you want to use the PULSAR HRI API or run the example scripts, make sure to activate your virtual environment first. If you close your terminal or restart your system, you\u2019ll need to reactivate it.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>pip show pcp_api\n</code></pre> This should provide information about the installed package, including its version and location. If you see this information, the installation was successful.</p>"},{"location":"01-how-to-control-hardware-actuators/01-R-how-to-install-hardware/#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Use the CLI (command line interface) to quickly interact with the PULSAR hardware.</li> <li>Run example scripts provided in the examples directory.</li> <li>Explore the documentation for detailed usage instructions.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please open an issue in this repository project repository.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/","title":"Examples overview to control real hardware","text":"<p>Welcome to the Examples Overview section, where we guide you through practical applications of controlling real hardware using the PULSAR HRI API. Whether you're a beginner or an experienced developer, these examples will help you harness the full potential of our advanced actuation systems.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Controlling One Device: Start with the basics by learning how to control a single actuator in close loop speed control. This example will introduce you to fundamental commands and setup procedures.</li> <li>Controlling Several Devices: Learn how to manage two actuators simultaneously. Understand synchronization and coordination between multiple hardware components.</li> <li>Advanced Features: Explore the advanced functionalities of our actuators, including different control modes and real-time control.</li> <li>Log Data to CSV: Learn how to log actuator data to CSV files for analysis and troubleshooting. This example will show you how to capture and utilize performance data effectively.</li> </ul>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/00-R-examples-overview/#why-these-examples-matter","title":"Why These Examples Matter","text":"<p>These examples are designed to provide you with hands-on experience and a deeper understanding of how to control real hardware using the PULSAR HRI API. By following these guides, you'll be able to:</p> <ul> <li>Improve Efficiency: Optimize the performance of your robotic systems.</li> <li>Enhance Precision: Achieve greater accuracy in actuator control.</li> <li>Expand Capabilities: Unlock new possibilities for your projects.</li> </ul> <p>Dive into each example and start mastering the art of hardware control with PULSAR HRI!</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/","title":"Controlling One Device","text":"<p>Learn how to control a Pulsar actuator through a step-by-step walkthrough covering connection setup, configuration, and basic motion control. The full example is at the bottom of the page.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>Pulsar devices understand the PCP protocol, which can be communicated over USB or CAN. The devices has a built-in USB interface, so you can connect directly to the actuator via USB. Alternatively, you can use a CAN adapter to connect to the actuator over a CAN bus. This can adapter is connected to the host computer via USB, so in both cases, you will use the <code>PCP_over_USB</code> class to create the adapter.</p> <pre><code>port = \"COM1\"  # you need to specify the port of the device or the CAN adapter\n# port = PCP_over_USB.get_port()  # there is also an auto-detect system that will find the first available port\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#instantiate-the-actuator","title":"Instantiate the actuator","text":"<p>You can instantiate as many actuators as you want with the same CAN adapter. In this example we are going to control only one actuator, connected directly via USB. If you are using a CAN adapter, you need to specify the PCP address of the actuator. The PCP address is a unique identifier for each actuator. You can find this address with the  CLI scan command. If you are connecting directly via USB, use <code>0</code> as the address.</p> <pre><code>ACTUATOR_ADDRESS = 0  # 0 for direct USB connection, or use the actuator address if using CAN adapter\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\nactuator.connect()\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#configure-feedback","title":"Configure feedback","text":"<p>First, define a function to handle the feedback from the actuator. This function will be called whenever new feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n</code></pre> <p>Set up the feedback configuration:</p> <ul> <li>High-frequency feedback for data like speed, position, torque, ...</li> <li>Low-frequency feedback for data like bus voltage, temperatures.... You can set the feedback items you want to receive. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>SPEED_FB</code>, <code>POSITION_FB</code>, <code>TORQUE_FB</code>, <code>VBUS</code>, <code>TEMP_MOTOR</code>, etc.</li> </ul> <p>You can set the feedback rate for each type of feedback. The rates are defined in <code>PulsarActuator.Rates</code>, and you can choose from <code>RATE_1HZ</code>, <code>RATE_10HZ</code>, <code>RATE_100HZ</code>, <code>RATE_1KHZ</code>, or <code>DISABLED</code> to disable the feedback.</p> Configure feedback and control settings<pre><code>actuator.setHighFreqFeedbackItems([\n    PulsarActuator.PCP_Items.SPEED_FB,\n    PulsarActuator.PCP_Items.POSITION_FB,\n    PulsarActuator.PCP_Items.TORQUE_FB,\n    # You can add more items as needed\n])\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n# Low-frequency feedback includes bus voltage and motor temperature.\nactuator.setLowFreqFeedbackItems([\n    PulsarActuator.PCP_Items.VBUS,\n    PulsarActuator.PCP_Items.TEMP_MOTOR,\n])\nactuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n# Set the feedback callback function to handle the feedback data\nactuator.set_feedback_callback(actuator_feedback)\n\n# feedback_callback can be set to None to disable it\n# and read the feedback manually with actuator.get_feedback()\n</code></pre> <p>As an alternative, do not set a callback function or call <code>actuator.set_feedback_callback(None)</code> and read the feedback manually using <code>feedback = actuator.get_feedback()</code>, but using a callback function is more efficient and allows you to process the feedback in real-time.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#configure-control-settings","title":"Configure control settings","text":"<p>You can choose from different control modes, such as <code>SPEED</code>, <code>POSITION</code>, or <code>TORQUE</code>. These are defined in <code>PulsarActuator.Mode</code> In this example, we will use the speed mode. You can now set the setpoint for the actuator, which is the target speed in this case. The units are in SI (International System of Units), so the speed is in radians per second (rad/s), position in radians, and torque in Newton-meters (Nm).</p> Configure control settings<pre><code>    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#start-the-actuator","title":"Start the actuator","text":"<p>You can start the actuator with the current configuration with the <code>start()</code> method. This will begin the control loop and the actuator will start moving according to the setpoint you defined. The feedback will be received at the rates you configured earlier. Its advisable to put these logic in a try-except block to ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C)</p> Shutdown<pre><code>try:\n    # Put the configuration and control code here\n    actuator.start()\n    # The loop will keep running until interrupted (e.g., via Ctrl+C).\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # will also stop the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/01-R-single-actuator/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s because mode is SPEED\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/","title":"Controlling Several Devices","text":"<p>This notebook demonstrates how to control multiple PULSAR HRI actuators using the PCP_over_USB interface. We will walk through the steps of connecting to the USB-CAN adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#import-necessary-modules","title":"Import necessary modules","text":"<p>We import the necessary modules.</p> <pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the CSP (CANopen Slave Protocol) addresses for the two actuators. These addresses are used to uniquely identify each actuator on the CAN bus.</p> Define Constants and Feedback Function<pre><code># Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. It extracts the position feedback (in radians) and prints it along with the actuator's address.</p> Define a feedback callback function<pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We auto-detect the USB port to which the CAN adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> Connect to USB-CAN Adapter<pre><code># Auto-detect the port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#initialize-and-configure-actuators","title":"Initialize and Configure Actuators","text":"<p>For each actuator address, we:</p> <ul> <li>Create a PulsarActuator instance.</li> <li>Attempt to connect to the actuator.</li> <li>Configure high-frequency feedback to report position at 10 Hz.</li> <li>Disable low-frequency feedback.</li> <li>Set the actuator to SPEED mode.</li> <li>Register the feedback callback function.</li> </ul> <p>Each successfully initialized actuator is added to a list for later control.</p> Initialize and Configure Actuators<pre><code>actuators = []\n\nfor address in CSP_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#set-setpoints-and-start-actuators","title":"Set Setpoints and Start Actuators","text":"<p>We assign different speed setpoints to each actuator and start them. This allows both actuators to run simultaneously at different speeds.</p> Set Setpoints and Start Actuators<pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We let the actuators run briefly to allow feedback to be printed. When the program is interrupted (e.g., via Ctrl+C if running from a Jupyter notebook), we ensure all actuators are properly disconnected and the adapter is closed.</p> Run and Cleanup<pre><code>try:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/02-R-several-actuators/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n\n# Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n\ndef actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n\n# Auto-detect the port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n\nactuators = []\n\nfor address in CSP_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n\n# Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\ntry:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/","title":"Advanced Features","text":"<p>This notebook demonstrates advanced configuration and control of a PULSAR HRI actuator using the pcp_api library. It builds upon the basic example, which covers:</p> <ul> <li>Connecting to the actuator</li> <li>Setting feedback items and rates</li> <li>Running in speed mode with a fixed setpoint</li> </ul> <p>In this advanced tutorial, you will learn how to:</p> <ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#import-required-modules","title":"Import Required Modules","text":"<p>We begin by importing the necessary modules to interact with the actuator, manage the CAN interface, and handle timing and output formatting. Import Required Modules<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#detect-and-connect-to-the-can-adapter","title":"Detect and Connect to the CAN Adapter","text":"<p>This section automatically detects the USB port where the CAN adapter is connected and initializes the adapter for communication. Detect and Connect to the CAN Adapter<pre><code># Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>We create an instance of the actuator using address 0 and attempt to establish a connection. If the connection fails, the program exits gracefully. Initialize the Actuator<pre><code># Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n</code></pre></p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#define-the-control-parameters","title":"Define the control parameters","text":"<p>Here we define the performance profiles and control parameters:</p> <ul> <li>Torque performance is set to BALANCED for fast torque response.</li> <li>Speed performance is also set to BALANCED for quick speed adjustments.</li> <li>Control parameters like damping and stiffness are set to custom values to fine-tune the actuator's dynamic behavior.</li> </ul> Define the control parameters<pre><code>K_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>This block performs several advanced configuration steps:</p> <ul> <li>Resets the encoder to define a new zero position.</li> <li>Changes the actuator's address (optional).</li> <li>Applies performance profiles for torque and speed.</li> <li>Sets custom control parameters.</li> <li>Optionally saves the configuration to persistent memory.</li> </ul> Apply Advanced Configuration<pre><code>try:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#run-and-verify-that-the-motor-control-behaves-as-required","title":"Run and Verify That the Motor Control Behaves as Required","text":"<p>This section reinitializes the actuator and sets it up for real-time feedback monitoring. It demonstrates how to verify that the actuator behaves as expected after applying the advanced configuration.</p> Run and Verify That the Motor Control Behaves as Required<pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = PCP_over_USB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/03-R-changing-parameters/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code># Import necessary modules\nfrom pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\nfrom time import sleep\n\n# Automatically detect the CAN port\nport = PCP_over_USB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = PCP_over_USB(port)\n\n# Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n\nK_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n\ntry:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = PCP_over_USB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/","title":"Log Data to CSV","text":"<p>This script is an example of how to log data from a PULSAR HRI actuator. It doesn't show live data, but instead logs it to a CSV file for later analysis. The full example is at the bottom of the page.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#common-code","title":"Common code","text":"<p>Most of the code is common to all examples, so we will not repeat it here. You can find the common code in the first example.</p>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#select-the-items-to-log","title":"Select the items to log","text":"<p>You can put the items to log from the actuator, in a list. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>POSITION_FB</code>, <code>TORQUE_SENS</code>, <code>SPEED_FB</code>, ... In this example, we will log the current in the three phases of the motor, which are <code>IA</code>, <code>IB</code>, and <code>IC</code>. </p> <pre><code>itemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#preparing-csv-logging","title":"Preparing CSV Logging","text":"<p>This opens a CSV file for writing. The key thing is to order the items in the same way they are logged. As the items are defined in an enum, you can sort them by name to ensure a consistent order.</p> <pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#callback-function-for-feedback","title":"Callback function for feedback","text":"<p>The callback function, instead of showing the feedback in real-time, like the other examples, it directly logs the data into a file, which allows for higher rates. The feedback data is a dictionary, where the keys are <code>PulsarActuator.PCP_Items</code> and the values are the corresponding values. Again, we sort the keys by name to ensure a consistent order in the CSV file.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<p>We are going to use only high-frequency feedback at 1kHz.</p> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#start-actuator","title":"Start Actuator","text":"<p>Like in the other examples, we can choose the control mode, setpoint, other parameters (not shown here) and start the actuator. In this example, we are going the let it run for 3 seconds.</p> <pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\nsleep(3)  # actuator_feedback() should be triggered during this time\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#run-and-cleanup","title":"Run and Cleanup","text":"<p>Make sure to close the file, stop the actuator and  close the adapter at the end. </p> <pre><code>actuator.disconnect()  # also stops the actuator\nadapter.close()\nfile.close()\n</code></pre>"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#example-output","title":"Example output","text":"<p>This code will generate a CSV file named <code>log.csv</code> with the logged data. The first column is the timestamp, and the subsequent columns are the values of the items you logged. The output will look like this:</p> Timestamp IA IB IC 1642780800.123 0.15 -0.08 0.12 1642780800.124 0.16 -0.09 0.13 1642780800.125 0.17 -0.10 0.14"},{"location":"01-how-to-control-hardware-actuators/02-R-actuator-control-examples/04-R-log-to-csv/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n\n\nitemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, 0)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\nactuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\nfile = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n\n\nactuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\ntry:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/00-DT-pulsar-digital-twin-context/","title":"What is the digital twin (AUGUR)?","text":"<p>The Digital Twin (Augur) is an advanced simulation technology developed by PULSAR HRI. It allows users to create a virtual replica of their actuators and motors, enabling them to simulate and test their performance in a digital environment before deploying them in real-world scenarios. This technology helps in refining control strategies, optimizing performance, and troubleshooting potential issues without the need for physical hardware.</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/01-DT-how-to-install-digital-twin/","title":"Installing the digital twin into your own Environment","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/00-DT-examples-overview/","title":"Examples overview to control the digital twin","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/01-DT-raw-telemetry-plotting/","title":"Raw telemetry and plotting","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/02-DT-mujoco-integration-pendulum/","title":"Mujoco integration example with a simple pendulum","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/03-DT-mujoco-integration-arm/","title":"Mujoco integration example with a robotic arm","text":"<p>Coming soon ...</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/","title":"Control modes overview","text":""},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#electromagnetic-torque-control","title":"Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#speed-control","title":"Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#position-control","title":"Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#impedance-control-under-development","title":"Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/01-control-modes-parameters/","title":"Which control parameters can be used in each mode?","text":"<p>Not all the available parameters are useful in all the control modes, the following table shows a summary of which control parameters are compatibles with each control mode.</p> <p>Table \u2013 Use of the parameters depending on the control type</p> Parameter Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque loop performance Yes Yes Yes Yes No No No No Speed loop performance No Yes Yes No No No No No Kp position No No Yes No No No No No Kp speed No Yes (if custom selected) Yes (if custom selected) No No No No No Ki speed No Yes (if custom selected) Yes (if custom selected) No No No No No Stiffness gain No No No Yes No No No No Damping gain No No No Yes No No No No FF torque No No No Yes No No No No Max positive speed (rad/s) (Profile) No No Yes No No No No No Min negative speed (rad/s) (Profile) No No Yes No No No No No Max acceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max deceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max speed (rad/s) No Yes Yes No No No No No Min speed (rad/s) No Yes Yes No No No No No Max position (rad) No No Yes Yes No No No No Min position (rad) No No Yes Yes No No No No Max absolute torque (Nm) Yes Yes Yes Yes Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus)"},{"location":"04-functions-explained/00-functions-overview/","title":"Actuator class overview","text":"<p>The PulsarActuator class is the core of the Pulsar Control Protocol (PCP) communication interface. It provides a high-level API for interacting with and managing PULSAR HRI motors or actuators via the CAN bus. Key capabilities include:</p> <ul> <li>Real-Time Command and Control: Send precise control commands to the actuator in real time.</li> <li>Mode Switching: Seamlessly transition between various control modes such as torque, velocity, position, and impedance.</li> <li>Live Feedback Monitoring: Continuously receive and process real-time feedback from the actuator via CAN messages.</li> <li>Parameter Configuration and Management: Set, retrieve, and persist actuator parameters for fine-tuned performance.</li> <li>Diagnostics and Health Monitoring: Access diagnostic data to evaluate actuator status and detect potential issues.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#initialization-and-constructor","title":"Initialization and Constructor","text":"<p>To create an instance of the PulsarActuator class, you need to provide a CAN bus handler and the actuator\u2019s CAN address. Optionally, you can supply a custom logger for debugging and monitoring purposes. Create an instance of the PulsarActuator class<pre><code>PulsarActuator(canbus_handler, address: int, logger=None)\n</code></pre></p>"},{"location":"04-functions-explained/00-functions-overview/#connection-and-address-management","title":"Connection and Address Management","text":"<ul> <li>Connecting to the Actuator: Use the connect() method to initiate communication.</li> <li>Disconnecting from the Actuator: Use the disconnect() method to safely terminate communication.</li> <li>Pinging the Actuator: Use the send_ping() method to check if a specific CAN address is active and responsive.</li> <li>Changing the Actuator's CAN Address: Use the changeAddress(new_address) method to assign a specific address.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#predefined-performance-profiles","title":"Predefined Performance Profiles","text":"<p>The actuator provides predefined performance profiles for both torque and speed control loops:</p> <ul> <li>Torque Control Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT.</li> <li>Speed Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT, and CUSTOM. In this case all the profiles have a similar response time without load, making it more agressive implies a faster rejection time of a perturbation. The parameters are obtained for the no-load motor operation.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#torque-control-loop-performance","title":"Torque Control Loop Performance","text":"<p>This setting determines how quickly and aggressively the actuator responds to torque commands. The available profiles are:</p>"},{"location":"04-functions-explained/00-functions-overview/#aggressive","title":"AGGRESSIVE","text":"<ul> <li>Bandwidth: ~1000 Hz  </li> <li>Behavior: Maximizes responsiveness and torque application speed.  </li> <li>Use Case: Ideal for dynamic tasks such as impedance control or joint torque control.  </li> <li>Trade-off: May reduce steady-state precision.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#balanced","title":"BALANCED","text":"<ul> <li>Bandwidth: ~500 Hz  </li> <li>Behavior: Offers a compromise between responsiveness and stability.  </li> <li>Use Case: Suitable for general-purpose applications.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#soft","title":"SOFT","text":"<ul> <li>Bandwidth: ~100 Hz  </li> <li>Behavior: Prioritizes smoothness and precision over speed.  </li> <li>Use Case: Best for tasks requiring high torque fidelity and low noise.  </li> <li>Trade-off: Lower responsiveness.</li> </ul> <p>Table \u2013 TorquePerformance</p> Name Value Bandwidth (Hz) Description AGGRESSIVE 1 ~1000 Hz Fast response, less precision in steady state BALANCED 2 ~500 Hz Balanced between response and stability SOFT 3 ~100 Hz Stable and quiet, low responsiveness"},{"location":"04-functions-explained/00-functions-overview/#changing-control-modes","title":"Changing Control Modes","text":"<p>Use the change_mode(mode) method to switch between control modes such as CALIBRATION, FVI, OPEN_LOOP, DVI, TORQUE, SPEED, POSITION, and IMPEDANCE.</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-control-start-and-stop","title":"Actuator Control: Start and Stop","text":"<ul> <li>Start: Use the start() method to initiate the actuator's operation.</li> <li>Stop: Use the stop() method to halt the actuator's current motion.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#save-configuration","title":"Save Configuration","text":"<p>Use the save_config() method to store the current settings in non-volatile memory.</p>"},{"location":"04-functions-explained/00-functions-overview/#feedback-configuration","title":"Feedback Configuration","text":"<p>The PulsarActuator API supports two feedback channels with configurable update rates: * High-Frequency Feedback: For fast-changing signals (e.g., torque, speed). * Low-Frequency Feedback: For slower or less critical signals (e.g., temperature, voltage).</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-calibration","title":"Actuator Calibration","text":"<p>Use the calibrate() method to perform internal calibration routines.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/","title":"Actuator parameters","text":"<p>In this section we will show the different parameters that are available in an actuator and their description, see Table \u2013 PCP_Parameters Enum. Moreover, the functions to read and change them will be presented. The use of setpoint profiles and how to set limits to the actuator is also included here.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#table-pcp_parameters-enum","title":"Table \u2013 PCP_Parameters Enum","text":"Enum Name Code Description <code>K_DAMPING</code> 0x01 Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control) <code>K_STIFFNESS</code> 0x02 Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control) <code>TORQUE_FF</code> 0x03 Feedforward Torque Value (Nm) <code>LIM_TORQUE</code> 0x04 Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm) <code>LIM_POSITION_MAX</code> 0x05 Max. Position Limit (rad) <code>LIM_POSITION_MIN</code> 0x06 Min. Position Limit (rad) <code>LIM_SPEED_MAX</code> 0x07 Max. Speed Limit (rad/s) <code>LIM_SPEED_MIN</code> 0x08 Min. Speed Limit (rad/s) <code>PROFILE_POSITION_MAX</code> 0x09 Max. Positive Speed (rad/s) in Position control configuration <code>PROFILE_POSITION_MIN</code> 0x0A Min. Negative Speed (rad/s) in Position control configuration <code>PROFILE_SPEED_MAX</code> 0x0B Max. Acceleration (rad/s^2) in Speed control configuration <code>PROFILE_SPEED_MIN</code> 0x0C Max. Deceleration (rad/s^2) in Speed control configuration <code>KP_SPEED</code> 0x0D Kp speed control constant P value <code>KI_SPEED</code> 0x0E Ki speed control constant I value <code>KP_POSITION</code> 0x0F Kp position control constant P value <code>MODE</code> 0x30 Operation Mode (read-only, must be set via <code>CHANGE_MODE</code>) <code>SETPOINT</code> 0x31 Setpoint, Position (rad), Speed (rad/s), Torque (Nm) <code>FIRMWARE_VERSION</code> 0x80 Firmware version"},{"location":"04-functions-explained/01-actuator-parameters-explained/#reading-actuator-parameters","title":"Reading Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Retrieve all configuration parameters of the actuator at once.</p> <p>Returns: - <code>dict</code>: A dictionary containing all parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parametersparameters-timeout10","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Retrieve specific parameters from the actuator.</p> <p>Parameters: - <code>parameters</code> (list): A list of parameters to request (see Table \u2013 PCP_Parameters Enum). - <code>timeout</code> (float, optional): Maximum time to wait for a response, in seconds. Default is <code>1.0</code>.</p> <p>Returns: - <code>dict</code>: A dictionary containing the requested parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#modifying-actuator-parameters","title":"Modifying Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#set_parametersparameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Modify specific parameters of the actuator.</p> <p>Parameters: - <code>parameters</code> (dict): A dictionary with <code>PCP_Parameters</code> enums as keys and their corresponding values.</p> <p>Warning</p> <p>Ensure that the parameters you modify are within the valid range and do not conflict with other settings to avoid improper actuator behavior.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#use-of-profiles-and-limits","title":"Use of profiles and limits","text":"<p>The use of position, speed or torque limits apply a saturation to the input reference of the corresponding control.</p> <p>The profile options provide the posibility of doing trapezoidal reference changes. Below there are some examples.</p> <ul> <li>Setting the Max positive speed \\((rad/s)\\) to 5 \\(rad/s\\) and using the position control.</li> </ul> <p></p> \\[ \\text{Speed (rad/s)} = \\frac{0.5 \\cdot 2 \\cdot \\pi}{0.630} = 5 \\, \\text{(rad/s)} \\] <ul> <li>Setting the Max acceleration \\((rad/s^2)\\) to 100 \\(rad/s^2\\) and using the speed control.</li> </ul> <p></p> \\[ \\text{Acceleration }(rad/s^2) = \\frac{2.33}{0.0234} = 100 \\, (rad/s^2) \\]"},{"location":"04-functions-explained/02-pcp-api-functions/","title":"Real hardware functions explained","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#communication","title":"Communication","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#connecttimeout10-bool","title":"connect(timeout=1.0) - bool","text":"<p>Info</p> <p>Initiates communication with the actuator by sending a PING message and waiting for a PONG response.</p> <p>Args: timeout (float, optional): Maximum time to wait for a response, in seconds. Default is 1.0. Returns: True if the actuator responds within the timeout window, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#disconnect","title":"disconnect()","text":"<p>Info</p> <p>Safely terminates communication by sending a STOP command to halt any ongoing operations.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#send_pingtimeout10-bool","title":"send_ping(timeout=1.0) - bool","text":"<p>Info</p> <p>Sends a PING message and waits for a PONG response within a specified timeout.</p> <p>Args: timeout (float, optional): The maximum time to wait for a pong response, in seconds. Default is 1.0 second. Returns: True if a pong response is received within the timeout period, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#changeaddressnew_address","title":"changeAddress(new_address)","text":"<p>Info</p> <p>Assigns a new CAN address to the actuator.</p> <p>Args: new_address (int): The new CAN address to assign. Must be within the valid range 0x10 \u2264 new_address \u2264 0x3FFE.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#control","title":"Control","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#start","title":"start()","text":"<p>Info</p> <p>Starts the actuator's operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#stop","title":"stop()","text":"<p>Info</p> <p>Stops the actuator's current motion and operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_modemode-mode","title":"change_mode(mode: Mode)","text":"<p>Info</p> <p>Changes the mode of the actuator.</p> <p>Args: mode (PulsarActuator.Mode): The mode to be set.</p> <p>Modes:</p> <ul> <li>PulsarActuator.Mode.CALIBRATION</li> <li>PulsarActuator.Mode.FVI</li> <li>PulsarActuator.Mode.OPEN_LOOP</li> <li>PulsarActuator.Mode.DVI</li> <li>PulsarActuator.Mode.TORQUE</li> <li>PulsarActuator.Mode.SPEED</li> <li>PulsarActuator.Mode.POSITION</li> <li>PulsarActuator.Mode.IMPEDANCE</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_setpointsetpoint","title":"change_setpoint(setpoint)","text":"<p>Info</p> <p>Changes the setpoint of the actuator.</p> <p>Args: setpoint (float): The setpoint to be set. The units of all the setpoints are in international system units (rad, rad/s, Nm)</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_torque_performanceperformance-torqueperformance","title":"set_torque_performance(performance: TorquePerformance)","text":"<p>Info</p> <p>Sets the torque performance.</p> <p>Args: performance (PulsarActuator.TorquePerformance): The torque performance to be set.</p> <p>Torque performance options:</p> <ul> <li>PulsarActuator.TorquePerformance.AGRESSIVE</li> <li>PulsarActuator.TorquePerformance.BALANCED</li> <li>PulsarActuator.TorquePerformance.SOFT</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_speed_performanceperformance-speedperformance","title":"set_speed_performance(performance: SpeedPerformance)","text":"<p>Info</p> <p>Sets the speed performance.</p> <p>Args: performance (PulsarActuator.SpeedPerformance): The speed performance to be set.</p> <p>Speed performance options:</p> <ul> <li>PulsarActuator.SpeedPerformance.AGRESSIVE</li> <li>PulsarActuator.SpeedPerformance.BALANCED</li> <li>PulsarActuator.SpeedPerformance.SOFT</li> <li>PulsarActuator.SpeedPerformance.CUSTOM To be able to set the values of KP_SPEED and KI_SPEED manually using set_parameters you should first set this speed performance option.</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#reset_encoder_position","title":"reset_encoder_position()","text":"<p>Info</p> <p>Resets the encoder absolute position to 0. Do this before using the position based controls.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#save_config","title":"save_config()","text":"<p>Info</p> <p>Saves the current configuration of the actuator in non-volatile memory.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#calibrate","title":"calibrate()","text":"<p>Info</p> <p>Performs internal calibration routines to align the motor\u2019s electrical position with the mechanical position of the encoder and get the ADCs offsets.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#logging","title":"Logging","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_feedback_callbackcallback-callable-none","title":"set_feedback_callback(callback: callable) - None","text":"<p>Info</p> <p>Registers a function to be called whenever new feedback is received.</p> <p>Args: callback (callable): The function to be executed with each feedback update.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_feedback-dict","title":"get_feedback() - dict","text":"<p>Info</p> <p>Returns the feedback dictionary containing real-time data from the actuator.</p> <p>Returns: dict: The feedback dictionary.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackitemsitems-list","title":"setHighFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the high-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackitemsitems-list","title":"setLowFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the low-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackraterate-rates","title":"setHighFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the high-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackraterate-rates","title":"setLowFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the low-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p> <p>Rates:</p> <ul> <li>PulsarActuator.Rates.DISABLED</li> <li>PulsarActuator.Rates.RATE_1KHZ</li> <li>PulsarActuator.Rates.RATE_100HZ</li> <li>PulsarActuator.Rates.RATE_50HZ</li> <li>PulsarActuator.Rates.RATE_10HZ</li> <li>PulsarActuator.Rates.RATE_5HZ</li> <li>PulsarActuator.Rates.RATE_2HZ</li> <li>PulsarActuator.Rates.RATE_1HZ</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#read-and-set-parameters","title":"Read and set parameters","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_parametersparameters","title":"set_parameters(parameters)","text":"<p>Info</p> <p>Set parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parametersparameters-timeout10","title":"get_parameters(parameters, timeout=1.0)","text":"<p>Info</p> <p>Get parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parameters_all","title":"get_parameters_all()","text":"<p>Info</p> <p>Get all parameters.</p>"},{"location":"04-functions-explained/03-DT-functions/","title":"Digital twin functions explained","text":"<p>Coming soon ...</p>"},{"location":"06-licensing-and-support/00-licensing/","title":"Licensing","text":""},{"location":"06-licensing-and-support/01-support/","title":"Support","text":"<p>If you encounter any issues or have any questions regarding the use of any product, please do not hesitate to reach out to our support team. </p> <ul> <li>Support Email: support.dt@pulsarhri.com</li> <li>Support Hours: Monday to Thursday, 8:00 AM - 5:00 PM (GMT) and Friday, 8:00 AM - 1:00 PM (GMT) </li> </ul> <p>For additional resources and troubleshooting tips, please contact our support team. Thank you for choosing our product. We are committed to providing you with the best possible experience.</p> <p>You can also create an issue in the repository reporting a bug or requesting a new feature.</p>"},{"location":"07-faq/00-faq/","title":"FAQ","text":"<p>Coming soon ...</p>"}]}