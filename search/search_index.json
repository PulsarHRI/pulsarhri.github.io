{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the PULSAR HRI documentation! This documentation contains everything you need to begin working with the PULSAR HRI Actuators or PULSAR HRI Motors. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the packages, and accessing the documentation and examples.</p> <p>The PULSAR HRI packages is designed to provide a robust and flexible interface for controlling and monitoring PULSAR HRI hardware. It includes:</p> <ul> <li>A Python package for controlling the real hardware</li> <li>A Python package for controlling the digital twin (AUGUR)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"#overview-of-the-pulsar-hri-ecosystem","title":"Overview of the PULSAR HRI ecosystem","text":"<p>Note</p> <ul> <li>When we refer to motors we refer to direct drive motors without transmission</li> <li>When we refer to actuators we refer to motors with a transmission</li> </ul> <p>PULSAR HRI develops best-in-class actuation systems to enable the next generation of robotic capabilities. Our aim is to provide the highest possible performance in motors and actuators, defining excellence through novel metrics involving agility, torque-density, and efficiency. Our model-based design approach enables us to deliver high-performance actuators alongside high-fidelity digital twins (AUGUR). This documentation contains all the necessary resources to set up either a simulation or a physical configuration using our products.</p> <p></p>"},{"location":"cli/","title":"Command line interface (CLI)","text":"<p>The Command Line Interface (CLI) is included in the python package. It provides a convenient way to interact with the actuator directly from a terminal. This is particularly useful for quick communication test and for scanning devices on a CAN bus.</p>"},{"location":"cli/#verifying-the-installation","title":"Verifying the Installation","text":"<p>The CLI is installed along the python package. To confirm that the CLI is working correctly, you can run the following command:</p> <p><pre><code>pulsar-cli -h\n</code></pre> This should print the help message.</p>"},{"location":"cli/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides several commands to interact with the Pulsar actuator. Here are some common commands:</p>"},{"location":"cli/#scan-for-devices","title":"Scan for Devices","text":"<p><pre><code>pulsar-cli scan -p &lt;port&gt;\n</code></pre> This command scans the CAN bus for connected Pulsar devices and lists their IDs and statuses. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the CAN adapter (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows). Use the <code>-h</code> flag to see more options</p>"},{"location":"cli/#get-device-parameters","title":"Get Device parameters","text":"<p><pre><code>pulsar-cli params -p &lt;port&gt;\n</code></pre> Then connected to a device via USB, you can retrieve all the parameters of the device. This command will display the current configuration of the actuator. Replace <code>&lt;port&gt;</code> with the appropriate serial port of the actuator (e.g., <code>/dev/ttyUSB0</code> on Linux or <code>COM3</code> on Windows).</p>"},{"location":"electrical_interfaces/","title":"Electrical Interfaces","text":""},{"location":"electrical_interfaces/#power-bus","title":"Power bus","text":"<p>The power bus requirements are:</p> <ul> <li>Voltage: 48V DC</li> <li>Current: up to 30A</li> </ul> <p>Keep in mind that the actuators usually draw much less current (less than 1A without load), but you should still ensure that your power supply can provide the maximum current, or limit the current if the device is demanding more than the power supply can provide.</p> <p>The device has a XT30 male connector for power input. The pinout is as follows:</p> <p></p>"},{"location":"electrical_interfaces/#can-bus","title":"CAN bus","text":"<p>Pulsar devices are compatible with CAN-FD 1Mbit/s|5Mbit/s. We also provide a CAN to USB adapter. CAN specifications require termination resistors (usually 120 Ohm) at both ends of the bus. This is particularly important for high-speed communication. All Pulsar devices have dual CAN connectors, so you can daisy-chain them easily. Ensure to connect the provided termination resistors at both ends of the bus.</p> <p>This is an example of a CAN bus connection between two Pulsar actuators and a Pulsar CAN to USB adapter:</p> <p></p> <p>The connectors are 3-pin PicoBlade from Molex, and the pinout is as follows:</p> <p></p>"},{"location":"electrical_interfaces/#usb","title":"USB","text":"<p>Pulsar devices also include a USB connector. The USB interface is intended for configuration and firmware updates.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Coming soon ...</p>"},{"location":"gui/","title":"Desktop App","text":"<p>The most straightforward way to use a Pulsar Actuator is through the graphical user interface (GUI). It allows you to easily configure and control the actuator without needing to write any code. This desktop application is available for Windows, Mac, and Linux. The Actuator needs to be powered and connected to the computer via USB.</p> <p></p>"},{"location":"install_python_api/","title":"Install Python API","text":"<p>In this document we will guide you through the installation of the PULSAR HRI Python API, which allows you to programmatically control and interact with PULSAR actuators.</p>"},{"location":"install_python_api/#installation","title":"Installation","text":"<p>You can use a virtual environment to install this and other packages for your project. There are several ways to create a virtual environments. In this guide, we will skip the virtual environment and install the PULSAR HRI Python API globally.</p> <pre><code>pip install pcp_api\n</code></pre>"},{"location":"install_python_api/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>pip show pcp_api\n</code></pre> This should provide information about the installed package, including its version and location. If you see this information, the installation was successful.</p>"},{"location":"install_python_api/#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Use the Command line interface to quickly interact with the PULSAR hardware.</li> <li>Run the example scripts</li> <li>Explore the documentation for detailed usage instructions.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please open an issue issue.</p>"},{"location":"led/","title":"LED Status Indicators","text":"<p>The device features an RGB LED that provides visual feedback about its current operational state. This LED helps users quickly identify the device status without needing to connect to a computer.</p>"},{"location":"led/#color-codes","title":"Color Codes","text":"<p>The following colors indicate different device states:</p> <p>\u25cf White: Device is powering up and initializing systems.</p> <p>\u25cf Blue: Device is idle and ready, waiting for PCP commands over CAN bus.</p> <p>\u25cf Purple: USB connection established, device is waiting for commands via USB interface.</p> <p>\u25cf Green: Device is actively processing commands and operating normally.</p> <p>\u25cf Red: Device has encountered an error and requires attention.</p> <p>\u25cf Off: Device is in firmware update mode.</p> <p>Note: LED colors transition automatically based on device state changes. If the LED remains red, consult the troubleshooting guide or check system logs for error details.</p>"},{"location":"licensing/","title":"Licensing","text":""},{"location":"mechanical_interfaces/","title":"Mechanical Interfaces","text":"<p>Before integrating the Pulsar Actuator to your system, we recommend to attach it to a generic bracket, so you can familiarize yourself with the usage and perform some tests. We provide the bracket as a 3D printable file.</p>"},{"location":"support/","title":"Support","text":"<p>If you encounter any issues or have any questions regarding the use of any product, please do not hesitate to reach out to our support team. </p> <ul> <li>Support Email: support.dt@pulsarhri.com</li> <li>Support Hours: Monday to Thursday, 8:00 AM - 5:00 PM (GMT) and Friday, 8:00 AM - 1:00 PM (GMT) </li> </ul> <p>For additional resources and troubleshooting tips, please contact our support team. Thank you for choosing our product. We are committed to providing you with the best possible experience.</p> <p>You can also create an issue reporting a bug or requesting a new feature.</p>"},{"location":"why_pulsar/","title":"Why PULSAR HRI motors and actuators?","text":""},{"location":"why_pulsar/#how-are-pulsar-hri-motors-and-actuators-different-from-the-others","title":"How are PULSAR HRI motors and actuators different from the others?","text":"<p>Robotic applications require motors and actuators which can produce high torques at low speeds, while being able to change speed and torque in a reliable and agile manner. A key performance indicator often overlooked is dynamic efficiency, a critical requirement for mobile robots. </p>"},{"location":"why_pulsar/#motors","title":"Motors","text":"<p>We provide our motors both on frameless and framed configurations. Your motor, your choice. Our range covers different sizes and torques to fit multiple applications, all of them delivering dynamic response (bandwidth) and torque density, while requiring low current to drive them. Both second electrical generation motors and custom design services can be unlocked by joining our Vanguard Program.\u200b</p>"},{"location":"why_pulsar/#actuators","title":"Actuators","text":"<p>We design Quasi-Direct Drive (QDD) actuators offer a well-balanced alternative to traditional high-gear solutions.</p> <p>Design specifics also matter. Therefore, we decided to design our transmissions with a very low gear ratio to increase the total bandwidth, boost backdrivability, improve proprioceptiveness and better respond to highly-dynamic intermittent operations.</p> <p></p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/00-DT-pulsar-digital-twin-context/","title":"What is the digital twin (AUGUR)?","text":"<p>The Digital Twin (Augur) is an advanced simulation technology developed by PULSAR HRI. It allows users to create a virtual replica of their actuators and motors, enabling them to simulate and test their performance in a digital environment before deploying them in real-world scenarios. This technology helps in refining control strategies, optimizing performance, and troubleshooting potential issues without the need for physical hardware.</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/01-DT-how-to-install-digital-twin/","title":"Installing the digital twin into your own Environment","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/00-DT-examples-overview/","title":"Examples overview to control the digital twin","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/01-DT-raw-telemetry-plotting/","title":"Raw telemetry and plotting","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/02-DT-mujoco-integration-pendulum/","title":"Mujoco integration example with a simple pendulum","text":"<p>Coming soon ...</p>"},{"location":"02-how-to-simulate-actuators-with-digital-twin/02-actuator-digital-twin-examples/03-DT-mujoco-integration-arm/","title":"Mujoco integration example with a robotic arm","text":"<p>Coming soon ...</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/","title":"Control modes overview","text":""},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#electromagnetic-torque-control","title":"Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#speed-control","title":"Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#position-control","title":"Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#impedance-control-under-development","title":"Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/00-control-modes-overview/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p> <p></p>"},{"location":"03-actuator-control-modes-explained/01-control-modes-parameters/","title":"Which control parameters can be used in each mode?","text":"<p>Not all the available parameters are useful in all the control modes, the following table shows a summary of which control parameters are compatibles with each control mode.</p> <p>Table \u2013 Use of the parameters depending on the control type</p> Parameter Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque loop performance Yes Yes Yes Yes No No No No Speed loop performance No Yes Yes No No No No No Kp position No No Yes No No No No No Kp speed No Yes (if custom selected) Yes (if custom selected) No No No No No Ki speed No Yes (if custom selected) Yes (if custom selected) No No No No No Stiffness gain No No No Yes No No No No Damping gain No No No Yes No No No No FF torque No No No Yes No No No No Max positive speed (rad/s) (Profile) No No Yes No No No No No Min negative speed (rad/s) (Profile) No No Yes No No No No No Max acceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max deceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max speed (rad/s) No Yes Yes No No No No No Min speed (rad/s) No Yes Yes No No No No No Max position (rad) No No Yes Yes No No No No Min position (rad) No No Yes Yes No No No No Max absolute torque (Nm) Yes Yes Yes Yes Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus)"},{"location":"04-functions-explained/00-functions-overview/","title":"Actuator class overview","text":"<p>The PulsarActuator class is the core of the Pulsar Control Protocol (PCP) communication interface. It provides a high-level API for interacting with and managing PULSAR HRI motors or actuators via the CAN bus. Key capabilities include:</p> <ul> <li>Real-Time Command and Control: Send precise control commands to the actuator in real time.</li> <li>Mode Switching: Seamlessly transition between various control modes such as torque, velocity, position, and impedance.</li> <li>Live Feedback Monitoring: Continuously receive and process real-time feedback from the actuator via CAN messages.</li> <li>Parameter Configuration and Management: Set, retrieve, and persist actuator parameters for fine-tuned performance.</li> <li>Diagnostics and Health Monitoring: Access diagnostic data to evaluate actuator status and detect potential issues.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#initialization-and-constructor","title":"Initialization and Constructor","text":"<p>To create an instance of the PulsarActuator class, you need to provide a CAN bus handler and the actuator\u2019s CAN address. Optionally, you can supply a custom logger for debugging and monitoring purposes. Create an instance of the PulsarActuator class<pre><code>PulsarActuator(canbus_handler, address: int, logger=None)\n</code></pre></p>"},{"location":"04-functions-explained/00-functions-overview/#connection-and-address-management","title":"Connection and Address Management","text":"<ul> <li>Connecting to the Actuator: Use the connect() method to initiate communication.</li> <li>Disconnecting from the Actuator: Use the disconnect() method to safely terminate communication.</li> <li>Pinging the Actuator: Use the send_ping() method to check if a specific CAN address is active and responsive.</li> <li>Changing the Actuator's CAN Address: Use the changeAddress(new_address) method to assign a specific address.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#predefined-performance-profiles","title":"Predefined Performance Profiles","text":"<p>The actuator provides predefined performance profiles for both torque and speed control loops:</p> <ul> <li>Torque Control Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT.</li> <li>Speed Loop Performance: Profiles include AGGRESSIVE, BALANCED, SOFT, and CUSTOM. In this case all the profiles have a similar response time without load, making it more agressive implies a faster rejection time of a perturbation. The parameters are obtained for the no-load motor operation.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#torque-control-loop-performance","title":"Torque Control Loop Performance","text":"<p>This setting determines how quickly and aggressively the actuator responds to torque commands. The available profiles are:</p>"},{"location":"04-functions-explained/00-functions-overview/#aggressive","title":"AGGRESSIVE","text":"<ul> <li>Bandwidth: ~1000 Hz  </li> <li>Behavior: Maximizes responsiveness and torque application speed.  </li> <li>Use Case: Ideal for dynamic tasks such as impedance control or joint torque control.  </li> <li>Trade-off: May reduce steady-state precision.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#balanced","title":"BALANCED","text":"<ul> <li>Bandwidth: ~500 Hz  </li> <li>Behavior: Offers a compromise between responsiveness and stability.  </li> <li>Use Case: Suitable for general-purpose applications.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#soft","title":"SOFT","text":"<ul> <li>Bandwidth: ~100 Hz  </li> <li>Behavior: Prioritizes smoothness and precision over speed.  </li> <li>Use Case: Best for tasks requiring high torque fidelity and low noise.  </li> <li>Trade-off: Lower responsiveness.</li> </ul> <p>Table \u2013 TorquePerformance</p> Name Value Bandwidth (Hz) Description AGGRESSIVE 1 ~1000 Hz Fast response, less precision in steady state BALANCED 2 ~500 Hz Balanced between response and stability SOFT 3 ~100 Hz Stable and quiet, low responsiveness"},{"location":"04-functions-explained/00-functions-overview/#changing-control-modes","title":"Changing Control Modes","text":"<p>Use the change_mode(mode) method to switch between control modes such as CALIBRATION, FVI, OPEN_LOOP, DVI, TORQUE, SPEED, POSITION, and IMPEDANCE.</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-control-start-and-stop","title":"Actuator Control: Start and Stop","text":"<ul> <li>Start: Use the start() method to initiate the actuator's operation.</li> <li>Stop: Use the stop() method to halt the actuator's current motion.</li> </ul>"},{"location":"04-functions-explained/00-functions-overview/#save-configuration","title":"Save Configuration","text":"<p>Use the save_config() method to store the current settings in non-volatile memory.</p>"},{"location":"04-functions-explained/00-functions-overview/#feedback-configuration","title":"Feedback Configuration","text":"<p>The PulsarActuator API supports two feedback channels with configurable update rates: * High-Frequency Feedback: For fast-changing signals (e.g., torque, speed). * Low-Frequency Feedback: For slower or less critical signals (e.g., temperature, voltage).</p>"},{"location":"04-functions-explained/00-functions-overview/#actuator-calibration","title":"Actuator Calibration","text":"<p>Use the calibrate() method to perform internal calibration routines.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/","title":"Actuator parameters","text":"<p>In this section we will show the different parameters that are available in an actuator and their description, see Table \u2013 PCP_Parameters Enum. Moreover, the functions to read and change them will be presented. The use of setpoint profiles and how to set limits to the actuator is also included here.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#table-pcp_parameters-enum","title":"Table \u2013 PCP_Parameters Enum","text":"Enum Name Code Description <code>K_DAMPING</code> 0x01 Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control) <code>K_STIFFNESS</code> 0x02 Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control) <code>TORQUE_FF</code> 0x03 Feedforward Torque Value (Nm) <code>LIM_TORQUE</code> 0x04 Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm) <code>LIM_POSITION_MAX</code> 0x05 Max. Position Limit (rad) <code>LIM_POSITION_MIN</code> 0x06 Min. Position Limit (rad) <code>LIM_SPEED_MAX</code> 0x07 Max. Speed Limit (rad/s) <code>LIM_SPEED_MIN</code> 0x08 Min. Speed Limit (rad/s) <code>PROFILE_POSITION_MAX</code> 0x09 Max. Positive Speed (rad/s) in Position control configuration <code>PROFILE_POSITION_MIN</code> 0x0A Min. Negative Speed (rad/s) in Position control configuration <code>PROFILE_SPEED_MAX</code> 0x0B Max. Acceleration (rad/s^2) in Speed control configuration <code>PROFILE_SPEED_MIN</code> 0x0C Max. Deceleration (rad/s^2) in Speed control configuration <code>KP_SPEED</code> 0x0D Kp speed control constant P value <code>KI_SPEED</code> 0x0E Ki speed control constant I value <code>KP_POSITION</code> 0x0F Kp position control constant P value <code>MODE</code> 0x30 Operation Mode (read-only, must be set via <code>CHANGE_MODE</code>) <code>SETPOINT</code> 0x31 Setpoint, Position (rad), Speed (rad/s), Torque (Nm) <code>FIRMWARE_VERSION</code> 0x80 Firmware version"},{"location":"04-functions-explained/01-actuator-parameters-explained/#reading-actuator-parameters","title":"Reading Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Retrieve all configuration parameters of the actuator at once.</p> <p>Returns: - <code>dict</code>: A dictionary containing all parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#get_parametersparameters-timeout10","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Retrieve specific parameters from the actuator.</p> <p>Parameters: - <code>parameters</code> (list): A list of parameters to request (see Table \u2013 PCP_Parameters Enum). - <code>timeout</code> (float, optional): Maximum time to wait for a response, in seconds. Default is <code>1.0</code>.</p> <p>Returns: - <code>dict</code>: A dictionary containing the requested parameters and their values.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#modifying-actuator-parameters","title":"Modifying Actuator Parameters","text":""},{"location":"04-functions-explained/01-actuator-parameters-explained/#set_parametersparameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Modify specific parameters of the actuator.</p> <p>Parameters: - <code>parameters</code> (dict): A dictionary with <code>PCP_Parameters</code> enums as keys and their corresponding values.</p> <p>Warning</p> <p>Ensure that the parameters you modify are within the valid range and do not conflict with other settings to avoid improper actuator behavior.</p>"},{"location":"04-functions-explained/01-actuator-parameters-explained/#use-of-profiles-and-limits","title":"Use of profiles and limits","text":"<p>The use of position, speed or torque limits apply a saturation to the input reference of the corresponding control.</p> <p>The profile options provide the posibility of doing trapezoidal reference changes. Below there are some examples.</p> <ul> <li>Setting the Max positive speed \\((rad/s)\\) to 5 \\(rad/s\\) and using the position control.</li> </ul> <p></p> \\[ \\text{Speed (rad/s)} = \\frac{0.5 \\cdot 2 \\cdot \\pi}{0.630} = 5 \\, \\text{(rad/s)} \\] <ul> <li>Setting the Max acceleration \\((rad/s^2)\\) to 100 \\(rad/s^2\\) and using the speed control.</li> </ul> <p></p> \\[ \\text{Acceleration }(rad/s^2) = \\frac{2.33}{0.0234} = 100 \\, (rad/s^2) \\]"},{"location":"04-functions-explained/02-pcp-api-functions/","title":"Real hardware functions explained","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#communication","title":"Communication","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#connecttimeout10-bool","title":"connect(timeout=1.0) - bool","text":"<p>Info</p> <p>Initiates communication with the actuator by sending a PING message and waiting for a PONG response.</p> <p>Args: timeout (float, optional): Maximum time to wait for a response, in seconds. Default is 1.0. Returns: True if the actuator responds within the timeout window, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#disconnect","title":"disconnect()","text":"<p>Info</p> <p>Safely terminates communication by sending a STOP command to halt any ongoing operations.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#send_pingtimeout10-bool","title":"send_ping(timeout=1.0) - bool","text":"<p>Info</p> <p>Sends a PING message and waits for a PONG response within a specified timeout.</p> <p>Args: timeout (float, optional): The maximum time to wait for a pong response, in seconds. Default is 1.0 second. Returns: True if a pong response is received within the timeout period, False otherwise.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#changeaddressnew_address","title":"changeAddress(new_address)","text":"<p>Info</p> <p>Assigns a new CAN address to the actuator.</p> <p>Args: new_address (int): The new CAN address to assign. Must be within the valid range 0x10 \u2264 new_address \u2264 0x3FFE.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#control","title":"Control","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#start","title":"start()","text":"<p>Info</p> <p>Starts the actuator's operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#stop","title":"stop()","text":"<p>Info</p> <p>Stops the actuator's current motion and operation.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_modemode-mode","title":"change_mode(mode: Mode)","text":"<p>Info</p> <p>Changes the mode of the actuator.</p> <p>Args: mode (PulsarActuator.Mode): The mode to be set.</p> <p>Modes:</p> <ul> <li>PulsarActuator.Mode.CALIBRATION</li> <li>PulsarActuator.Mode.FVI</li> <li>PulsarActuator.Mode.OPEN_LOOP</li> <li>PulsarActuator.Mode.DVI</li> <li>PulsarActuator.Mode.TORQUE</li> <li>PulsarActuator.Mode.SPEED</li> <li>PulsarActuator.Mode.POSITION</li> <li>PulsarActuator.Mode.IMPEDANCE</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#change_setpointsetpoint","title":"change_setpoint(setpoint)","text":"<p>Info</p> <p>Changes the setpoint of the actuator.</p> <p>Args: setpoint (float): The setpoint to be set. The units of all the setpoints are in international system units (rad, rad/s, Nm)</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_torque_performanceperformance-torqueperformance","title":"set_torque_performance(performance: TorquePerformance)","text":"<p>Info</p> <p>Sets the torque performance.</p> <p>Args: performance (PulsarActuator.TorquePerformance): The torque performance to be set.</p> <p>Torque performance options:</p> <ul> <li>PulsarActuator.TorquePerformance.AGRESSIVE</li> <li>PulsarActuator.TorquePerformance.BALANCED</li> <li>PulsarActuator.TorquePerformance.SOFT</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#set_speed_performanceperformance-speedperformance","title":"set_speed_performance(performance: SpeedPerformance)","text":"<p>Info</p> <p>Sets the speed performance.</p> <p>Args: performance (PulsarActuator.SpeedPerformance): The speed performance to be set.</p> <p>Speed performance options:</p> <ul> <li>PulsarActuator.SpeedPerformance.AGRESSIVE</li> <li>PulsarActuator.SpeedPerformance.BALANCED</li> <li>PulsarActuator.SpeedPerformance.SOFT</li> <li>PulsarActuator.SpeedPerformance.CUSTOM To be able to set the values of KP_SPEED and KI_SPEED manually using set_parameters you should first set this speed performance option.</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#reset_encoder_position","title":"reset_encoder_position()","text":"<p>Info</p> <p>Resets the encoder absolute position to 0. Do this before using the position based controls.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#save_config","title":"save_config()","text":"<p>Info</p> <p>Saves the current configuration of the actuator in non-volatile memory.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#calibrate","title":"calibrate()","text":"<p>Info</p> <p>Performs internal calibration routines to align the motor\u2019s electrical position with the mechanical position of the encoder and get the ADCs offsets.</p> <p>Warning</p> <p>DO NOT USE THIS UNLESS SPECIFIED BY PULSAR TEAM</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#logging","title":"Logging","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_feedback_callbackcallback-callable-none","title":"set_feedback_callback(callback: callable) - None","text":"<p>Info</p> <p>Registers a function to be called whenever new feedback is received.</p> <p>Args: callback (callable): The function to be executed with each feedback update.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_feedback-dict","title":"get_feedback() - dict","text":"<p>Info</p> <p>Returns the feedback dictionary containing real-time data from the actuator.</p> <p>Returns: dict: The feedback dictionary.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackitemsitems-list","title":"setHighFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the high-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackitemsitems-list","title":"setLowFreqFeedbackItems(items: list)","text":"<p>Info</p> <p>Sets the items to be sent in the low-frequency feedback.</p> <p>Args: items (list): The list of PulsarActuator.PCP_Items to be sent.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#sethighfreqfeedbackraterate-rates","title":"setHighFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the high-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#setlowfreqfeedbackraterate-rates","title":"setLowFreqFeedbackRate(rate: Rates)","text":"<p>Info</p> <p>Sets the rate of the low-frequency feedback.</p> <p>Args: rate (Rates): The rate in Hz.</p> <p>Rates:</p> <ul> <li>PulsarActuator.Rates.DISABLED</li> <li>PulsarActuator.Rates.RATE_1KHZ</li> <li>PulsarActuator.Rates.RATE_100HZ</li> <li>PulsarActuator.Rates.RATE_50HZ</li> <li>PulsarActuator.Rates.RATE_10HZ</li> <li>PulsarActuator.Rates.RATE_5HZ</li> <li>PulsarActuator.Rates.RATE_2HZ</li> <li>PulsarActuator.Rates.RATE_1HZ</li> </ul>"},{"location":"04-functions-explained/02-pcp-api-functions/#read-and-set-parameters","title":"Read and set parameters","text":""},{"location":"04-functions-explained/02-pcp-api-functions/#set_parametersparameters","title":"set_parameters(parameters)","text":"<p>Info</p> <p>Set parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parametersparameters-timeout10","title":"get_parameters(parameters, timeout=1.0)","text":"<p>Info</p> <p>Get parameters.</p>"},{"location":"04-functions-explained/02-pcp-api-functions/#get_parameters_all","title":"get_parameters_all()","text":"<p>Info</p> <p>Get all parameters.</p>"},{"location":"04-functions-explained/03-DT-functions/","title":"Digital twin functions explained","text":"<p>Coming soon ...</p>"},{"location":"example_scripts/advanced_features/","title":"Advanced Features","text":"<p>This notebook demonstrates advanced configuration and control of a PULSAR HRI actuator. It builds upon the basic example.</p> <p>In this document you will learn how to:</p> <ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"example_scripts/advanced_features/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>The code shows several features of the PULSAR HRI actuator:</p>"},{"location":"example_scripts/advanced_features/#resets-the-encoder-to-define-a-new-zero-position","title":"Resets the encoder to define a new zero position","text":"<pre><code>actuator.reset_encoder_position()\n</code></pre>"},{"location":"example_scripts/advanced_features/#changes-the-actuators-address","title":"Changes the actuator's address","text":"<pre><code>actuator.changeAddress(0x15)\n</code></pre>"},{"location":"example_scripts/advanced_features/#applies-performance-profiles-for-torque-and-speed","title":"Applies performance profiles for torque and speed","text":"<p>The available performance profiles are defined in the <code>PulsarActuator.TorquePerformance</code> and <code>PulsarActuator.SpeedPerformance</code></p> <pre><code>actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\nactuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n</code></pre>"},{"location":"example_scripts/advanced_features/#sets-custom-control-parameters","title":"Sets custom control parameters","text":"<p>The available parameters are defined in the <code>PulsarActuator.PCP_Parameters</code></p> <pre><code>actuator.set_parameters({\n    PulsarActuator.PCP_Parameters.K_DAMPING: 7.7,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS: 8.8,\n})\n</code></pre>"},{"location":"example_scripts/advanced_features/#saves-the-configuration-to-persistent-memory","title":"Saves the configuration to persistent memory","text":"<p>This will save the current configuration to the actuator's persistent memory, so it will be retained across power cycles.</p> <pre><code>actuator.save_config()\n</code></pre>"},{"location":"example_scripts/advanced_features/#reads-back-parameters","title":"Reads back parameters","text":"<p>This will read back the current configuration from the actuator.</p> <pre><code>params = actuator.get_parameters([\n    PulsarActuator.PCP_Parameters.MODE,\n    PulsarActuator.PCP_Parameters.SETPOINT,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS,\n])\n# params = actuator.get_parameters_all()\npprint(params)\n</code></pre>"},{"location":"example_scripts/advanced_features/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom pprint import pprint\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection\n\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\n\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator 0x{actuator.address:X} ({actuator.address})\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to {actuator.model} at address 0x{actuator.address:X} ({actuator.address})  firmware: v{actuator.firmware_version}\")\n\n# Define actual position as zero position\nactuator.reset_encoder_position()\n\n# Change the actuator's address\nactuator.changeAddress(0x15)\n\n# Set performance modes\nactuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\nactuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n# Set control parameters\nactuator.set_parameters({\n    PulsarActuator.PCP_Parameters.K_DAMPING: 7.7,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS: 8.8,\n})\n\n# Optional: Save configuration to persistent memory\n# actuator.save_config()\n\n# Read back parameters \nparams = actuator.get_parameters([\n    PulsarActuator.PCP_Parameters.MODE,\n    PulsarActuator.PCP_Parameters.SETPOINT,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS,\n])\n# params = actuator.get_parameters_all()\npprint(params)\n\nadapter.close()\n</code></pre>"},{"location":"example_scripts/examples_overview/","title":"Examples overview to control real hardware","text":"<p>Welcome to the Examples Overview section, where we guide you through practical applications of controlling real hardware using the PULSAR HRI API. Whether you're a beginner or an experienced developer, these examples will help you harness the full potential of our advanced actuation systems.</p>"},{"location":"example_scripts/examples_overview/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Controlling One Device: Start with the basics by learning how to control a single actuator in close loop speed control. This example will introduce you to fundamental commands and setup procedures.</li> <li>Controlling Several Devices: Learn how to manage two actuators simultaneously. Understand synchronization and coordination between multiple hardware components.</li> <li>Advanced Features: Explore the advanced functionalities of our actuators, including different control modes and real-time control.</li> <li>Log Data to CSV: Learn how to log actuator data to CSV files for analysis and troubleshooting. This example will show you how to capture and utilize performance data effectively.</li> </ul>"},{"location":"example_scripts/examples_overview/#why-these-examples-matter","title":"Why These Examples Matter","text":"<p>These examples are designed to provide you with hands-on experience and a deeper understanding of how to control real hardware using the PULSAR HRI API. By following these guides, you'll be able to:</p> <ul> <li>Improve Efficiency: Optimize the performance of your robotic systems.</li> <li>Enhance Precision: Achieve greater accuracy in actuator control.</li> <li>Expand Capabilities: Unlock new possibilities for your projects.</li> </ul> <p>Dive into each example and start mastering the art of hardware control with PULSAR HRI!</p>"},{"location":"example_scripts/log_to_csv/","title":"Log Data to CSV","text":"<p>This script is an example of how to log data from a PULSAR HRI actuator. It doesn't show live data, but instead logs it to a CSV file for later analysis. The full example is at the bottom of the page.</p>"},{"location":"example_scripts/log_to_csv/#common-code","title":"Common code","text":"<p>Most of the code is common to all examples, so we will not repeat it here. You can find the common code in the first example.</p>"},{"location":"example_scripts/log_to_csv/#select-the-items-to-log","title":"Select the items to log","text":"<p>You can put the items to log from the actuator, in a list. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>POSITION_FB</code>, <code>TORQUE_SENS</code>, <code>SPEED_FB</code>, ... In this example, we will log the current in the three phases of the motor, which are <code>IA</code>, <code>IB</code>, and <code>IC</code>. </p> <pre><code>itemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n</code></pre>"},{"location":"example_scripts/log_to_csv/#preparing-csv-logging","title":"Preparing CSV Logging","text":"<p>This opens a CSV file for writing. The key thing is to order the items in the same way they are logged. As the items are defined in an enum, you can sort them by name to ensure a consistent order.</p> <pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"example_scripts/log_to_csv/#callback-function-for-feedback","title":"Callback function for feedback","text":"<p>The callback function, instead of showing the feedback in real-time, like the other examples, it directly logs the data into a file, which allows for higher rates. The feedback data is a dictionary, where the keys are <code>PulsarActuator.PCP_Items</code> and the values are the corresponding values. Again, we sort the keys by name to ensure a consistent order in the CSV file.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n</code></pre>"},{"location":"example_scripts/log_to_csv/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<p>We are going to use only high-frequency feedback at 1kHz.</p> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"example_scripts/log_to_csv/#start-actuator","title":"Start Actuator","text":"<p>Like in the other examples, we can choose the control mode, setpoint, other parameters (not shown here) and start the actuator. In this example, we are going the let it run for 3 seconds.</p> <pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\nsleep(3)  # actuator_feedback() should be triggered during this time\n</code></pre>"},{"location":"example_scripts/log_to_csv/#run-and-cleanup","title":"Run and Cleanup","text":"<p>Make sure to close the file, stop the actuator and  close the adapter at the end. </p> <pre><code>actuator.disconnect()  # also stops the actuator\nadapter.close()\nfile.close()\n</code></pre>"},{"location":"example_scripts/log_to_csv/#example-output","title":"Example output","text":"<p>This code will generate a CSV file named <code>log.csv</code> with the logged data. The first column is the timestamp, and the subsequent columns are the values of the items you logged. The output will look like this:</p> Timestamp IA IB IC 1642780800.123 0.15 -0.08 0.12 1642780800.124 0.16 -0.09 0.13 1642780800.125 0.17 -0.10 0.14"},{"location":"example_scripts/log_to_csv/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n\n\nitemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, 0)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\nactuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\nfile = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n\n# add header\nheader = [\"Timestamp\"]\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n\n\nactuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\ntry:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre>"},{"location":"example_scripts/several_actuators/","title":"Controlling Several Devices","text":"<p>This notebook demonstrates how to control multiple PULSAR HRI actuators. We will walk through the steps of connecting to the USB-CAN adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p>"},{"location":"example_scripts/several_actuators/#import-necessary-modules","title":"Import necessary modules","text":"<p>We import the necessary modules.</p> <pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"example_scripts/several_actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the addresses for the two actuators. These addresses are used to uniquely identify each actuator on the CAN bus. You can discover the addresses of your actuators using the CLI scan command</p> <pre><code># Example PCP addresses for two actuators\nACTUATOR_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"example_scripts/several_actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. You can define individual functions for each actuator, or use a single function for all actuators. In this example, we are going to extract the position from the feedback dict, and prints it along with the actuator's address.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"example_scripts/several_actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We auto-detect the USB port to which the CAN adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> <pre><code># Auto-detect CAN adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"example_scripts/several_actuators/#initialize-actuators-and-set-common-configuration","title":"Initialize Actuators and set common configuration","text":"<p>We create a loop to initialize each actuator using its address. Each actuator is connected, configured for high-frequency feedback, and set to SPEED mode. The feedback callback function is registered to handle incoming feedback from the actuators.</p> <pre><code>actuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"example_scripts/several_actuators/#individual-actuator-configuration","title":"Individual Actuator Configuration","text":"<p>We assign different configuration to each actuator.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n</code></pre>"},{"location":"example_scripts/several_actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We start all actuators and let them run briefly to allow feedback to be printed. When the program is interrupted (e.g., via Ctrl+C ), we ensure all actuators are properly disconnected and the adapter is closed.</p> <pre><code># Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"example_scripts/several_actuators/#full-code","title":"Full code","text":"<p>The Jupyter notebook can be downloaded here.</p> Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n# Example PCP addresses for two actuators\nACTUATOR_ADDRESSES = [0x10, 0x11]\n\ndef actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n\n# Auto-detect CAN adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n\nactuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n\n# Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"example_scripts/single_actuator/","title":"Controlling One Device","text":"<p>Learn how to control a Pulsar actuator through a step-by-step walkthrough covering connection setup, configuration, and basic motion control. The full example is at the bottom of the page.</p>"},{"location":"example_scripts/single_actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"example_scripts/single_actuator/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>Pulsar devices understand the PCP protocol, which can be communicated over USB or CAN. The devices has a built-in USB interface, so you can connect directly to the actuator via USB. Alternatively, you can use a CAN adapter to connect to the actuator over a CAN bus. This can adapter is connected to the host computer via USB, so in both cases, you will use the <code>PCP_over_USB</code> class to create the adapter.</p> <pre><code>port = \"COM1\"  # you need to specify the port of the device or the CAN adapter\n# port = PCP_over_USB.get_port()  # there is also an auto-detect system that will find the first available port\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"example_scripts/single_actuator/#instantiate-the-actuator","title":"Instantiate the actuator","text":"<p>You can instantiate as many actuators as you want with the same CAN adapter. In this example we are going to control only one actuator, connected directly via USB. If you are using a CAN adapter, you need to specify the PCP address of the actuator. The PCP address is a unique identifier for each actuator. You can find this address with the  CLI scan command. If you are connecting directly via USB, use <code>0</code> as the address.</p> <pre><code>ACTUATOR_ADDRESS = 0  # 0 for direct USB connection, or use the actuator address if using CAN adapter\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\nactuator.connect()\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n</code></pre>"},{"location":"example_scripts/single_actuator/#configure-feedback","title":"Configure feedback","text":"<p>First, define a function to handle the feedback from the actuator. This function will be called whenever new feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n</code></pre> <p>Set up the feedback configuration:</p> <ul> <li>High-frequency feedback for data like speed, position, torque, ...</li> <li>Low-frequency feedback for data like bus voltage, temperatures.... You can set the feedback items you want to receive. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>SPEED_FB</code>, <code>POSITION_FB</code>, <code>TORQUE_FB</code>, <code>VBUS</code>, <code>TEMP_MOTOR</code>, etc.</li> </ul> <p>You can set the feedback rate for each type of feedback. The rates are defined in <code>PulsarActuator.Rates</code>, and you can choose from <code>RATE_1HZ</code>, <code>RATE_10HZ</code>, <code>RATE_100HZ</code>, <code>RATE_1KHZ</code>, or <code>DISABLED</code> to disable the feedback.</p> Configure feedback and control settings<pre><code>actuator.setHighFreqFeedbackItems([\n    PulsarActuator.PCP_Items.SPEED_FB,\n    PulsarActuator.PCP_Items.POSITION_FB,\n    PulsarActuator.PCP_Items.TORQUE_FB,\n    # You can add more items as needed\n])\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n# Low-frequency feedback includes bus voltage and motor temperature.\nactuator.setLowFreqFeedbackItems([\n    PulsarActuator.PCP_Items.VBUS,\n    PulsarActuator.PCP_Items.TEMP_MOTOR,\n])\nactuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n# Set the feedback callback function to handle the feedback data\nactuator.set_feedback_callback(actuator_feedback)\n\n# feedback_callback can be set to None to disable it\n# and read the feedback manually with actuator.get_feedback()\n</code></pre> <p>As an alternative, do not set a callback function or call <code>actuator.set_feedback_callback(None)</code> and read the feedback manually using <code>feedback = actuator.get_feedback()</code>, but using a callback function is more efficient and allows you to process the feedback in real-time.</p>"},{"location":"example_scripts/single_actuator/#configure-control-settings","title":"Configure control settings","text":"<p>You can choose from different control modes, such as <code>SPEED</code>, <code>POSITION</code>, or <code>TORQUE</code>. These are defined in <code>PulsarActuator.Mode</code> In this example, we will use the speed mode. You can now set the setpoint for the actuator, which is the target speed in this case. The units are in SI (International System of Units), so the speed is in radians per second (rad/s), position in radians, and torque in Newton-meters (Nm).</p> Configure control settings<pre><code>    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n</code></pre>"},{"location":"example_scripts/single_actuator/#start-the-actuator","title":"Start the actuator","text":"<p>You can start the actuator with the current configuration with the <code>start()</code> method. This will begin the control loop and the actuator will start moving according to the setpoint you defined. The feedback will be received at the rates you configured earlier. Its advisable to put these logic in a try-except block to ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C)</p> Shutdown<pre><code>try:\n    # Put the configuration and control code here\n    actuator.start()\n    # The loop will keep running until interrupted (e.g., via Ctrl+C).\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # will also stop the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"example_scripts/single_actuator/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s because mode is SPEED\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"}]}