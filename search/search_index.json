{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This repository provides all the necessary resources to install the Pulsar API, along with comprehensive documentation and examples to help you get started using the Pulsar Actuator or Motor. It includes detailed descriptions of available classes and methods.</p>"},{"location":"#installing-the-pulsar-api-into-your-own-environment","title":"Installing the Pulsar API into your own Environment","text":"<p>We recommend using a virtual environment to manage dependencies. However, you may also install the package directly into your system\u2019s Python environment if preferred. To create and activate your own virtual environment, follow these steps: <pre><code>python -m venv .venv\n</code></pre> Once created, transfer the generated .whl file to the designated personal directory to proceed with the installation. In this instance, the target distribution is version 0.9.1, specifically pcp_api-0.9.1-py3-none-any.whl</p> <p></p> <p>Next, utilize Python\u2019s package manager, pip, to install the package into the active environment. Begin by activating the appropriate virtual environment to ensure the package is installed in the correct context.</p> LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Now we install the package using pip:</p> LinuxWindows <pre><code>pip install pcp_api-0.9.1-py3-none-any.whl\n</code></pre> <pre><code>pip install pcp_api-0.9.1-py3-none-any.whl\n</code></pre> <p>IMPORTANT NOTE</p> <p>This command is installing the version 0.9.1, if you have a newer version modify the name of the file accordingly.</p>"},{"location":"01-Single-Actuator/","title":"01-Pulsar Actuator Control (One Target)","text":"<p>This notebook demonstrates how to connect to a Pulsar actuator using the <code>pcp_api</code> library and <code>CANoverUSB</code>, configure feedback settings, and control one actuator in speed mode.</p> <pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"01-Single-Actuator/#define-the-actuator-address","title":"Define the actuator address","text":"<p>Use <code>0</code> for direct USB connection. If using a CAN adapter, specify the appropriate PCP address.</p> <pre><code>ACTUATOR_ADDRESS = 0\n</code></pre>"},{"location":"01-Single-Actuator/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function will be called automatically when feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n</code></pre>"},{"location":"01-Single-Actuator/#connect-to-the-actuator","title":"Connect to the actuator","text":"<p>Automatically detect the USB port and establish a connection to the actuator.</p> <pre><code>port = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"01-Single-Actuator/#configure-feedback-and-control-settings","title":"Configure feedback and control settings","text":"<p>Set high-frequency and low-frequency feedback items, change the actuator mode to SPEED, and set a speed setpoint.</p> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"02-Two-Actuators/","title":"02-Pulsar Actuator Control (Two Targets)","text":"<p>This notebook demonstrates how to control Pulsar actuators using the CANoverUSB interface. We will go through the steps of connecting to the USB-CAN adapter, initializing the actuators, configuring them, and finally running them.</p> <pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"02-Two-Actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the CSP addresses for the actuators and a feedback function to handle actuator feedback.</p> <pre><code># Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"02-Two-Actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function will be called automatically when feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"02-Two-Actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We connect to the USB-CAN adapter. The port is auto-detected.</p> <pre><code># Auto-detect the port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"02-Two-Actuators/#initialize-and-configure-actuators","title":"Initialize and Configure Actuators","text":"<p>We initialize the actuators, connect to them, and configure their feedback settings.</p> <pre><code>actuators = []\n\nfor address in CSP_ADDRESSES:\n    actuator = PulsarActuator(adapter, address)\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"02-Two-Actuators/#set-setpoints-and-start-actuators","title":"Set Setpoints and Start Actuators","text":"<p>We set different speeds for each actuator and start them.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n</code></pre>"},{"location":"02-Two-Actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We run the actuators for a short period and then clean up by disconnecting the actuators and closing the adapter.</p> <pre><code>try:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"03-Changing-Parameters/","title":"03-Advanced Pulsar Control","text":"<p>This notebook demonstrates advanced configuration and control of a Pulsar actuator using the pcp_api library. It builds upon the basic example, which covers:</p> <ul> <li>Connecting to the actuator</li> <li>Setting feedback items and rates</li> <li>Running in speed mode with a fixed setpoint</li> </ul>"},{"location":"03-Changing-Parameters/#in-this-advanced-tutorial-you-will-learn-how-to","title":"In this advanced tutorial, you will learn how to:","text":"<ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"03-Changing-Parameters/#import-required-modules","title":"Import Required Modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"03-Changing-Parameters/#detect-and-connect-to-the-can-adapter","title":"Detect and Connect to the CAN Adapter","text":"<pre><code># Automatically detect the CAN port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"03-Changing-Parameters/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p><pre><code># Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n</code></pre> Here we define the performance for Torque and Speed Loops: * In this case we want a BALANCED behavior for the torque performance.  * In thi case we want an AGRESSIVE mode for speed. </p> <p>Also it is possible to set some control parameters as the Damping Factor and The Stiffnes.</p> <pre><code>K_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n</code></pre> <pre><code>try:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n</code></pre>"},{"location":"03-Changing-Parameters/#run-and-verify-that-the-motor-control-behaves-as-required","title":"Run and Verify That the Motor Control Behaves as Required","text":"<pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"}]}