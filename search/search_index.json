{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Welcome to the Pulsar API repository! This repository contains everything you need to begin working with the Pulsar Actuator or Pulsar Motor. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the API, and accessing the documentation and examples.</p> <p>The Pulsar API is designed to provide a robust and flexible interface for controlling and monitoring Pulsar hardware. It includes:</p> <ul> <li>A well-documented Python package (pcp_api)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"#installing-the-pulsar-api-into-your-own-environment","title":"Installing the Pulsar API into your own Environment","text":"<p>To ensure a clean and manageable development setup, we strongly recommend using a virtual environment. This helps isolate your dependencies and avoid conflicts with other Python packages on your system.</p>"},{"location":"#step-1-create-a-virtual-environment","title":"Step 1: Create a Virtual Environment","text":"<p>Open your terminal or command prompt and run:</p> <p><pre><code>python -m venv .venv\n</code></pre> This will create a new virtual environment in a folder named .venv within your project directory.</p>"},{"location":"#step-2-activate-the-virtual-environment","title":"Step 2: Activate the Virtual Environment","text":"<p>Before installing the Pulsar API, activate the virtual environment. The activation command depends on your operating system:</p> Linux/macOSWindows (PowerShell) <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Once activated, your terminal prompt should change to indicate that you're working inside the virtual environment.</p>"},{"location":"#step-3-install-the-pulsar-api","title":"Step 3: Install the Pulsar API","text":"<p>With the virtual environment active, install the Pulsar API package using <code>pip</code>:</p> <p><pre><code>pip install pcp_api\n</code></pre> This command will download and install the latest version of the pcp_api package from PyPI or your configured package index.</p> <p>Important</p> <p>Every time you want to use the Pulsar API or run the example scripts, make sure to activate your virtual environment first. If you close your terminal or restart your system, you\u2019ll need to reactivate it.</p>"},{"location":"#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>python -c \"import pcp_api; print(pcp_api.__version__)\"\n</code></pre> This should print the version number of the installed package, indicating that it's ready to use.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Explore the documentation for detailed usage instructions.</li> <li>Run example scripts provided in the examples/ directory.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please refer to the Troubleshooting section in the documentation or open an issue in this repository.</p>"},{"location":"01-Single-Actuator/","title":"01. Controlling One Target","text":"<p>This notebook demonstrates how to connect to a Pulsar actuator using the pcp_api library and CANoverUSB, configure feedback settings, and control one actuator in speed mode.</p>"},{"location":"01-Single-Actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"01-Single-Actuator/#define-the-actuator-address","title":"Define the actuator address","text":"<p>Specify the address of the actuator. Use <code>0</code> if you're connecting directly via USB. If you're using a CAN adapter, replace it with the appropriate PCP address assigned to your actuator.</p> <pre><code>ACTUATOR_ADDRESS = 0\n</code></pre>"},{"location":"01-Single-Actuator/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is automatically triggered whenever feedback is received from the actuator. It prints the full feedback dictionary and extracts the speed feedback (if available), displaying it in a readable format.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n</code></pre>"},{"location":"01-Single-Actuator/#connect-to-the-actuator","title":"Connect to the actuator","text":"<p>Automatically detect the USB port, create the CAN adapter, and attempt to connect to the actuator. If the connection fails, the program exits gracefully.</p> <pre><code>port = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"01-Single-Actuator/#configure-feedback-and-control-settings","title":"Configure feedback and control settings","text":"<p>Set up the feedback configuration and control mode:</p> <ul> <li>High-frequency feedback includes speed, position, and torque.</li> <li>Low-frequency feedback includes bus voltage and motor temperature.</li> <li>The actuator is switched to SPEED mode and given a setpoint of 1 rad/s.</li> <li>Parameters are retrieved and printed for inspection.</li> <li>The actuator is started and feedback is monitored in a loop.</li> </ul> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-Single-Actuator/#shutdown","title":"Shutdown","text":"<p>Ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C or notebook stop).</p>"},{"location":"02-Two-Actuators/","title":"02. Controlling Two Targets","text":"<p>This notebook demonstrates how to control multiple Pulsar actuators using the CANoverUSB interface. We will walk through the steps of connecting to the USB-CAN adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p>"},{"location":"02-Two-Actuators/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"02-Two-Actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the CSP (CANopen Slave Protocol) addresses for the two actuators. These addresses are used to uniquely identify each actuator on the CAN bus.</p> <pre><code># Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"02-Two-Actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. It extracts the position feedback (in radians) and prints it along with the actuator's address.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"02-Two-Actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We auto-detect the USB port to which the CAN adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> <pre><code># Auto-detect the port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"02-Two-Actuators/#initialize-and-configure-actuators","title":"Initialize and Configure Actuators","text":"<p>For each actuator address, we:</p> <ul> <li>Create a PulsarActuator instance.</li> <li>Attempt to connect to the actuator.</li> <li>Configure high-frequency feedback to report position at 10 Hz.</li> <li>Disable low-frequency feedback.</li> <li>Set the actuator to SPEED mode.</li> <li>Register the feedback callback function.</li> </ul> <p>Each successfully initialized actuator is added to a list for later control.</p> <pre><code>actuators = []\n\nfor address in CSP_ADDRESSES:\n    actuator = PulsarActuator(adapter, address)\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"02-Two-Actuators/#set-setpoints-and-start-actuators","title":"Set Setpoints and Start Actuators","text":"<p>We assign different speed setpoints to each actuator and start them. This allows both actuators to run simultaneously at different speeds.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n</code></pre>"},{"location":"02-Two-Actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We let the actuators run briefly to allow feedback to be printed. When the program is interrupted (e.g., via Ctrl+C), we ensure all actuators are properly disconnected and the adapter is closed.</p> <pre><code>try:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"03-Changing-Parameters/","title":"03. Advanced Features","text":"<p>This notebook demonstrates advanced configuration and control of a Pulsar actuator using the pcp_api library. It builds upon the basic example, which covers:</p> <ul> <li>Connecting to the actuator</li> <li>Setting feedback items and rates</li> <li>Running in speed mode with a fixed setpoint</li> </ul>"},{"location":"03-Changing-Parameters/#in-this-advanced-tutorial-you-will-learn-how-to","title":"In this advanced tutorial, you will learn how to:","text":"<ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"03-Changing-Parameters/#import-required-modules","title":"Import Required Modules","text":"<p>We begin by importing the necessary modules to interact with the actuator, manage the CAN interface, and handle timing and output formatting. <pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre></p>"},{"location":"03-Changing-Parameters/#detect-and-connect-to-the-can-adapter","title":"Detect and Connect to the CAN Adapter","text":"<p>This section automatically detects the USB port where the CAN adapter is connected and initializes the adapter for communication. <pre><code># Automatically detect the CAN port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = CANoverUSB(port)\n</code></pre></p>"},{"location":"03-Changing-Parameters/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>We create an instance of the actuator using address 0 and attempt to establish a connection. If the connection fails, the program exits gracefully. <pre><code># Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n</code></pre></p>"},{"location":"03-Changing-Parameters/#define-the-control-parameters","title":"Define the control parameters","text":"<p>Here we define the performance profiles and control parameters:</p> <ul> <li>Torque performance is set to BALANCED for fast torque response.</li> <li>Speed performance is also set to BALANCED for quick speed adjustments.</li> <li>Control parameters like damping and stiffness are set to custom values to fine-tune the actuator's dynamic behavior.</li> </ul> <pre><code>K_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n</code></pre>"},{"location":"03-Changing-Parameters/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>This block performs several advanced configuration steps:</p> <ul> <li>Resets the encoder to define a new zero position.</li> <li>Changes the actuator's address (optional).</li> <li>Applies performance profiles for torque and speed.</li> <li>Sets custom control parameters.</li> <li>Optionally saves the configuration to persistent memory.</li> </ul> <pre><code>try:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n</code></pre>"},{"location":"03-Changing-Parameters/#run-and-verify-that-the-motor-control-behaves-as-required","title":"Run and Verify That the Motor Control Behaves as Required","text":"<p>This section reinitializes the actuator and sets it up for real-time feedback monitoring. It demonstrates how to verify that the actuator behaves as expected after applying the advanced configuration.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"04-Log-To-CSV/","title":"04. Log Data to CSV","text":"<p>This script is designed to connect to a Pulsar actuator using a CAN-over-USB adapter. It logs high-frequency sensor data and saves it to a CSV file for later analysis.</p>"},{"location":"04-Log-To-CSV/#import-required-modules","title":"Import Required Modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom time import sleep, time\nimport csv\n</code></pre>"},{"location":"04-Log-To-CSV/#connect-to-the-can-adapter","title":"Connect to the CAN Adapter","text":"<pre><code># Automatically detect the CAN port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"04-Log-To-CSV/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>This creates an actuator object at address 0 <pre><code>actuator = PulsarActuator(adapter, 0)\n</code></pre></p>"},{"location":"04-Log-To-CSV/#specify-the-logging-variables","title":"Specify the Logging Variables","text":"<p>Specifies which sensor data to log (e.g., torque sensor, PCB temperature)</p> <pre><code>if not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"04-Log-To-CSV/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<ul> <li>Sets up high-frequency feedback (1kHz) for selected items.</li> <li>Disables low-frequency feedback.</li> </ul> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"04-Log-To-CSV/#preaparig-csv-logging","title":"Preaparig CSV Logging","text":"<p>This opens a CSV file for writing</p> <p><pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n</code></pre> Adding a header row with the timestamp and item names</p> <pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"04-Log-To-CSV/#define-feedback-callback","title":"Define Feedback Callback","text":"<p>This function is called whenever new feedback data is recieved</p> <pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"04-Log-To-CSV/#start-actuator","title":"Start Actuator","text":"<pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\n</code></pre>"},{"location":"04-Log-To-CSV/#run-and-cleanup","title":"Run and Cleanup","text":"<p>This runs for 3 seconds, then disconnects and closes everything</p> <p><pre><code>try:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre> The CSV is updated for postprocessing</p>"},{"location":"Classes-02-ConnectionAndAdress/","title":"Connection and Address Management","text":"<p>The <code>PulsarActuator</code> class provides methods to establish and terminate communication with an actuator, verify its availability, and configure its CAN address.</p>"},{"location":"Classes-02-ConnectionAndAdress/#connecting-to-the-actuator","title":"Connecting to the Actuator","text":"<p>To initiate communication with an actuator, use the <code>connect()</code> method. * Description: Sends a PING message to the actuator and waits for a PONG response within the specified timeout period.</p> <ul> <li>Parameters: timeout (float, optional): Maximum time to wait for a response, in seconds. Default is 1.0.</li> <li>Returns: True if the actuator responds within the timeout window, False otherwise.</li> <li>Usage Example: <pre><code>if actuator.connect():\n    print(\"Actuator connected successfully.\")\nelse:\n    print(\"Failed to connect to actuator.\")\n</code></pre></li> </ul>"},{"location":"Classes-02-ConnectionAndAdress/#disconnecting-from-the-actuator","title":"Disconnecting from the Actuator","text":"<p>To safely terminate communication, use the <code>disconnect()</code> method:</p> <ul> <li>Description: Sends a STOP command to the actuator to halt any ongoing operations and ensure a safe disconnection.</li> <li>Usage Example:  <pre><code>actuator.disconnect()\n</code></pre></li> </ul>"},{"location":"Classes-02-ConnectionAndAdress/#pinging-the-actuator","title":"Pinging the Actuator","text":"<p>To check if a specific CAN address is active and responsive, use the send_ping() method. * Description: Sends a PING message and waits for a PONG response.</p> <ul> <li>Parameters: timeout (float, optional): Time to wait for a response, in seconds. Default is 1.0. Returns: True if a response is received within the timeout, False otherwise.</li> </ul> <p>Usage Example: <pre><code>if actuator.send_ping():\n    print(\"Actuator is responsive.\")\nelse:\n    print(\"No response from actuator.\")\n</code></pre></p>"},{"location":"Classes-02-ConnectionAndAdress/#changing-the-actuators-can-address","title":"Changing the Actuator's CAN Address","text":"<p>By default, actuators may start with a randomly assigned CAN address. To integrate the actuator into a known network configuration, you can assign it a specific address using: <pre><code>changeAddress(new_address)\n</code></pre> * Parameters: new_address (int): The new CAN address to assign. Must be within the valid range: <pre><code>0x10 \u2264 new_address \u2264 0x3FFE\n</code></pre> * Usage Example:  <pre><code>actuator.changeAddress(0x20)\n</code></pre></p> <p>Important</p> <p>Make sure to assign a unique CAN address to each actuator to avoid communication conflicts on the network.</p>"},{"location":"Classes-03-Feedback/","title":"Feedback Configuration from the Pulsar Actuator","text":"<p>To efficiently manage data flow and avoid saturating the CAN bus, the PulsarActuator API supports two feedback channels with configurable update rates:</p> <ul> <li>High-Frequency Feedback: For fast-changing signals (e.g., torque, speed).</li> <li>Low-Frequency Feedback: For slower or less critical signals (e.g., temperature, voltage). Each channel allows you to specify:</li> <li>Which feedback items to receive.</li> <li>The rate at which they are updated.</li> </ul>"},{"location":"Classes-03-Feedback/#high-frequency-feedback","title":"\ud83d\udd01 High-Frequency Feedback","text":""},{"location":"Classes-03-Feedback/#sethighfreqfeedbackitemsitems-list","title":"setHighFreqFeedbackItems(items: list)","text":"<p>Sets the list of feedback items to be sent at high frequency.</p> <ul> <li>Parameters: <code>items</code> A list of PulsarActuator.PCP_Items enums (see Table 1).</li> </ul>"},{"location":"Classes-03-Feedback/#sethighfreqfeedbackraterate-rates","title":"setHighFreqFeedbackRate(rate: Rates)","text":"<p>Sets the update rate for high-frequency feedback.</p> <ul> <li>Parameters: <code>rate</code> A value from the PulsarActuator.Rates enum (see Table 2).</li> </ul>"},{"location":"Classes-03-Feedback/#low-frequency-feedback","title":"\ud83d\udd52 Low-Frequency Feedback","text":""},{"location":"Classes-03-Feedback/#setlowfreqfeedbackitemsitems-list","title":"setLowFreqFeedbackItems(items: list)","text":"<p>Sets the list of feedback items to be sent at low frequency.</p> <ul> <li>Parameters: <code>items</code> A list of PulsarActuator.PCP_Items enums.</li> </ul>"},{"location":"Classes-03-Feedback/#setlowfreqfeedbackraterate-rates","title":"setLowFreqFeedbackRate(rate: Rates)","text":"<p>Sets the update rate for low-frequency feedback.</p> <ul> <li>Parameters: <code>rate</code> A value from the PulsarActuator.Rates enum.</li> </ul>"},{"location":"Classes-03-Feedback/#receiving-feedback","title":"\ud83d\udce1 Receiving Feedback","text":"<p>To handle incoming feedback, you can register a callback function.</p>"},{"location":"Classes-03-Feedback/#set_feedback_callbackcallback-callable-none","title":"set_feedback_callback(callback: callable) -&gt; None","text":"<p>Registers a function to be called whenever new feedback is received. * Parameters: <code>callback</code> A callable that will be executed with each feedback update.</p>"},{"location":"Classes-03-Feedback/#table-1-configurable-feedback-items-pcp_items-enum","title":"\ud83d\udcd8 Table 1 \u2013 Configurable Feedback Items (<code>PCP_Items</code> Enum)","text":"Enum Name Code Description <code>ENCODER_INT</code> 0x41 Internal encoder position (rads) <code>ENCODER_INT_RAW</code> 0x42 Raw internal encoder value (uint32) <code>ENCODER_EXT</code> 0x43 External encoder position (rads) <code>ENCODER_EXT_RAW</code> 0x44 Raw external encoder value (uint32) <code>SPEED_FB</code> 0x45 Output speed (rad/s) <code>IA</code>, <code>IB</code>, <code>IC</code> 0x46\u20130x48 Phase currents A, B, C (Amps) <code>TORQUE_SENS</code> 0x49 Measured torque (Nm) <code>TORQUE_SENS_RAW</code> 0x4A Raw torque sensor value (uint32) <code>POSITION_REF</code> 0x4B Position mode command (rads) <code>POSITION_FB</code> 0x4C Actual position (rads) <code>SPEED_REF</code> 0x4D Speed mode command (rad/s) <code>ID_REF</code>, <code>ID_FB</code> 0x4F\u20130x50 Direct current reference and feedback (Amps) <code>IQ_REF</code>, <code>IQ_FB</code> 0x51\u20130x52 Quadrature current reference and feedback (Amps) <code>VD_REF</code>, <code>VQ_REF</code> 0x53\u20130x54 DVI mode voltage references (Volts) <code>TORQUE_REF</code>, <code>TORQUE_FB</code> 0x55\u20130x56 Torque command and feedback (Nm) <code>ENABLE</code> 0x57 Actuator enabled state (0/1) <code>ERRORS_ENCODER_INT</code> 0x60 Internal encoder error count <code>ERRORS_ENCODER_EXT</code> 0x61 External encoder error count <code>ERRORS_OVERRUN</code> 0x62 Loop overrun count <code>VBUS</code> 0x70 Bus voltage <code>TEMP_PCB</code> 0x71 PCB temperature <code>TEMP_MOTOR</code> 0x72 Motor winding temperature"},{"location":"Classes-03-Feedback/#table-2-feedback-rates-rates-enum","title":"\u23f1\ufe0f Table 2 \u2013 Feedback Rates (<code>Rates</code> Enum)","text":"Enum Name Value Update Frequency <code>DISABLED</code> 0 Disabled <code>RATE_1KHZ</code> 10 1,000 Hz <code>RATE_100HZ</code> 100 100 Hz <code>RATE_50HZ</code> 200 50 Hz <code>RATE_10HZ</code> 1,000 10 Hz <code>RATE_5HZ</code> 2,000 5 Hz <code>RATE_2HZ</code> 5,000 2 Hz <code>RATE_1HZ</code> 10,000 1 Hz <p>Important</p> <p>To optimize CAN bus performance, only enable the feedback items and rates necessary for your application.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/","title":"Reading and Modifying Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#reading-actuator-parameters","title":"Reading Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Retrieve all configuration parameters of the actuator at once.</p> <p>Returns: - <code>dict</code>: A dictionary containing all parameters and their values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#get_parametersparameters-timeout10","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Retrieve specific parameters from the actuator.</p> <p>Parameters: - <code>parameters</code> (list): A list of parameters to request (see Table 3). - <code>timeout</code> (float, optional): Maximum time to wait for a response, in seconds. Default is <code>1.0</code>.</p> <p>Returns: - <code>dict</code>: A dictionary containing the requested parameters and their values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#modifying-actuator-parameters","title":"Modifying Actuator Parameters","text":""},{"location":"Classes-04-PulsarActuator_Parameters/#set_parametersparameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Modify specific parameters of the actuator.</p> <p>Parameters: - <code>parameters</code> (dict): A dictionary with <code>PCP_Parameters</code> enums as keys and their corresponding values.</p>"},{"location":"Classes-04-PulsarActuator_Parameters/#table-3-pcp_parameters-enum","title":"Table 3 \u2013 <code>PCP_Parameters</code> Enum","text":"Enum Name Code Description <code>K_DAMPING</code> 0x01 Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control) <code>K_STIFFNESS</code> 0x02 Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control) <code>TORQUE_FF</code> 0x03 Torque of Feedforward Value (Nm) <code>LIM_TORQUE</code> 0x04 Max. Torque Limit. Some limit value to positive or negative torques (Nm) <code>LIM_POSITION_MAX</code> 0x05 Max. Position Limit (Rad) <code>LIM_POSITION_MIN</code> 0x06 Min. Position Limit (Rad) <code>LIM_SPEED_MAX</code> 0x07 Max. Speed Limit (Rad/s) <code>LIM_SPEED_MIN</code> 0x08 Min. Position Limit (Rad) <code>PROFILE_POSITION_MAX</code> 0x09 Max. Positive Speed (rad/s) in Position control configuration <code>PROFILE_POSITION_MIN</code> 0x0A Min. Negative Speed (rad/s) in Position control configuration <code>PROFILE_SPEED_MAX</code> 0x0B Max. Acceleration (rad/s^2) in Speed control configuration <code>PROFILE_SPEED_MIN</code> 0x0C Max. Deceleration (rad/s^2) in Speed control configuration <code>KP_SPEED</code> 0x0D Kp speed control constant P value <code>KI_SPEED</code> 0x0E Ki speed control constant I value <code>KP_POSITION</code> 0x0F Kp position control constant P value <code>MODE</code> 0x30 Operation Mode (read-only, must be set via <code>CHANGE_MODE</code>) <code>SETPOINT</code> 0x31 Setpoint <code>FIRMWARE_VERSION</code> 0x80 Firmware version <p>Important</p> <p>Ensure that the parameters you modify are within the valid range and do not conflict with other settings to avoid improper actuator behavior.</p>"},{"location":"Classes-05-PerformanceProfiles/","title":"Predefined Performance Profiles for Actuator Control","text":"<p>The actuator provides a set of predefined performance profiles for both torque and speed control loops. These profiles allow users to easily configure the system's responsiveness without manually tuning low-level control parameters. Each profile adjusts the bandwidth and stability of the inner control loops, which is essential for achieving optimal behavior in dynamic or high-precision applications.</p>"},{"location":"Classes-05-PerformanceProfiles/#torque-control-loop-performance","title":"Torque Control Loop Performance","text":"<p>This setting determines how quickly and aggressively the actuator responds to torque commands. The available profiles are:</p>"},{"location":"Classes-05-PerformanceProfiles/#aggressive","title":"AGGRESSIVE","text":"<ul> <li>Bandwidth: ~1000 Hz  </li> <li>Behavior: Maximizes responsiveness and torque application speed.  </li> <li>Use Case: Ideal for dynamic tasks such as impedance control or joint torque control.  </li> <li>Trade-off: May reduce steady-state precision.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#balanced","title":"BALANCED","text":"<ul> <li>Bandwidth: ~500 Hz  </li> <li>Behavior: Offers a compromise between responsiveness and stability.  </li> <li>Use Case: Suitable for general-purpose applications.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#soft","title":"SOFT","text":"<ul> <li>Bandwidth: ~100 Hz  </li> <li>Behavior: Prioritizes smoothness and precision over speed.  </li> <li>Use Case: Best for tasks requiring high torque fidelity and low noise.  </li> <li>Trade-off: Lower responsiveness.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#custom-if-supported","title":"CUSTOM (if supported)","text":"<ul> <li>Behavior: Allows manual tuning of control gains.  </li> <li>Use Case: For advanced users with specialized requirements.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#api-command","title":"API Command","text":"<p><pre><code>set_torque_performance(self, performance: TorquePerformance)\n</code></pre> - Parameter: <code>performance</code>   - Type: <code>PulsarActuator.TorquePerformance</code>   - Description: Sets the desired torque control profile.</p>"},{"location":"Classes-05-PerformanceProfiles/#table-4-torqueperformance-enum","title":"Table 4 \u2013 <code>TorquePerformance</code> (Enum)","text":"Name Value Bandwidth (Hz) Description AGGRESSIVE 1 ~1000 Hz Fast response, less precision in steady state BALANCED 2 ~500 Hz Balanced between response and stability SOFT 3 ~100 Hz Stable and quiet, low responsiveness"},{"location":"Classes-05-PerformanceProfiles/#speed-loop-performance","title":"Speed Loop Performance","text":"<p>The speed control loop uses the same predefined profiles as the torque loop, ensuring consistent behavior tuning across both control domains.</p>"},{"location":"Classes-05-PerformanceProfiles/#aggressive_1","title":"AGGRESSIVE","text":"<ul> <li>Behavior: Enables rapid speed tracking with minimal delay and short settling time.</li> <li>Use Case: High-speed applications where quick velocity changes are required.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#balanced_1","title":"BALANCED","text":"<ul> <li>Behavior: Provides a well-rounded compromise between speed and stability.</li> <li>Use Case: Suitable for general-purpose motion control tasks.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#soft_1","title":"SOFT","text":"<ul> <li>Behavior: Emphasizes smooth, accurate motion over speed.</li> <li>Use Case: Ideal for applications requiring low noise and precise velocity regulation.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#custom","title":"CUSTOM","text":"<ul> <li>Behavior: Grants full control over PI controller gains.</li> <li>Use Case: Advanced tuning for specialized systems or experimental setups.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#api-command_1","title":"API Command","text":"<p>To configure the speed loop performance, use the following API method:</p> <pre><code>set_speed_performance(self, performance: SpeedPerformance)\n</code></pre>"},{"location":"Classes-05-PerformanceProfiles/#parameter-performance","title":"Parameter: <code>performance</code>","text":"<ul> <li>Type: <code>PulsarActuator.SpeedPerformance</code></li> <li>Description: Sets the desired speed control profile.</li> </ul>"},{"location":"Classes-05-PerformanceProfiles/#table-5-speedperformance-enum","title":"Table 5 \u2013 <code>SpeedPerformance</code> (Enum)","text":"Name Value Description AGGRESSIVE 1 Aggressive speed control profile BALANCED 2 Balanced speed control profile SOFT 3 Soft speed control profile CUSTOM 4 Custom-defined profile"},{"location":"Classes-06-ActuatorOperation/","title":"Actuator Operation: Startup, Shutdown, and Control Modes","text":""},{"location":"Classes-06-ActuatorOperation/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"Classes-06-ActuatorOperation/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>When the actuator is powered on with the control mode set to Calibration, the system performs an automatic offset calibration. This process aligns the electrical position of the motor with the mechanical position of the encoder, ensuring accurate motion control.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"Classes-06-ActuatorOperation/#1-electromagnetic-torque-control","title":"1. Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p>"},{"location":"Classes-06-ActuatorOperation/#2-speed-control","title":"2. Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p>"},{"location":"Classes-06-ActuatorOperation/#3-position-control","title":"3. Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#4-impedance-control","title":"4. Impedance Control","text":"<p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior.</p>"},{"location":"Classes-06-ActuatorOperation/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"Classes-06-ActuatorOperation/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p>"},{"location":"Classes-06-ActuatorOperation/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p>"},{"location":"Classes-06-ActuatorOperation/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p>"},{"location":"Classes-06-ActuatorOperation/#changing-control-modes","title":"Changing Control Modes","text":"<p>To switch between control modes, use the following method:</p> <p>Parameters:</p> <ul> <li><code>mode (PulsarActuatorMode)</code>: The desired control mode to activate. Refer to Table 6 for a complete list of available modes and their descriptions.</li> </ul>"},{"location":"Classes-06-ActuatorOperation/#table-6-mode-enum","title":"Table 6 \u2013 Mode (Enum)","text":"Mode Name Enum Value Description CALIBRATION <code>0x01</code> Calibration mode FVI <code>0x02</code> Fixed Voltage Injection OPEN_LOOP <code>0x03</code> Open-loop control DVI <code>0x04</code> Direct Voltage Injection (field-oriented) TORQUE <code>0x05</code> Electromagnetic Torque Control SPEED <code>0x06</code> Speed Control POSITION <code>0x07</code> Position Control IMPEDANCE <code>0x08</code> Impedance Control"},{"location":"classes-01-InitialisationContrustor/","title":"Initialization and Constructor","text":"<p>To create an instance of the <code>PulsarActuator</code> class, you must provide a CAN bus handler (commonly referred to as an adapter) and the actuator\u2019s CAN address. Optionally, you may also supply a custom logger for debugging and monitoring purposes.</p>"},{"location":"classes-01-InitialisationContrustor/#python-usage","title":"Python Usage","text":"<pre><code>PulsarActuator(canbus_handler, address: int, logger=None)\n</code></pre>"},{"location":"classes-01-InitialisationContrustor/#parameters","title":"Parameters","text":"<ul> <li>canbus_handler (object):An object responsible for managing communication over the CAN bus. This handler must implement the method: <pre><code>setCallback(address, callback_fn)\n</code></pre> This method is used to register a callback function that processes incoming CAN messages for the specified actuator address.</li> <li>address(int): The unique CAN address assigned to the actuator. This address is used to identify and communicate with the specific device on the CAN network.</li> <li>logger(Logger,optional): A Python Logger instance used for logging internal events, warnings, and errors. If not provided, the class defaults to using Python\u2019s root logger.</li> </ul>"},{"location":"classes/","title":"Class Definitions","text":""},{"location":"classes/#overview-of-the-pulsaractuator-communication-interface","title":"Overview of the PulsarActuator Communication Interface","text":"<p>At the core of PCP (Pulsar Control Protocol) communication lies the PulsarActuator class. This class serves as the primary high-level interface for interacting with and managing a Pulsar motor or actuator controller via the CAN (Controller Area Network) bus. It abstracts the complexities of low-level communication, providing developers with a streamlined and intuitive API for real-time control and monitoring.</p>"},{"location":"classes/#key-capabilities-of-the-pulsaractuator-api","title":"Key Capabilities of the PulsarActuator API","text":"<p>The PulsarActuator class offers a comprehensive suite of features designed to facilitate robust and flexible actuator control. These include:</p> <ul> <li>Real-Time Command and Control: Send precise control commands to the actuator in real time.</li> <li>Mode Switching: Seamlessly transition between various control modes such as torque, velocity, position, and impedance.</li> <li>Live Feedback Monitoring: Continuously receive and process real-time feedback from the actuator via CAN messages.</li> <li>Parameter Configuration and Management: Set, retrieve, and persist actuator parameters for fine-tuned performance.</li> <li>Diagnostics and Health Monitoring: Access diagnostic data to evaluate actuator status and detect potential issues.</li> </ul>"},{"location":"classes/#what-this-class-definition-covers","title":"What This Class Definition Covers","text":"<p>This manual provides detailed guidance on how to effectively use the PulsarActuator class to:</p>"},{"location":"classes/#operate-the-actuator-in-multiple-control-modes-including","title":"Operate the actuator in multiple control modes, including:","text":"<ul> <li>Torque Control: Apply a specific torque to the actuator.</li> <li>Speed Control: Regulate the actuator\u2019s rotational velocity.</li> <li>Position Control: Move the actuator to a defined position.</li> <li>Impedance Control: Combine position and force control for compliant motion.</li> </ul>"},{"location":"classes/#configure-and-query-actuator-parameters-such-as","title":"Configure and query actuator parameters, such as:","text":"<ul> <li>PID gains</li> <li>Safety limits</li> <li>Communication settings</li> </ul>"},{"location":"classes/#receive-and-interpret-real-time-feedback-including","title":"Receive and interpret real-time feedback, including:","text":"<ul> <li>Position, velocity, and torque readings</li> <li>Temperature and voltage levels</li> <li>Error and status flags</li> </ul>"},{"location":"classes/#modify-actuator-settings-and-perform-diagnostics-enabling","title":"Modify actuator settings and perform diagnostics, enabling:","text":"<ul> <li>Firmware updates</li> <li>Fault detection and recovery</li> <li>System calibration and tuning</li> </ul>"}]}