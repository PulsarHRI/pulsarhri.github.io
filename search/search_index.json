{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Welcome to the Pulsar API repository! This repository contains everything you need to begin working with the Pulsar Actuator or Pulsar Motor. Whether you're a researcher, developer, or engineer, this guide will walk you through setting up your environment, installing the API, and accessing the documentation and examples.</p> <p>The Pulsar API is designed to provide a robust and flexible interface for controlling and monitoring Pulsar hardware. It includes:</p> <ul> <li>A well-documented Python package (pcp_api)</li> <li>Example scripts for common use cases</li> <li>Detailed descriptions of available classes, methods, and parameters</li> <li>Best practices for integration and deployment</li> </ul>"},{"location":"#installing-the-pulsar-api-into-your-own-environment","title":"Installing the Pulsar API into your own Environment","text":"<p>To ensure a clean and manageable development setup, we strongly recommend using a virtual environment. This helps isolate your dependencies and avoid conflicts with other Python packages on your system.</p>"},{"location":"#step-1-create-a-virtual-environment","title":"Step 1: Create a Virtual Environment","text":"<p>Open your terminal or command prompt and run:</p> <p><pre><code>python -m venv .venv\n</code></pre> This will create a new virtual environment in a folder named .venv within your project directory.</p>"},{"location":"#step-2-activate-the-virtual-environment","title":"Step 2: Activate the Virtual Environment","text":"<p>Before installing the Pulsar API, activate the virtual environment. The activation command depends on your operating system:</p> Linux/macOSWindows (PowerShell) <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Once activated, your terminal prompt should change to indicate that you're working inside the virtual environment.</p>"},{"location":"#step-3-install-the-pulsar-api","title":"Step 3: Install the Pulsar API","text":"<p>With the virtual environment active, install the Pulsar API package using <code>pip</code>:</p> <p><pre><code>pip install pcp_api\n</code></pre> This command will download and install the latest version of the pcp_api package from PyPI or your configured package index.</p> <p>IMPORTANT NOTE</p> <p>Every time you want to use the Pulsar API or run the example scripts, make sure to activate your virtual environment first. If you close your terminal or restart your system, you\u2019ll need to reactivate it.</p>"},{"location":"#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>python -c \"import pcp_api; print(pcp_api.__version__)\"\n</code></pre> This should print the version number of the installed package, indicating that it's ready to use.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Explore the documentation for detailed usage instructions.</li> <li>Run example scripts provided in the examples/ directory.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please refer to the Troubleshooting section in the documentation or open an issue in this repository.</p>"},{"location":"01-Single-Actuator/","title":"01. Controlling One Target","text":"<p>This notebook demonstrates how to connect to a Pulsar actuator using the pcp_api library and CANoverUSB, configure feedback settings, and control one actuator in speed mode.</p>"},{"location":"01-Single-Actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"01-Single-Actuator/#define-the-actuator-address","title":"Define the actuator address","text":"<p>Specify the address of the actuator. Use <code>0</code> if you're connecting directly via USB. If you're using a CAN adapter, replace it with the appropriate PCP address assigned to your actuator.</p> <pre><code>ACTUATOR_ADDRESS = 0\n</code></pre>"},{"location":"01-Single-Actuator/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is automatically triggered whenever feedback is received from the actuator. It prints the full feedback dictionary and extracts the speed feedback (if available), displaying it in a readable format.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n</code></pre>"},{"location":"01-Single-Actuator/#connect-to-the-actuator","title":"Connect to the actuator","text":"<p>Automatically detect the USB port, create the CAN adapter, and attempt to connect to the actuator. If the connection fails, the program exits gracefully.</p> <pre><code>port = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"01-Single-Actuator/#configure-feedback-and-control-settings","title":"Configure feedback and control settings","text":"<p>Set up the feedback configuration and control mode:</p> <ul> <li>High-frequency feedback includes speed, position, and torque.</li> <li>Low-frequency feedback includes bus voltage and motor temperature.</li> <li>The actuator is switched to SPEED mode and given a setpoint of 1 rad/s.</li> <li>Parameters are retrieved and printed for inspection.</li> <li>The actuator is started and feedback is monitored in a loop.</li> </ul> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"01-Single-Actuator/#shutdown","title":"Shutdown","text":"<p>Ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C or notebook stop).</p>"},{"location":"02-Two-Actuators/","title":"02. Controlling Two Targets","text":"<p>This notebook demonstrates how to control multiple Pulsar actuators using the CANoverUSB interface. We will walk through the steps of connecting to the USB-CAN adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p>"},{"location":"02-Two-Actuators/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre>"},{"location":"02-Two-Actuators/#define-constants-and-feedback-function","title":"Define Constants and Feedback Function","text":"<p>We define the CSP (CANopen Slave Protocol) addresses for the two actuators. These addresses are used to uniquely identify each actuator on the CAN bus.</p> <pre><code># Example CSP addresses for two actuators\nCSP_ADDRESSES = [0x10, 0x11]\n</code></pre>"},{"location":"02-Two-Actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. It extracts the position feedback (in radians) and prints it along with the actuator's address.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"02-Two-Actuators/#connect-to-usb-can-adapter","title":"Connect to USB-CAN Adapter","text":"<p>We auto-detect the USB port to which the CAN adapter is connected and create an instance of the adapter. This step is essential to establish communication with the actuators.</p> <pre><code># Auto-detect the port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"02-Two-Actuators/#initialize-and-configure-actuators","title":"Initialize and Configure Actuators","text":"<p>For each actuator address, we:</p> <ul> <li>Create a PulsarActuator instance.</li> <li>Attempt to connect to the actuator.</li> <li>Configure high-frequency feedback to report position at 10 Hz.</li> <li>Disable low-frequency feedback.</li> <li>Set the actuator to SPEED mode.</li> <li>Register the feedback callback function.</li> </ul> <p>Each successfully initialized actuator is added to a list for later control.</p> <pre><code>actuators = []\n\nfor address in CSP_ADDRESSES:\n    actuator = PulsarActuator(adapter, address)\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address}\")\n\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n</code></pre>"},{"location":"02-Two-Actuators/#set-setpoints-and-start-actuators","title":"Set Setpoints and Start Actuators","text":"<p>We assign different speed setpoints to each actuator and start them. This allows both actuators to run simultaneously at different speeds.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)\nactuators[1].change_setpoint(0.3)\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n</code></pre>"},{"location":"02-Two-Actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We let the actuators run briefly to allow feedback to be printed. When the program is interrupted (e.g., via Ctrl+C), we ensure all actuators are properly disconnected and the adapter is closed.</p> <pre><code>try:\n    sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"03-Changing-Parameters/","title":"03. Advanced Features","text":"<p>This notebook demonstrates advanced configuration and control of a Pulsar actuator using the pcp_api library. It builds upon the basic example, which covers:</p> <ul> <li>Connecting to the actuator</li> <li>Setting feedback items and rates</li> <li>Running in speed mode with a fixed setpoint</li> </ul>"},{"location":"03-Changing-Parameters/#in-this-advanced-tutorial-you-will-learn-how-to","title":"In this advanced tutorial, you will learn how to:","text":"<ul> <li>\ud83d\udd04 Reset the encoder to define a custom zero position</li> <li>\ud83c\udd94 Change the actuator's PCP address dynamically</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul> <p>These features are useful for fine-tuning actuator behavior, multi-actuator setups, and persistent deployment scenarios.</p>"},{"location":"03-Changing-Parameters/#import-required-modules","title":"Import Required Modules","text":"<p>We begin by importing the necessary modules to interact with the actuator, manage the CAN interface, and handle timing and output formatting. <pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom pprint import pprint\nfrom time import sleep\n</code></pre></p>"},{"location":"03-Changing-Parameters/#detect-and-connect-to-the-can-adapter","title":"Detect and Connect to the CAN Adapter","text":"<p>This section automatically detects the USB port where the CAN adapter is connected and initializes the adapter for communication. <pre><code># Automatically detect the CAN port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = CANoverUSB(port)\n</code></pre></p>"},{"location":"03-Changing-Parameters/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>We create an instance of the actuator using address 0 and attempt to establish a connection. If the connection fails, the program exits gracefully. <pre><code># Create actuator instance with ID 0\nactuator = PulsarActuator(adapter, 0)\n\n# Attempt to connect\nif not actuator.connect():\n    print(\"Could not connect to the actuator\")\n    adapter.close()\n    raise SystemExit(\"Exiting due to connection failure.\")\nprint(\"Connected to the actuator\")\n</code></pre></p>"},{"location":"03-Changing-Parameters/#define-the-control-parameters","title":"Define the control parameters","text":"<p>Here we define the performance profiles and control parameters:</p> <ul> <li>Torque performance is set to BALANCED for fast torque response.</li> <li>Speed performance is also set to BALANCED for quick speed adjustments.</li> <li>Control parameters like damping and stiffness are set to custom values to fine-tune the actuator's dynamic behavior.</li> </ul> <pre><code>K_DAMPING = 7.7\nK_STIFFNESS = 8.8 \n</code></pre>"},{"location":"03-Changing-Parameters/#apply-advanced-configuration","title":"Apply Advanced Configuration","text":"<p>This block performs several advanced configuration steps:</p> <ul> <li>Resets the encoder to define a new zero position.</li> <li>Changes the actuator's address (optional).</li> <li>Applies performance profiles for torque and speed.</li> <li>Sets custom control parameters.</li> <li>Optionally saves the configuration to persistent memory.</li> </ul> <pre><code>try:\n    # Reset encoder to define zero position\n    actuator.reset_encoder_position()\n\n    # Change the actuator's address (optional)\n    actuator.changeAddress(0x15)\n\n    # Set performance modes\n    actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\n    actuator.set_speed_performance(PulsarActuator.SpeedPerformance.AGGRESSIVE)\n\n    # Set control parameters\n    actuator.set_parameters({\n        PulsarActuator.PCP_Parameters.K_DAMPING: K_DAMPING ,\n        PulsarActuator.PCP_Parameters.K_STIFFNESS: K_STIFFNESS,\n    })\n\n    # Optional: Save configuration to persistent memory\n    actuator.save_config()\n\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user.\")\n\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n    print(\"Disconnected and cleaned up.\")\n</code></pre>"},{"location":"03-Changing-Parameters/#run-and-verify-that-the-motor-control-behaves-as-required","title":"Run and Verify That the Motor Control Behaves as Required","text":"<p>This section reinitializes the actuator and sets it up for real-time feedback monitoring. It demonstrates how to verify that the actuator behaves as expected after applying the advanced configuration.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\nACTUATOR_ADDRESS = 0\n\nport = CANoverUSB.get_port()  # auto-detect\nprint(f\"Connecting to {port}\")\nadapter = CANoverUSB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nelse:\n    print(f\"Connected to the actuator {actuator.address}\")\n</code></pre> <pre><code>try:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1)  # rad/s\n    # Retrieve and Display Actuator Parameters\n    params = actuator.get_parameters_all()\n    pprint(params)\n\n    # Start the actuator and monitor feedback\n\n    # The loop will keep running until interrupted (e.g., by pressing `Stop` in the notebook).\n    actuator.start()\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\n\n## Shutdown\n\n#Disconnect the actuator and close the adapter when the program is interrupted.\n\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"04-Log-To-CSV/","title":"04. Log Data to CSV","text":"<p>This script is designed to connect to a Pulsar actuator using a CAN-over-USB adapter. It logs high-frequency sensor data and saves it to a CSV file for later analysis.</p>"},{"location":"04-Log-To-CSV/#import-required-modules","title":"Import Required Modules","text":"<pre><code># Import necessary modules\nfrom pcp_api.PulsarActuator import PulsarActuator\nfrom pcp_api.can_over_usb import CANoverUSB\nfrom time import sleep, time\nimport csv\n</code></pre>"},{"location":"04-Log-To-CSV/#connect-to-the-can-adapter","title":"Connect to the CAN Adapter","text":"<pre><code># Automatically detect the CAN port\nport = CANoverUSB.get_port()\nprint(f\"Connecting to {port}\")\n\n# Initialize the adapter\nadapter = CANoverUSB(port)\n</code></pre>"},{"location":"04-Log-To-CSV/#initialize-the-actuator","title":"Initialize the Actuator","text":"<p>This creates an actuator object at address 0 <pre><code>actuator = PulsarActuator(adapter, 0)\n</code></pre></p>"},{"location":"04-Log-To-CSV/#specify-the-logging-variables","title":"Specify the Logging Variables","text":"<p>Specifies which sensor data to log (e.g., torque sensor, PCB temperature)</p> <pre><code>if not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address}\")\n</code></pre>"},{"location":"04-Log-To-CSV/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<ul> <li>Sets up high-frequency feedback (1kHz) for selected items.</li> <li>Disables low-frequency feedback.</li> </ul> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"04-Log-To-CSV/#preaparig-csv-logging","title":"Preaparig CSV Logging","text":"<p>This opens a CSV file for writing</p> <p><pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n</code></pre> Adding a header row with the timestamp and item names</p> <pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"04-Log-To-CSV/#define-feedback-callback","title":"Define Feedback Callback","text":"<p>This function is called whenever new feedback data is recieved</p> <pre><code># add header\nheader = [time()]  # timestamp\nheader.extend([item.name for item in sorted(itemsToLog, key=lambda x: x.name)])  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"04-Log-To-CSV/#start-actuator","title":"Start Actuator","text":"<pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1)\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\n</code></pre>"},{"location":"04-Log-To-CSV/#run-and-cleanup","title":"Run and Cleanup","text":"<p>This runs for 3 seconds, then disconnects and closes everything</p> <p><pre><code>try:\n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre> The CSV is updated for postprocessing</p>"},{"location":"classes/","title":"Classes","text":""}]}