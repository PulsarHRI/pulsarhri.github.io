{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the PULSAR HRI Ecosystem Documentation!</p> <p>Whether you're a researcher, developer, or engineer, the content on this website will help you get up and running with PULSAR products:  PULSAR HRI develops best-in-class actuation systems and surrounding ecosystem, to enable next-generation robotics.</p>"},{"location":"#first-time-here","title":"\u26a1 First Time Here?","text":"<p>If you really can't wait to get hands-on, just go straight to the Quickstart No-Code Guide to set up, power your actuator and get moving in minutes!</p> <p>Tip</p> <p>Make sure to read the following short section: it will allow you to easily find what you need in the website</p>"},{"location":"#ecosystem-overview","title":"\ud83e\udded Ecosystem Overview","text":"<p>At a glance, these are the main elements of the PULSAR HRI ecosystem:</p> <p></p> <ul> <li>REAL ACTUATORS which, once set up, offer the following hardware communication interfaces: <ul> <li>Direct USB connection</li> <li>CAN communication  </li> </ul> </li> <li>VIRTUAL ACTUATORS closely matching their Real counterparts behaviour. These Virtual Actuators can be set up thanks to:<ul> <li>\ud83d\udea7 AUGUR Digital Twin, UNDER DEVELOPMENT - modeling the physics of the real actuator and running the exact same control algorithms </li> </ul> </li> <li>CONTROL INTERFACES of different kinds and for different needs, to control both Real and Virtual Actuators:<ul> <li>Desktop Application, no-code GUI for single actuator testing, for the easiest quickstart experience and to get familiar with PULSAR HRI actuators and their control</li> <li>Python API, simple but powerful scripting to control multiple actuators for robotics prototypes and to leverage Python libraries such as for ML, AI applications<ul> <li>\ud83d\udea7 ROS2 Python Node, UNDER DEVELOPMENT</li> </ul> </li> <li>\ud83d\udea7 C++ API, UNDER DEVELOPMENT - to control multiple actuators in demanding applications with strict real-time requirements, where latency is a blocker<ul> <li>\ud83d\udea7 ROS2 C++ Node, UNDER DEVELOPMENT</li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>A quick alignment on naming we use:</p> <ul> <li>Motors = Direct-drive units without transmission  </li> <li>Actuators = Motors with integrated transmission</li> </ul> <p>A question we often hear is: </p> <p>\"How are you different from the other actuator companies?\"</p> <p>Glad you asked: check out PULSAR HRI's website for answers!</p>"},{"location":"#need-help","title":"\ud83c\udd98 Need help?","text":"<p>Visit our Support page or check the FAQ.</p> <p></p>"},{"location":"faq/","title":"FAQ","text":"<p>Coming soon ...</p>"},{"location":"support/","title":"Support","text":"<p>If you encounter any issues or have any questions regarding the use of any product, please do not hesitate to reach out to our support team. </p> <ul> <li>Support Email: support.dt@pulsarhri.com</li> <li>Support Hours: Monday to Thursday, 8:00 AM - 5:00 PM (GMT) and Friday, 8:00 AM - 1:00 PM (GMT) </li> </ul> <p>For additional resources and troubleshooting tips, please contact our support team. Thank you for choosing our product. We are committed to providing you with the best possible experience.</p> <p>You can also create an issue reporting a bug or requesting a new feature.</p>"},{"location":"why_pulsar/","title":"Why PULSAR HRI motors and actuators?","text":""},{"location":"why_pulsar/#how-are-pulsar-hri-motors-and-actuators-different-from-the-others","title":"How are PULSAR HRI motors and actuators different from the others?","text":"<p>Robotic applications require motors and actuators which can produce high torques at low speeds, while being able to change speed and torque in a reliable and agile manner. A key performance indicator often overlooked is dynamic efficiency, a critical requirement for mobile robots. </p>"},{"location":"why_pulsar/#motors","title":"Motors","text":"<p>We provide our motors both on frameless and framed configurations. Your motor, your choice. Our range covers different sizes and torques to fit multiple applications, all of them delivering dynamic response (bandwidth) and torque density, while requiring low current to drive them. Both second electrical generation motors and custom design services can be unlocked by joining our Vanguard Program.\u200b</p>"},{"location":"why_pulsar/#actuators","title":"Actuators","text":"<p>We design Quasi-Direct Drive (QDD) actuators offer a well-balanced alternative to traditional high-gear solutions.</p> <p>Design specifics also matter. Therefore, we decided to design our transmissions with a very low gear ratio to increase the total bandwidth, boost backdrivability, improve proprioceptiveness and better respond to highly-dynamic intermittent operations.</p> <p></p>"},{"location":"communicate/communicate_real/","title":"Communicate with Real Actuators","text":"<p>This page guides you through the available communication methods with a real PULSAR actuator.</p> <p>Currently, there are two supported modes of communication:</p> <ol> <li>USB: Direct connection to a single actuator using a USB-C cable.</li> <li>CAN (via USB-to-CAN adapter): Used for connecting one or multiple actuators on a CAN bus.</li> </ol> <p></p> <p>Warning</p> <p>Before continuing, ensure that your actuator is securely mounted and powered on, as explained in the Set Up Real Actuators guide.</p>"},{"location":"communicate/communicate_real/#usb-communication","title":"USB Communication","text":"<p>This is the most straightforward method for connecting a single actuator during development or testing.</p>"},{"location":"communicate/communicate_real/#1-connect-usb","title":"1. Connect USB","text":"<p>Use a USB-A to USB-C cable to connect the actuator directly to your computer.</p> <p>\ud83d\udca1 The actuator will switch LED color when USB is successfully connected.</p> <p></p>"},{"location":"communicate/communicate_real/#2-check-usb-communication","title":"2. Check USB Communication","text":"<p>To verify the connection either start up the PULSAR Desktop App, or use the Python API CLI tool.</p> <p>You should see your actuator listed.</p>"},{"location":"communicate/communicate_real/#can-communication","title":"CAN Communication","text":"<p>Step by step guide coming soon.. for now see here</p> <p>Success</p> <p>You are connected!! You can now interact with the actuator either using:</p> <ul> <li>The PULSAR HRI Desktop App as per this tutorial</li> <li>The Python API as per this other tutorial</li> </ul> <p>Question</p> <p>Need help or something doesn\u2019t work? Head over to the Support page: we\u2019ve got your back.</p>"},{"location":"communicate/communicate_virtual/","title":"Communicate with Virtual Actuators","text":"<p>Coming soon.. contact our team for more info</p>"},{"location":"control/control_modes_explained/control_modes_overview/","title":"Control modes overview","text":""},{"location":"control/control_modes_explained/control_modes_overview/#overview-of-operation-modes","title":"Overview of Operation Modes","text":"<p>Before initiating any actuator movement, it is essential to configure the appropriate control mode. The selected mode determines how the actuator interprets and responds to setpoints. Once a control mode is active, the system will establish the corresponding setpoint based on the mode\u2019s logic and parameters.</p>"},{"location":"control/control_modes_explained/control_modes_overview/#standard-control-modes","title":"Standard Control Modes","text":"<p>The actuator supports several core control strategies, each optimized for specific performance characteristics:</p>"},{"location":"control/control_modes_explained/control_modes_overview/#electromagnetic-torque-control","title":"Electromagnetic Torque Control","text":"<p>This mode directly controls the torque output of the actuator by regulating the motor current. It includes three predefined profiles, each offering a different control bandwidth\u2014from conservative to aggressive\u2014tailored for various application needs.</p> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#speed-control","title":"Speed Control","text":"<p>Speed control is implemented using a dual-loop architecture:</p> <ul> <li>The inner loop manages torque via current control.</li> <li>The outer loop regulates speed using a Proportional-Integral (PI) controller.</li> </ul> <p>Users can either manually tune the PI parameters or select from optimized preset profiles.</p> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#position-control","title":"Position Control","text":"<p>Position control is achieved through a hierarchical control structure:</p> <ul> <li>A proportional controller governs the position loop.</li> <li>This loop operates over the speed and torque control layers, ensuring smooth and accurate positioning.</li> </ul> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#impedance-control-under-development","title":"Impedance Control (Under development)","text":"<p>Warning</p> <p>DO NOT USE THIS MODE AS IT IS UNDER DEVELOPMENT</p> <p>This advanced mode simulates mechanical impedance (stiffness and damping) by manipulating motor currents at a low level. It is particularly useful for applications requiring compliant or human-interactive behavior. </p> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#special-purpose-modes","title":"Special-Purpose Modes","text":"<p>Warning</p> <p>DO NOT USE THESE MODES UNLESS SPECIFIED BY PULSAR DEVELOPMENT TEAM</p> <p>In addition to the standard modes, the actuator includes several specialized modes designed for debugging, testing, and system integration. These are not intended for regular operation but are invaluable during development and troubleshooting:</p>"},{"location":"control/control_modes_explained/control_modes_overview/#startup-calibration-mode","title":"Startup Calibration Mode","text":"<p>The actuator includes an internal calibration routine that can be triggered directly. During calibration, the system performs offset calibration for both current sensing and position measurement\u2014aligning the motor\u2019s electrical position with the mechanical position of the encoder. As part of this process, the relative position (turn count) is reset to zero.</p> <p>During this calibration:</p> <ul> <li>The relative position (also known as the \"turn count\") is reset to zero.</li> <li>Note: This does not affect the absolute position. To reset the absolute position, the <code>Set Zero Position</code> command must be used separately.</li> </ul>"},{"location":"control/control_modes_explained/control_modes_overview/#fixed-voltage-injection-fvi","title":"Fixed Voltage Injection (FVI)","text":"<p>Injects a constant DC voltage into the motor phases. Useful for basic motor testing and diagnostics.</p> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#open-loop-mode","title":"Open-Loop Mode","text":"<p>Applies a rotating voltage vector to the motor using a V/f (voltage-to-frequency) control method. This mode typically runs at a constant speed or can be configured with user-defined parameters.</p> <p></p>"},{"location":"control/control_modes_explained/control_modes_overview/#direct-voltage-injection-dvi","title":"Direct Voltage Injection (DVI)","text":"<p>Allows manual control of the voltage vector applied to the motor phases. The internal encoder is used to orient the voltage field, enabling precise testing of motor response.</p> <p></p>"},{"location":"control/control_modes_explained/control_modes_parameters/","title":"Which control parameters can be used in each mode?","text":"<p>Not all the available parameters are useful in all the control modes, the following table shows a summary of which control parameters are compatibles with each control mode.</p> <p>Table \u2013 Use of the parameters depending on the control type</p> Parameter Torque control (CtrlType = 5) Speed control (CtrlType = 6) Position control (CtrlType = 7) Impedance control (CtrlType = 8) Calibration (CtrlType = 1) FVI (CtrlType = 2) Open loop (CtrlType = 3) DVI (CtrlType = 4) Torque loop performance Yes Yes Yes Yes No No No No Speed loop performance No Yes Yes No No No No No Kp position No No Yes No No No No No Kp speed No Yes (if custom selected) Yes (if custom selected) No No No No No Ki speed No Yes (if custom selected) Yes (if custom selected) No No No No No Stiffness gain No No No Yes No No No No Damping gain No No No Yes No No No No FF torque No No No Yes No No No No Max positive speed (rad/s) (Profile) No No Yes No No No No No Min negative speed (rad/s) (Profile) No No Yes No No No No No Max acceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max deceleration (rad/s\u00b2) (Profile) No Yes Yes No No No No No Max speed (rad/s) No Yes Yes No No No No No Min speed (rad/s) No Yes Yes No No No No No Max position (rad) No No Yes Yes No No No No Min position (rad) No No Yes Yes No No No No Max absolute torque (Nm) Yes Yes Yes Yes Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus) Yes (for the debug bus)"},{"location":"control/desktop_app/desktop_app/","title":"Pulsar Desktop App","text":"<p>Note</p> <p>Currently the Desktop App works only for Real Actuators, not for Virtual ones</p> <p>The Pulsar Desktop App provides the simplest way to get started with a Pulsar Actuator. It offers a graphical interface (GUI) to configure, control, and monitor the actuator without writing any code.</p> <p>This tool is ideal for: - Quick testing and tuning actuator parameters - Visualizing data such as position, speed, and torque - Running diagnostics without using scripts</p>"},{"location":"control/desktop_app/desktop_app/#system-requirements","title":"\u2699\ufe0f System Requirements","text":"<ul> <li>Connection: The actuator must be powered and connected directly via USB</li> <li>Compatibility: Tested on Windows <p>Linux and macOS support is experimental and currently under review</p> </li> </ul> <p>At this stage, the app supports controlling one actuator at a time.</p>"},{"location":"control/desktop_app/desktop_app/#how-to-get-the-app","title":"\ud83d\udce6 How to Get the App","text":"<p>The app is not yet available as a public download. To request an installer, please contact our team and include: - Your operating system - Your intended use case (optional)</p>"},{"location":"control/desktop_app/desktop_app/#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Browse and connect to available actuators via USB</li> <li>Switch between control modes: Speed, Position, Torque, and Impedance</li> <li>Change control parameters (e.g., position Kp, torque limits)</li> <li>View real-time plots of actuator feedback</li> <li>Run basic motion sequences interactively</li> </ul>"},{"location":"control/desktop_app/desktop_app/#learn-by-doing","title":"\ud83d\udd0d Learn by Doing","text":"<p>To walk through your first experience with the app, check out the Quickstart Guide. It covers: - Powering and connecting your actuator - Using the GUI to change control modes and parameters - Safety tips for live testing - Interacting with the actuator in real-time  </p>"},{"location":"control/desktop_app/desktop_app/#interface-preview","title":"\ud83d\uddbc Interface Preview","text":""},{"location":"control/python_api/class_PCP_over_USB/","title":"PCP_over_USB","text":"<p>PCP (Pulsar Communication Protocol) adapter for USB connections.</p> <p>This class provides USB serial communication for the PCP protocol, sending messages, receiving incoming messages in a thread for asynchronous communication</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>class PCP_over_USB:\n    \"\"\"\n    PCP (Pulsar Communication Protocol) adapter for USB connections.\n\n    This class provides USB serial communication for the PCP protocol, sending messages,\n    receiving incoming messages in a thread for asynchronous communication\n    \"\"\"\n\n    def __init__(self, port: Optional[str] = None, connect_on_init: bool = True, logger: Optional[logging.Logger] = None) -&gt; None:\n        \"\"\"\n        Initialize PCP over USB communication adapter.\n\n        Args:\n            port: Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.\n            connect_on_init: Whether to automatically connect during initialization\n            logger: Optional logger for debugging messages\n        \"\"\"\n        ...\n\n    def connect(self, port: Optional[str] = None) -&gt; bool:\n        \"\"\"\n        Establish a connection to the device.\n\n        Args:\n            port (str, optional): Serial port name. If None, uses previously set port or auto-discovery.\n\n        Returns:\n            bool: True if connection successful, False otherwise\n        \"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnect from the USB serial port and stop background threads.\n\n        Cleanly shuts down the polling thread and closes the serial connection.\n        \"\"\"\n        ...\n\n    def close(self) -&gt; None:\n        \"\"\"\n        Alias for disconnect() method.\n\n        Provided for compatibility and explicit resource cleanup.\n        \"\"\"\n        ...\n\n    def setCallback(self, address: int, callback: Callable[[int, List[int]], None]) -&gt; None:\n        \"\"\"\n        Register a callback function for messages from a specific PCP address.\n\n        Args:\n            address: PCP address to listen for (1-16382)\n            callback: Function to call when messages are received from this address.\n                     Callback signature: callback(address: int, data: List[int])\n        \"\"\"\n        ...\n\n    def send_PCP(self, address: int, data: List[int]) -&gt; bool:\n        \"\"\"\n        Send a PCP message to the specified address.\n\n        Args:\n            address: Target PCP address (1-16382)\n            data: List of bytes to send as message payload\n\n        Returns:\n            True if message was sent successfully, False otherwise\n        \"\"\"\n        ...\n\n    @staticmethod\n    def get_ports() -&gt; List[str]:\n        \"\"\"\n        Get list of available USB serial ports from Pulsar HRI devices.\n\n        Automatically filters serial ports to only include those manufactured\n        by Pulsar HRI, which are compatible with PCP over USB.\n\n        Returns:\n            List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows\n            or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)\n        \"\"\"\n        ...\n\n    @staticmethod\n    def get_port() -&gt; str:\n        \"\"\"\n        Auto-discover a single USB serial port for PCP communication.\n\n        Attempts to automatically find a suitable serial port. If exactly one\n        Pulsar HRI port is found, returns it. Otherwise, returns empty string.\n\n        Returns:\n            Serial port name if exactly one suitable port is found, empty string otherwise\n        \"\"\"\n        ...\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Check if the USB connection is active.\n\n        Returns:\n            True if connected, False otherwise\n        \"\"\"\n        ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if the USB connection is active.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if connected, False otherwise</p>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.__init__","title":"<code>__init__(port=None, connect_on_init=True, logger=None)</code>","text":"<p>Initialize PCP over USB communication adapter.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.</p> <code>None</code> <code>connect_on_init</code> <code>bool</code> <p>Whether to automatically connect during initialization</p> <code>True</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger for debugging messages</p> <code>None</code> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def __init__(self, port: Optional[str] = None, connect_on_init: bool = True, logger: Optional[logging.Logger] = None) -&gt; None:\n    \"\"\"\n    Initialize PCP over USB communication adapter.\n\n    Args:\n        port: Serial port name (e.g., 'COM3', '/dev/ttyACM0'). If None, auto-discovery is attempted.\n        connect_on_init: Whether to automatically connect during initialization\n        logger: Optional logger for debugging messages\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.close","title":"<code>close()</code>","text":"<p>Alias for disconnect() method.</p> <p>Provided for compatibility and explicit resource cleanup.</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Alias for disconnect() method.\n\n    Provided for compatibility and explicit resource cleanup.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.connect","title":"<code>connect(port=None)</code>","text":"<p>Establish a connection to the device.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port name. If None, uses previously set port or auto-discovery.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def connect(self, port: Optional[str] = None) -&gt; bool:\n    \"\"\"\n    Establish a connection to the device.\n\n    Args:\n        port (str, optional): Serial port name. If None, uses previously set port or auto-discovery.\n\n    Returns:\n        bool: True if connection successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the USB serial port and stop background threads.</p> <p>Cleanly shuts down the polling thread and closes the serial connection.</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the USB serial port and stop background threads.\n\n    Cleanly shuts down the polling thread and closes the serial connection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.get_port","title":"<code>get_port()</code>  <code>staticmethod</code>","text":"<p>Auto-discover a single USB serial port for PCP communication.</p> <p>Attempts to automatically find a suitable serial port. If exactly one Pulsar HRI port is found, returns it. Otherwise, returns empty string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Serial port name if exactly one suitable port is found, empty string otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>@staticmethod\ndef get_port() -&gt; str:\n    \"\"\"\n    Auto-discover a single USB serial port for PCP communication.\n\n    Attempts to automatically find a suitable serial port. If exactly one\n    Pulsar HRI port is found, returns it. Otherwise, returns empty string.\n\n    Returns:\n        Serial port name if exactly one suitable port is found, empty string otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.get_ports","title":"<code>get_ports()</code>  <code>staticmethod</code>","text":"<p>Get list of available USB serial ports from Pulsar HRI devices.</p> <p>Automatically filters serial ports to only include those manufactured by Pulsar HRI, which are compatible with PCP over USB.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows</p> <code>List[str]</code> <p>or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>@staticmethod\ndef get_ports() -&gt; List[str]:\n    \"\"\"\n    Get list of available USB serial ports from Pulsar HRI devices.\n\n    Automatically filters serial ports to only include those manufactured\n    by Pulsar HRI, which are compatible with PCP over USB.\n\n    Returns:\n        List of serial port names/paths (e.g., ['COM3', 'COM5'] on Windows\n        or ['/dev/ttyACM0', '/dev/ttyACM1'] on Linux)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.send_PCP","title":"<code>send_PCP(address, data)</code>","text":"<p>Send a PCP message to the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Target PCP address (1-16382)</p> required <code>data</code> <code>List[int]</code> <p>List of bytes to send as message payload</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully, False otherwise</p> Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def send_PCP(self, address: int, data: List[int]) -&gt; bool:\n    \"\"\"\n    Send a PCP message to the specified address.\n\n    Args:\n        address: Target PCP address (1-16382)\n        data: List of bytes to send as message payload\n\n    Returns:\n        True if message was sent successfully, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PCP_over_USB/#pcp_api.pcp_over_usb.PCP_over_USB.setCallback","title":"<code>setCallback(address, callback)</code>","text":"<p>Register a callback function for messages from a specific PCP address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>PCP address to listen for (1-16382)</p> required <code>callback</code> <code>Callable[[int, List[int]], None]</code> <p>Function to call when messages are received from this address.      Callback signature: callback(address: int, data: List[int])</p> required Source code in <code>pcp_api/pcp_over_usb.pyi</code> <pre><code>def setCallback(self, address: int, callback: Callable[[int, List[int]], None]) -&gt; None:\n    \"\"\"\n    Register a callback function for messages from a specific PCP address.\n\n    Args:\n        address: PCP address to listen for (1-16382)\n        callback: Function to call when messages are received from this address.\n                 Callback signature: callback(address: int, data: List[int])\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/","title":"PulsarActuator","text":"<p>Main class for controlling Pulsar actuators via PCP (Pulsar Control Protocol).</p> <p>This class provides high-level methods to control actuator modes, setpoints, feedback configuration, and parameter management.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PulsarActuator:\n    \"\"\"\n    Main class for controlling Pulsar actuators via PCP (Pulsar Control Protocol).\n\n    This class provides high-level methods to control actuator modes, setpoints,\n    feedback configuration, and parameter management.\n    \"\"\"\n\n    class Mode(Enum):\n        \"\"\"Control modes available for the Pulsar actuator.\"\"\"\n        TORQUE = 0x05\n        SPEED = 0x06\n        POSITION = 0x07\n        IMPEDANCE = 0x08\n        # These modes are only for testing purposes\n        FVI = 0x02\n        OPEN_LOOP = 0x03\n        DVI = 0x04         # Field oriented voltage injection\n\n    class Rates(Enum):\n        \"\"\"Feedback update rates for high/low frequency data streams.\"\"\"\n        DISABLED = 0       # Feedback disabled\n        RATE_1KHZ = 10     # 1kHz update rate (1000 Hz)\n        RATE_100HZ = 100\n        RATE_50HZ = 200\n        RATE_10HZ = 1_000\n        RATE_5HZ = 2_000\n        RATE_2HZ = 5_000\n        RATE_1HZ = 10_000\n\n    class TorquePerformance(Enum):\n        \"\"\"Performance settings for torque control mode.\"\"\"\n        AGGRESSIVE = 1     # Fast, responsive torque control\n        BALANCED = 2       # Balanced torque control\n        SOFT = 3          # Smooth, gentle torque control\n\n    class SpeedPerformance(Enum):\n        \"\"\"Performance settings for speed control mode.\"\"\"\n        AGGRESSIVE = 1     # Fast, responsive speed control\n        BALANCED = 2       # Balanced speed control\n        SOFT = 3          # Smooth, gentle speed control\n        CUSTOM = 4        # Custom speed control parameters\n\n    class PCP_Parameters(Enum):\n        \"\"\"Available parameters that can be read/written on the actuator.\"\"\"\n        K_DAMPING = 0x01              # Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control)\n        K_STIFFNESS = 0x02            # Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control)\n        TORQUE_FF = 0x03              # Feedforward Torque Value (Nm)\n        LIM_TORQUE = 0x04             # Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm)\n        LIM_POSITION_MAX = 0x05       # Max. Position Limit (rad)\n        LIM_POSITION_MIN = 0x06       # Min. Position Limit (rad)\n        LIM_SPEED_MAX = 0x07          # Max. Speed Limit (rad/s)\n        LIM_SPEED_MIN = 0x08          # Min. Speed Limit (rad/s)\n        PROFILE_POSITION_MAX = 0x09   # Max. Positive Speed (rad/s) in Position control configuration\n        PROFILE_POSITION_MIN = 0x0A   # Min. Negative Speed (rad/s) in Position control configuration\n        PROFILE_SPEED_MAX = 0x0B      # Max. Acceleration (rad/s^2) in Speed control configuration\n        PROFILE_SPEED_MIN = 0x0C      # Max. Deceleration (rad/s^2) in Speed control configuration\n        KP_SPEED = 0x0D               # Kp speed control constant P value\n        KI_SPEED = 0x0E               # Ki speed control constant I value\n        KP_POSITION = 0x0F            # Kp position control constant P value\n        MODE = 0x30                   # Operation Mode (read-only, must be set via CHANGE_MODE)\n        SETPOINT = 0x31               # Setpoint, Position (rad), Speed (rad/s), Torque (Nm)\n        TORQUE_PERFORMANCE = 0x40     # Torque performance setting\n        SPEED_PERFORMANCE = 0x41      # Speed performance setting\n        PROFILE_SPEED_MAX_RAD_S = 0x42    # Maximum profile speed in rad/s\n        PROFILE_TORQUE_MAX_NM = 0x43      # Maximum profile torque in Nm\n        FIRMWARE_VERSION = 0x80       # Firmware version (read-only)\n        PCP_ADDRESS = 0x81            # device PCP address\n        SERIAL_NUMBER = 0x82          # Device serial number (read-only)\n        DEVICE_MODEL = 0x83           # Device model identifier (read-only)\n        CONTROL_VERSION = 0x84        # Control software version (read-only)\n\n    class PCP_Items(Enum):\n        \"\"\"Feedback items available for monitoring actuator state.\"\"\"\n        ENCODER_INT = 0x41            # Internal encoder position\n        ENCODER_INT_RAW = 0x42        # Raw internal encoder counts\n        ENCODER_EXT = 0x43            # External encoder position\n        ENCODER_EXT_RAW = 0x44        # Raw external encoder counts\n        SPEED_FB = 0x45               # Speed feedback\n        IA = 0x46                     # Phase A current\n        IB = 0x47                     # Phase B current\n        IC = 0x48                     # Phase C current\n        TORQUE_SENS = 0x49            # Torque sensor reading\n        TORQUE_SENS_RAW = 0x4A        # Raw torque sensor reading\n        POSITION_REF = 0x4B           # Position reference/command\n        POSITION_FB = 0x4C            # Position feedback\n        SPEED_REF = 0x4D              # Speed reference/command\n        ID_REF = 0x4F                 # D-axis current reference\n        ID_FB = 0x50                  # D-axis current feedback\n        IQ_REF = 0x51                 # Q-axis current reference\n        IQ_FB = 0x52                  # Q-axis current feedback\n        VD_REF = 0x53                 # D-axis voltage reference\n        VQ_REF = 0x54                 # Q-axis voltage reference\n        TORQUE_REF = 0x55             # Torque reference/command\n        TORQUE_FB = 0x56              # Torque feedback\n        ERRORS_ENCODER_INT = 0x60     # Internal encoder error flags\n        ERRORS_ENCODER_EXT = 0x61     # External encoder error flags\n        ERRORS_OVERRUN = 0x62         # Control loop overrun errors\n        VBUS = 0x70                   # Bus voltage\n        TEMP_PCB = 0x71               # PCB temperature\n        TEMP_MOTOR = 0x72             # Motor temperature\n\n    def __init__(self, adapter_handler: Any, address: int, logger: Optional[logging.Logger] = None) -&gt; None:\n        \"\"\"\n        Initialize a PulsarActuator instance.\n\n        Args:\n            adapter_handler: Communication adapter for PCP protocol\n            address: PCP network address of the actuator (1-16382)\n            logger: Optional logger for debugging messages\n        \"\"\"\n        ...\n\n    def connect(self, timeout: float = 1.0) -&gt; bool:\n        \"\"\"\n        Establish connection to the actuator.\n\n        Args:\n            timeout: Connection timeout in seconds\n\n        Returns:\n            True if connection successful, False otherwise\n        \"\"\"\n        ...\n\n    def set_feedback_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Set callback function to receive feedback data.\n\n        Args:\n            callback: Function to call when feedback data is received\n        \"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the actuator and clean up resources.\"\"\"\n        ...\n\n    def get_feedback(self) -&gt; Dict[Any, Any]:\n        \"\"\"\n        Get the latest feedback data.\n\n        Returns:\n            Dictionary containing latest feedback values\n        \"\"\"\n        ...\n\n    def send_ping(self, timeout: float = 1.0) -&gt; bool:\n        \"\"\"\n        Send ping to verify actuator connectivity.\n\n        Args:\n            timeout: Response timeout in seconds\n\n        Returns:\n            True if ping successful, False otherwise\n        \"\"\"\n        ...\n\n    def changeAddress(self, new_address: int) -&gt; None:\n        \"\"\"\n        Change the PCP address of the actuator.\n\n        Args:\n            new_address: New PCP address (0x10 - 0x3FFE)\n        \"\"\"\n        ...\n\n    def start(self) -&gt; None:\n        \"\"\"Enable the actuator control system.\"\"\"\n        ...\n\n    def stop(self) -&gt; None:\n        \"\"\"Disable the actuator control system.\"\"\"\n        ...\n\n    def change_mode(self, mode: 'PulsarActuator.Mode') -&gt; None:\n        \"\"\"\n        Change the actuator control mode.\n\n        Args:\n            mode (PulsarActuator.Mode): The mode to be set.  (TORQUE, SPEED, POSITION, ...)\n        \"\"\"\n        ...\n\n    def change_setpoint(self, setpoint: float) -&gt; None:\n        \"\"\"\n        Set the control setpoint for the current mode.\n\n        Args:\n            setpoint: Target value (units depend on current mode)\n                     - Torque mode: Nm\n                     - Speed mode: rad/s\n                     - Position mode: rad\n                     - Impedance mode: rad\n        \"\"\"\n        ...\n\n    def save_config(self) -&gt; None:\n        \"\"\"Save current configuration to non-volatile memory.\"\"\"\n        ...\n\n    def setHighFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n        \"\"\"\n        Configure which items to include in high frequency feedback stream.\n\n        Args:\n            items: List of PCP_Items to monitor at high frequency\n        \"\"\"\n        ...\n\n    def setHighFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n        \"\"\"\n        Set the update rate for high frequency feedback.\n\n        Args:\n            rate: Desired update rate from Rates enum\n        \"\"\"\n        ...\n\n    def setLowFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n        \"\"\"\n        Configure which items to include in low frequency feedback stream.\n\n        Args:\n            items: List of PCP_Items to monitor at low frequency\n        \"\"\"\n        ...\n\n    def setLowFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n        \"\"\"\n        Set the update rate for low frequency feedback.\n\n        Args:\n            rate: Desired update rate from Rates enum\n        \"\"\"\n        ...\n\n    def set_home_position(self) -&gt; None:\n        \"\"\"Sets the current position as the home position (zero reference).\"\"\"\n        ...\n\n    def set_parameters(self, parameters: Dict['PulsarActuator.PCP_Parameters', float]) -&gt; None:\n        \"\"\"\n        Set multiple actuator parameters.\n\n        Args:\n            parameters: Dictionary mapping PCP_Parameters to their values\n        \"\"\"\n        ...\n\n    def get_parameters(self, parameters: List['PulsarActuator.PCP_Parameters'], timeout: float = 1.0) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n        \"\"\"\n        Read multiple actuator parameters.\n\n        Args:\n            parameters: List of parameters to read\n            timeout: Response timeout in seconds\n\n        Returns:\n            Dictionary mapping parameters to their current values\n        \"\"\"\n        ...\n\n    def get_parameters_all(self) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n        \"\"\"\n        Read all available actuator parameters.\n\n        Returns:\n            Dictionary containing all parameter values\n        \"\"\"\n        ...\n\n    def set_torque_performance(self, performance: 'PulsarActuator.TorquePerformance') -&gt; None:\n        \"\"\"\n        Set torque control performance level.\n\n        Args:\n            performance: Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)\n        \"\"\"\n        ...\n\n    def set_speed_performance(self, performance: 'PulsarActuator.SpeedPerformance') -&gt; None:\n        \"\"\"\n        Set speed control performance level.\n\n        Args:\n            performance: Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.Mode","title":"<code>Mode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Control modes available for the Pulsar actuator.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class Mode(Enum):\n    \"\"\"Control modes available for the Pulsar actuator.\"\"\"\n    TORQUE = 0x05\n    SPEED = 0x06\n    POSITION = 0x07\n    IMPEDANCE = 0x08\n    # These modes are only for testing purposes\n    FVI = 0x02\n    OPEN_LOOP = 0x03\n    DVI = 0x04         # Field oriented voltage injection\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.PCP_Items","title":"<code>PCP_Items</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Feedback items available for monitoring actuator state.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PCP_Items(Enum):\n    \"\"\"Feedback items available for monitoring actuator state.\"\"\"\n    ENCODER_INT = 0x41            # Internal encoder position\n    ENCODER_INT_RAW = 0x42        # Raw internal encoder counts\n    ENCODER_EXT = 0x43            # External encoder position\n    ENCODER_EXT_RAW = 0x44        # Raw external encoder counts\n    SPEED_FB = 0x45               # Speed feedback\n    IA = 0x46                     # Phase A current\n    IB = 0x47                     # Phase B current\n    IC = 0x48                     # Phase C current\n    TORQUE_SENS = 0x49            # Torque sensor reading\n    TORQUE_SENS_RAW = 0x4A        # Raw torque sensor reading\n    POSITION_REF = 0x4B           # Position reference/command\n    POSITION_FB = 0x4C            # Position feedback\n    SPEED_REF = 0x4D              # Speed reference/command\n    ID_REF = 0x4F                 # D-axis current reference\n    ID_FB = 0x50                  # D-axis current feedback\n    IQ_REF = 0x51                 # Q-axis current reference\n    IQ_FB = 0x52                  # Q-axis current feedback\n    VD_REF = 0x53                 # D-axis voltage reference\n    VQ_REF = 0x54                 # Q-axis voltage reference\n    TORQUE_REF = 0x55             # Torque reference/command\n    TORQUE_FB = 0x56              # Torque feedback\n    ERRORS_ENCODER_INT = 0x60     # Internal encoder error flags\n    ERRORS_ENCODER_EXT = 0x61     # External encoder error flags\n    ERRORS_OVERRUN = 0x62         # Control loop overrun errors\n    VBUS = 0x70                   # Bus voltage\n    TEMP_PCB = 0x71               # PCB temperature\n    TEMP_MOTOR = 0x72             # Motor temperature\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.PCP_Parameters","title":"<code>PCP_Parameters</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Available parameters that can be read/written on the actuator.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class PCP_Parameters(Enum):\n    \"\"\"Available parameters that can be read/written on the actuator.\"\"\"\n    K_DAMPING = 0x01              # Damping coefficient (Nm\u00b7s/rad) for the virtual damper behavior (Impedance Control)\n    K_STIFFNESS = 0x02            # Stiffness coefficient (Nm/rad) for the virtual spring behavior (Impedance Control)\n    TORQUE_FF = 0x03              # Feedforward Torque Value (Nm)\n    LIM_TORQUE = 0x04             # Upper and lower bounds for how much torque can be applied in the positive and negative directions. (Nm)\n    LIM_POSITION_MAX = 0x05       # Max. Position Limit (rad)\n    LIM_POSITION_MIN = 0x06       # Min. Position Limit (rad)\n    LIM_SPEED_MAX = 0x07          # Max. Speed Limit (rad/s)\n    LIM_SPEED_MIN = 0x08          # Min. Speed Limit (rad/s)\n    PROFILE_POSITION_MAX = 0x09   # Max. Positive Speed (rad/s) in Position control configuration\n    PROFILE_POSITION_MIN = 0x0A   # Min. Negative Speed (rad/s) in Position control configuration\n    PROFILE_SPEED_MAX = 0x0B      # Max. Acceleration (rad/s^2) in Speed control configuration\n    PROFILE_SPEED_MIN = 0x0C      # Max. Deceleration (rad/s^2) in Speed control configuration\n    KP_SPEED = 0x0D               # Kp speed control constant P value\n    KI_SPEED = 0x0E               # Ki speed control constant I value\n    KP_POSITION = 0x0F            # Kp position control constant P value\n    MODE = 0x30                   # Operation Mode (read-only, must be set via CHANGE_MODE)\n    SETPOINT = 0x31               # Setpoint, Position (rad), Speed (rad/s), Torque (Nm)\n    TORQUE_PERFORMANCE = 0x40     # Torque performance setting\n    SPEED_PERFORMANCE = 0x41      # Speed performance setting\n    PROFILE_SPEED_MAX_RAD_S = 0x42    # Maximum profile speed in rad/s\n    PROFILE_TORQUE_MAX_NM = 0x43      # Maximum profile torque in Nm\n    FIRMWARE_VERSION = 0x80       # Firmware version (read-only)\n    PCP_ADDRESS = 0x81            # device PCP address\n    SERIAL_NUMBER = 0x82          # Device serial number (read-only)\n    DEVICE_MODEL = 0x83           # Device model identifier (read-only)\n    CONTROL_VERSION = 0x84        # Control software version (read-only)\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.Rates","title":"<code>Rates</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Feedback update rates for high/low frequency data streams.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class Rates(Enum):\n    \"\"\"Feedback update rates for high/low frequency data streams.\"\"\"\n    DISABLED = 0       # Feedback disabled\n    RATE_1KHZ = 10     # 1kHz update rate (1000 Hz)\n    RATE_100HZ = 100\n    RATE_50HZ = 200\n    RATE_10HZ = 1_000\n    RATE_5HZ = 2_000\n    RATE_2HZ = 5_000\n    RATE_1HZ = 10_000\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.SpeedPerformance","title":"<code>SpeedPerformance</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Performance settings for speed control mode.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class SpeedPerformance(Enum):\n    \"\"\"Performance settings for speed control mode.\"\"\"\n    AGGRESSIVE = 1     # Fast, responsive speed control\n    BALANCED = 2       # Balanced speed control\n    SOFT = 3          # Smooth, gentle speed control\n    CUSTOM = 4        # Custom speed control parameters\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.TorquePerformance","title":"<code>TorquePerformance</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Performance settings for torque control mode.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>class TorquePerformance(Enum):\n    \"\"\"Performance settings for torque control mode.\"\"\"\n    AGGRESSIVE = 1     # Fast, responsive torque control\n    BALANCED = 2       # Balanced torque control\n    SOFT = 3          # Smooth, gentle torque control\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.__init__","title":"<code>__init__(adapter_handler, address, logger=None)</code>","text":"<p>Initialize a PulsarActuator instance.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_handler</code> <code>Any</code> <p>Communication adapter for PCP protocol</p> required <code>address</code> <code>int</code> <p>PCP network address of the actuator (1-16382)</p> required <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger for debugging messages</p> <code>None</code> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def __init__(self, adapter_handler: Any, address: int, logger: Optional[logging.Logger] = None) -&gt; None:\n    \"\"\"\n    Initialize a PulsarActuator instance.\n\n    Args:\n        adapter_handler: Communication adapter for PCP protocol\n        address: PCP network address of the actuator (1-16382)\n        logger: Optional logger for debugging messages\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.changeAddress","title":"<code>changeAddress(new_address)</code>","text":"<p>Change the PCP address of the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>new_address</code> <code>int</code> <p>New PCP address (0x10 - 0x3FFE)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def changeAddress(self, new_address: int) -&gt; None:\n    \"\"\"\n    Change the PCP address of the actuator.\n\n    Args:\n        new_address: New PCP address (0x10 - 0x3FFE)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.change_mode","title":"<code>change_mode(mode)</code>","text":"<p>Change the actuator control mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Mode</code> <p>The mode to be set.  (TORQUE, SPEED, POSITION, ...)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def change_mode(self, mode: 'PulsarActuator.Mode') -&gt; None:\n    \"\"\"\n    Change the actuator control mode.\n\n    Args:\n        mode (PulsarActuator.Mode): The mode to be set.  (TORQUE, SPEED, POSITION, ...)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.change_setpoint","title":"<code>change_setpoint(setpoint)</code>","text":"<p>Set the control setpoint for the current mode.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>float</code> <p>Target value (units depend on current mode)      - Torque mode: Nm      - Speed mode: rad/s      - Position mode: rad      - Impedance mode: rad</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def change_setpoint(self, setpoint: float) -&gt; None:\n    \"\"\"\n    Set the control setpoint for the current mode.\n\n    Args:\n        setpoint: Target value (units depend on current mode)\n                 - Torque mode: Nm\n                 - Speed mode: rad/s\n                 - Position mode: rad\n                 - Impedance mode: rad\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.connect","title":"<code>connect(timeout=1.0)</code>","text":"<p>Establish connection to the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Connection timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def connect(self, timeout: float = 1.0) -&gt; bool:\n    \"\"\"\n    Establish connection to the actuator.\n\n    Args:\n        timeout: Connection timeout in seconds\n\n    Returns:\n        True if connection successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the actuator and clean up resources.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the actuator and clean up resources.\"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_feedback","title":"<code>get_feedback()</code>","text":"<p>Get the latest feedback data.</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dictionary containing latest feedback values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_feedback(self) -&gt; Dict[Any, Any]:\n    \"\"\"\n    Get the latest feedback data.\n\n    Returns:\n        Dictionary containing latest feedback values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_parameters","title":"<code>get_parameters(parameters, timeout=1.0)</code>","text":"<p>Read multiple actuator parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>List[PCP_Parameters]</code> <p>List of parameters to read</p> required <code>timeout</code> <code>float</code> <p>Response timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Dict[PCP_Parameters, float]</code> <p>Dictionary mapping parameters to their current values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_parameters(self, parameters: List['PulsarActuator.PCP_Parameters'], timeout: float = 1.0) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n    \"\"\"\n    Read multiple actuator parameters.\n\n    Args:\n        parameters: List of parameters to read\n        timeout: Response timeout in seconds\n\n    Returns:\n        Dictionary mapping parameters to their current values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.get_parameters_all","title":"<code>get_parameters_all()</code>","text":"<p>Read all available actuator parameters.</p> <p>Returns:</p> Type Description <code>Dict[PCP_Parameters, float]</code> <p>Dictionary containing all parameter values</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def get_parameters_all(self) -&gt; Dict['PulsarActuator.PCP_Parameters', float]:\n    \"\"\"\n    Read all available actuator parameters.\n\n    Returns:\n        Dictionary containing all parameter values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.save_config","title":"<code>save_config()</code>","text":"<p>Save current configuration to non-volatile memory.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def save_config(self) -&gt; None:\n    \"\"\"Save current configuration to non-volatile memory.\"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.send_ping","title":"<code>send_ping(timeout=1.0)</code>","text":"<p>Send ping to verify actuator connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Response timeout in seconds</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ping successful, False otherwise</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def send_ping(self, timeout: float = 1.0) -&gt; bool:\n    \"\"\"\n    Send ping to verify actuator connectivity.\n\n    Args:\n        timeout: Response timeout in seconds\n\n    Returns:\n        True if ping successful, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setHighFreqFeedbackItems","title":"<code>setHighFreqFeedbackItems(items)</code>","text":"<p>Configure which items to include in high frequency feedback stream.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[PCP_Items]</code> <p>List of PCP_Items to monitor at high frequency</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setHighFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n    \"\"\"\n    Configure which items to include in high frequency feedback stream.\n\n    Args:\n        items: List of PCP_Items to monitor at high frequency\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setHighFreqFeedbackRate","title":"<code>setHighFreqFeedbackRate(rate)</code>","text":"<p>Set the update rate for high frequency feedback.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Rates</code> <p>Desired update rate from Rates enum</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setHighFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n    \"\"\"\n    Set the update rate for high frequency feedback.\n\n    Args:\n        rate: Desired update rate from Rates enum\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setLowFreqFeedbackItems","title":"<code>setLowFreqFeedbackItems(items)</code>","text":"<p>Configure which items to include in low frequency feedback stream.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[PCP_Items]</code> <p>List of PCP_Items to monitor at low frequency</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setLowFreqFeedbackItems(self, items: List['PulsarActuator.PCP_Items']) -&gt; None:\n    \"\"\"\n    Configure which items to include in low frequency feedback stream.\n\n    Args:\n        items: List of PCP_Items to monitor at low frequency\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.setLowFreqFeedbackRate","title":"<code>setLowFreqFeedbackRate(rate)</code>","text":"<p>Set the update rate for low frequency feedback.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Rates</code> <p>Desired update rate from Rates enum</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def setLowFreqFeedbackRate(self, rate: 'PulsarActuator.Rates') -&gt; None:\n    \"\"\"\n    Set the update rate for low frequency feedback.\n\n    Args:\n        rate: Desired update rate from Rates enum\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_feedback_callback","title":"<code>set_feedback_callback(callback)</code>","text":"<p>Set callback function to receive feedback data.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to call when feedback data is received</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_feedback_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Set callback function to receive feedback data.\n\n    Args:\n        callback: Function to call when feedback data is received\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_home_position","title":"<code>set_home_position()</code>","text":"<p>Sets the current position as the home position (zero reference).</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_home_position(self) -&gt; None:\n    \"\"\"Sets the current position as the home position (zero reference).\"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_parameters","title":"<code>set_parameters(parameters)</code>","text":"<p>Set multiple actuator parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[PCP_Parameters, float]</code> <p>Dictionary mapping PCP_Parameters to their values</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_parameters(self, parameters: Dict['PulsarActuator.PCP_Parameters', float]) -&gt; None:\n    \"\"\"\n    Set multiple actuator parameters.\n\n    Args:\n        parameters: Dictionary mapping PCP_Parameters to their values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_speed_performance","title":"<code>set_speed_performance(performance)</code>","text":"<p>Set speed control performance level.</p> <p>Parameters:</p> Name Type Description Default <code>performance</code> <code>SpeedPerformance</code> <p>Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_speed_performance(self, performance: 'PulsarActuator.SpeedPerformance') -&gt; None:\n    \"\"\"\n    Set speed control performance level.\n\n    Args:\n        performance: Desired performance setting (AGGRESSIVE, BALANCED, SOFT, or CUSTOM)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.set_torque_performance","title":"<code>set_torque_performance(performance)</code>","text":"<p>Set torque control performance level.</p> <p>Parameters:</p> Name Type Description Default <code>performance</code> <code>TorquePerformance</code> <p>Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)</p> required Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def set_torque_performance(self, performance: 'PulsarActuator.TorquePerformance') -&gt; None:\n    \"\"\"\n    Set torque control performance level.\n\n    Args:\n        performance: Desired performance setting (AGGRESSIVE, BALANCED, or SOFT)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.start","title":"<code>start()</code>","text":"<p>Enable the actuator control system.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Enable the actuator control system.\"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/class_PulsarActuator/#pcp_api.pulsar_actuator.PulsarActuator.stop","title":"<code>stop()</code>","text":"<p>Disable the actuator control system.</p> Source code in <code>pcp_api/pulsar_actuator.pyi</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Disable the actuator control system.\"\"\"\n    ...\n</code></pre>"},{"location":"control/python_api/cli/","title":"Command line interface (CLI)","text":"<p>The Command Line Interface (CLI) is included in the python package. It provides a convenient way to interact with the actuator directly from a terminal. This is particularly useful for quick communication test and for scanning devices on a CAN bus.</p>"},{"location":"control/python_api/cli/#verifying-the-installation","title":"Verifying the Installation","text":"<p>The CLI is installed along the python package. To confirm that the CLI is working correctly, you can run the following command:</p> <p><pre><code>pulsar-cli -h\n</code></pre> This should print the help message.</p>"},{"location":"control/python_api/cli/#using-the-cli","title":"Using the CLI","text":"<p>The CLI provides several commands to interact with the Pulsar actuator. Here are some common commands:</p>"},{"location":"control/python_api/cli/#scan-for-devices","title":"Scan for Devices","text":"<p><pre><code>pulsar-cli scan\n</code></pre> This command scans the CAN bus for connected Pulsar devices and lists their addresses. You need a CAN adapter connected and a correctly wired CAN bus. Use the <code>-h</code> flag to see more options.</p>"},{"location":"control/python_api/cli/#get-device-parameters","title":"Get Device parameters","text":"<p><pre><code>pulsar-cli params\n</code></pre> You can retrieve all the parameters of the connected device.  Use the <code>-h</code> flag to see more options.</p>"},{"location":"control/python_api/example_advanced_features/","title":"Advanced Features","text":"<p>These code snippets demonstrate more advanced configuration and control of a PULSAR HRI actuator. It builds upon the basic example so you can upgrade it by adding these features.</p> <p>In this document you will learn how to:</p> <ul> <li>\ud83c\udd94 Change the actuator's PCP address</li> <li>\u2699\ufe0f Tune performance profiles (torque and speed)</li> <li>\ud83c\udf9b\ufe0f Set custom control parameters (e.g., stiffness and damping)</li> <li>\ud83d\udcbe Optionally save configuration to persistent memory</li> </ul>"},{"location":"control/python_api/example_advanced_features/#changes-the-actuators-address","title":"Changes the actuator's address","text":"<p>Sets a new address. This gets stored in the actuator's persistent memory, so it will be retained across power cycles. For actuators we recommend to use addresses from 0x10 (16) Lower addresses are reserved for adapters and special purposes.</p> <pre><code>actuator.changeAddress(0x15)\n</code></pre>"},{"location":"control/python_api/example_advanced_features/#change-performance-profiles-for-torque-and-speed","title":"Change performance profiles for torque and speed","text":"<p>The available performance profiles are defined in the <code>PulsarActuator.TorquePerformance</code> and <code>PulsarActuator.SpeedPerformance</code></p> <pre><code>actuator.set_torque_performance(PulsarActuator.TorquePerformance.AGGRESSIVE)\nactuator.set_speed_performance(PulsarActuator.SpeedPerformance.BALANCED)\n</code></pre>"},{"location":"control/python_api/example_advanced_features/#sets-custom-control-parameters","title":"Sets custom control parameters","text":"<p>The available parameters are defined in the <code>PulsarActuator.PCP_Parameters</code>. Note that the <code>set_parameters</code> method takes a dictionary, where the keys are the parameter names and the values are the desired settings.</p> <pre><code>actuator.set_parameters({\n    PulsarActuator.PCP_Parameters.K_DAMPING: 7.7,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS: 8.8,\n})\n</code></pre>"},{"location":"control/python_api/example_advanced_features/#read-back-parameters","title":"Read back parameters","text":"<p>This will read back the current configuration from the actuator. In this case, the <code>get_parameters</code> method takes a list of parameters instead of a dictionary. You can also use <code>get_parameters_all()</code> to read all parameters at once.</p> <pre><code>params = actuator.get_parameters([\n    PulsarActuator.PCP_Parameters.MODE,\n    PulsarActuator.PCP_Parameters.SETPOINT,\n    PulsarActuator.PCP_Parameters.K_STIFFNESS,\n])\n# params = actuator.get_parameters_all()\nprint(params)\nprint(params[PulsarActuator.PCP_Parameters.K_STIFFNESS])\n</code></pre>"},{"location":"control/python_api/example_advanced_features/#saves-the-configuration-to-persistent-memory","title":"Saves the configuration to persistent memory","text":"<p>This will save the current parameters to the actuator's persistent memory, so it will be retained across power cycles.</p> <pre><code>actuator.save_config()\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/","title":"Log Data to CSV","text":"<p>This script is an example of how to log data from a PULSAR HRI actuator. It doesn't show live data, but instead logs it to a CSV file for later analysis. The full example is at the bottom of the page.</p>"},{"location":"control/python_api/example_log_to_csv/#common-code","title":"Common code","text":"<p>Most of the code is common to all examples, so we will not explain it here. You can find the common code in the first example.</p>"},{"location":"control/python_api/example_log_to_csv/#select-the-items-to-log","title":"Select the items to log","text":"<p>You can put the items to log from the actuator in a list. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>POSITION_FB</code>, <code>TORQUE_SENS</code>, <code>SPEED_FB</code>, ... In this example, we will log the current in the three phases of the motor, which are <code>IA</code>, <code>IB</code>, and <code>IC</code>. </p> <pre><code>itemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#preparing-csv-logging","title":"Preparing CSV Logging","text":"<p>This opens a CSV file for writing. The key thing is to order the items in the same way they will be logged. As the items are defined in an enum, you can sort them by name to ensure a consistent order.</p> <pre><code>file = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n# add header\nheader = [\"Timestamp\"]\nheader.extend(sorted([item.name for item in itemsToLog]))  # sorted by name for consistent order\ncsv_writer.writerow(header)\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#callback-function-for-feedback","title":"Callback function for feedback","text":"<p>The callback function, instead of showing the feedback in real-time, like the other examples, it directly logs the data into a file, which allows for higher rates. The feedback data is a dictionary, where the keys are <code>PulsarActuator.PCP_Items</code> and the values are the corresponding values. Again, we sort the keys by name to ensure a consistent order in the CSV file.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#configuration-of-the-feedback-rates","title":"Configuration of the Feedback Rates","text":"<p>We are going to use only high-frequency feedback at 1kHz.</p> <pre><code>actuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#start-actuator","title":"Start Actuator","text":"<p>Like in the other examples, we can choose the control mode, setpoint, other parameters (not shown here) and start the actuator. In this example, we are going to let it spin in SPEED mode for 3 seconds.</p> <pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)  # rad/s\nactuator.start()\nactuator.set_feedback_callback(actuator_feedback)\nsleep(3)  # actuator_feedback() should be triggered during this time\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#run-and-cleanup","title":"Run and Cleanup","text":"<p>Make sure to close the file, stop the actuator and  close the adapter at the end. </p> <pre><code>actuator.disconnect()  # also stops the actuator\nadapter.close()\nfile.close()\n</code></pre>"},{"location":"control/python_api/example_log_to_csv/#example-output","title":"Example output","text":"<p>This code will generate a CSV file named <code>log.csv</code> with the logged data. The first column is the timestamp, and the subsequent columns are the values of the items you logged. The output will look like this:</p> Timestamp IA IB IC 1642780800.123 0.15 -0.08 0.12 1642780800.124 0.16 -0.09 0.13 1642780800.125 0.17 -0.10 0.14"},{"location":"control/python_api/example_log_to_csv/#full-example","title":"Full Example","text":"Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep, time\nimport csv\n\n\nitemsToLog = [\n        PulsarActuator.PCP_Items.IA,\n        PulsarActuator.PCP_Items.IB,\n        PulsarActuator.PCP_Items.IC,\n        # add more items to log\n    ]\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, 0)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\nactuator.setHighFreqFeedbackItems(itemsToLog)\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_1KHZ)\nactuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\nfile = open(\"log.csv\", \"w\")\ncsv_writer = csv.writer(file, lineterminator='\\n')\n\n# add header\nheader = [\"Timestamp\"]\nheader.extend(sorted([item.name for item in itemsToLog])) # sorted by name for consistent order\ncsv_writer.writerow(header)\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    line = [time()]  # timestamp\n    line.extend([feedback[k] for k in sorted(feedback.keys(), key=lambda x: x.name)])  # sorted by enum name for consistent order\n    csv_writer.writerow(line)\n\n\ntry:\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n    actuator.start()\n    actuator.set_feedback_callback(actuator_feedback)    \n    sleep(3)  # actuator_feedback() should be triggered during this time\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n    file.close()\n</code></pre>"},{"location":"control/python_api/example_several_actuators/","title":"Controlling Several Real Actuators","text":"<p>This example demonstrates how to control multiple PULSAR HRI actuators. We will walk through the steps of connecting to the CAN to USB adapter, initializing two actuators, configuring their feedback settings, assigning different speed setpoints, and running them simultaneously.</p> <p>The physical connection for this example (two actuators and the CAN to USB adapter) is shown in the image below. The actuators are connected to the CAN bus via an adapter, which is connected to the host computer via USB.</p> <p></p> <p>Warning</p> <p>Do not forget the termination resistors (TR) at the ends of the CAN bus.</p> <p>The schema shows actuators with addresses 0x10 and 0x11, but you need to find out the actual addresses of your devices. For that you can either use the CLI scan command or use the Desktop App to change their address.</p>"},{"location":"control/python_api/example_several_actuators/#import-necessary-modules","title":"Import necessary modules","text":"<p>We import the necessary modules.</p> <pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>We are going to create a list with all the actuators we want to control, and instantiate a single adapter for all of them. If only one adapter is connected to the computer, you can use the <code>get_port()</code> method to automatically detect the USB port. You can also specify the port manually (e.g., \"COM1\" on Windows or \"/dev/ttyACM0\" on Linux).</p> <pre><code>ACTUATOR_ADDRESSES = [0x10, 0x11]  # Use the actual addresses of your actuators\n\n# Auto-detect CAN to USB adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#define-a-feedback-callback-function","title":"Define a feedback callback function","text":"<p>This function is called automatically whenever feedback is received from any actuator. You can define individual functions for each actuator, or use a single function for all actuators. In this example, we are going to extract the position from the feedback dict, and prints it along with the actuator's address.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#initialize-actuators-and-set-common-configuration","title":"Initialize Actuators and set common configuration","text":"<p>We create a loop to initialize each actuator using its address. Each actuator is connected, configured for high-frequency feedback, and set to SPEED mode. The same feedback callback function is registered to handle incoming feedback from the actuators. (Individual callback functions are also possible)</p> <pre><code>actuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n        # Add other items if needed\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    # Add the actuator to the list\n    actuators.append(actuator)\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#individual-actuator-configuration","title":"Individual Actuator Configuration","text":"<p>We assign different configuration to each actuator. In this case, only the speed setpoint.</p> <pre><code># Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)  # rad/s\nactuators[1].change_setpoint(0.3)  # rad/s\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#run-and-cleanup","title":"Run and Cleanup","text":"<p>We start all actuators and let them run. The feedback will be printed in the console. When the program is interrupted (e.g., via Ctrl+C ), we ensure all actuators are properly disconnected and the adapter is closed.</p> <pre><code># Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    while True:\n        sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"control/python_api/example_several_actuators/#full-code","title":"Full code","text":"Full code<pre><code>from pcp_api import  PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n# Example PCP addresses for two actuators\nACTUATOR_ADDRESSES = [0x10, 0x11]\n\ndef actuator_feedback(address: int, feedback: dict):\n    position = feedback.get(PulsarActuator.PCP_Items.POSITION_FB, None)\n    print(f\"Actuator 0x{address:X} position: {position:.2f} rad/s\")\n\n# Auto-detect CAN to USB adapter port\nport = PCP_over_USB.get_port()\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n\nactuators = []  # list to hold actuator instances\n\nfor address in ACTUATOR_ADDRESSES:\n    # Create a PulsarActuator instance.\n    actuator = PulsarActuator(adapter, address)\n\n    # Attempt to connect to the actuator.\n    if not actuator.connect():\n        print(f\"Could not connect to the actuator {actuator.address}\")\n        adapter.close()\n        raise SystemExit(1)\n\n    print(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n\n    # Configure high-frequency feedback to report position at 10 Hz.\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.POSITION_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n    # Disable low-frequency feedback.\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    # Set the actuator to SPEED mode.\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n\n    # Register the feedback callback function.\n    actuator.set_feedback_callback(actuator_feedback)\n\n    actuators.append(actuator)\n\n# Set different speeds for each actuator\nactuators[0].change_setpoint(0.2)  # rad/s\nactuators[1].change_setpoint(0.3)  # rad/s\n\n# Start all actuators\nfor actuator in actuators:\n    actuator.start()\n\nprint(\"Actuators started. Press Ctrl+C to stop.\")\ntry:\n    while True:\n        sleep(0.1)  # Let feedback trigger\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    for actuator in actuators:\n        actuator.disconnect()\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"control/python_api/example_single_actuator/","title":"Controlling One Real Actuator","text":"<p>Learn how to control a Pulsar actuator through a step-by-step walkthrough covering connection setup, configuration, and basic motion control. The full example is at the bottom of the page.</p>"},{"location":"control/python_api/example_single_actuator/#import-necessary-modules","title":"Import necessary modules","text":"<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n</code></pre>"},{"location":"control/python_api/example_single_actuator/#instantiate-the-adapter","title":"Instantiate the adapter","text":"<p>Pulsar devices understand the PCP protocol, which can be transmitted over USB or CAN. The devices have a built-in USB interface, so you can connect directly to the actuator via USB. Alternatively, you can use a CAN to USB adapter to connect to the actuator over a CAN bus. This adapter is connected to the host computer via USB, so in both cases, you will use the <code>PCP_over_USB</code> class to create the adapter.</p> <pre><code>port = \"COM1\"  # you need to specify the port of the device or the CAN to USB adapter\n# port = PCP_over_USB.get_port()  # there is also an auto-detect system that will find the first available port\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\n</code></pre>"},{"location":"control/python_api/example_single_actuator/#instantiate-the-actuator","title":"Instantiate the actuator","text":"<p>You can instantiate as many actuators as you want with the same CAN adapter. In this example we are going to control only one actuator, connected directly via USB. If you are using a CAN adapter, you need to specify the PCP address of the actuator. The PCP address must be unique for each actuator. You can find this address with the  CLI scan command. If you are connecting directly via USB, use <code>0</code> as the address.</p> <pre><code>ACTUATOR_ADDRESS = 0  # 0 for direct USB connection, or use the actuator address if using CAN adapter\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\nactuator.connect()\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\n</code></pre>"},{"location":"control/python_api/example_single_actuator/#configure-feedback","title":"Configure feedback","text":"<p>First, define a function to handle the feedback from the actuator. This function will be called whenever new feedback is received from the actuator.</p> <pre><code>def actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n</code></pre> <p>Set up the feedback configuration:</p> <ul> <li>High-frequency feedback for data like speed, position, torque, ...</li> <li>Low-frequency feedback for data like bus voltage, temperatures....</li> </ul> <p>You can set the feedback items you want to receive. The items are defined in <code>PulsarActuator.PCP_Items</code>. You can choose from items like <code>SPEED_FB</code>, <code>POSITION_FB</code>, <code>TORQUE_FB</code>, <code>VBUS</code>, <code>TEMP_MOTOR</code>, etc.</p> <p>You can set the feedback rate for each type of feedback. The rates are defined in <code>PulsarActuator.Rates</code>, and you can choose from <code>RATE_1HZ</code>, <code>RATE_10HZ</code>, <code>RATE_100HZ</code>, <code>RATE_1KHZ</code>, or <code>DISABLED</code> to disable the feedback.</p> Configure feedback and control settings<pre><code>actuator.setHighFreqFeedbackItems([\n    PulsarActuator.PCP_Items.SPEED_FB,\n    PulsarActuator.PCP_Items.POSITION_FB,\n    PulsarActuator.PCP_Items.TORQUE_FB,\n    # You can add more items as needed\n])\nactuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n\n# Low-frequency feedback includes bus voltage and motor temperature.\nactuator.setLowFreqFeedbackItems([\n    PulsarActuator.PCP_Items.VBUS,\n    PulsarActuator.PCP_Items.TEMP_MOTOR,\n])\nactuator.setLowFreqFeedbackRate(actuator.Rates.RATE_1HZ)\n\n# Set the feedback callback function to handle the feedback data\nactuator.set_feedback_callback(actuator_feedback)\n\n# feedback_callback can be set to None to disable it\n# and read the feedback manually with actuator.get_feedback()\n</code></pre> <p>As an alternative, do not set a callback function or call <code>actuator.set_feedback_callback(None)</code> and read the feedback manually using <code>feedback = actuator.get_feedback()</code>, but using a callback function is more efficient and allows you to process the feedback in real-time.</p>"},{"location":"control/python_api/example_single_actuator/#configure-control-settings","title":"Configure control settings","text":"<p>You can choose from different control modes, such as <code>SPEED</code>, <code>POSITION</code>, or <code>TORQUE</code>. These are defined in <code>PulsarActuator.Mode</code> In this example, we will use the speed mode. You can now set the setpoint for the actuator, which is the target speed in this case. The units are in SI (International System of Units), so the speed is in radians per second (rad/s), position in radians, and torque in Newton-meters (Nm).</p> SpeedTorquePosition Configure control speed<pre><code>actuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)  # rad/s\n</code></pre> Configure control torque<pre><code>actuator.change_mode(PulsarActuator.Mode.TORQUE)\nactuator.change_setpoint(2.0)  # Nm\n</code></pre> Configure control position<pre><code>actuator.change_mode(PulsarActuator.Mode.POSITION)\nactuator.set_home_position()  # Sets the current position as the zero reference\nactuator.change_setpoint(3.1416)  # (rad) target position at about 180 degrees from home \n</code></pre>"},{"location":"control/python_api/example_single_actuator/#start-the-actuator","title":"Start the actuator","text":"<p>You can start the actuator with the current configuration with the <code>start()</code> method. This will begin the control loop and the actuator will start following the setpoint you defined. The feedback will be received at the rates you configured earlier. It's advisable to put these logic in a try-except block to ensure the actuator is properly disconnected and the adapter is closed when the program is interrupted (e.g., via Ctrl+C)</p> Shutdown<pre><code>try:\n    # Put the configuration and control code here\n    actuator.start()\n    # The loop will keep running until interrupted (e.g., via Ctrl+C).\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # will also stop the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"control/python_api/example_single_actuator/#full-example","title":"Full Example","text":"SpeedTorquePosition Full code Speed<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    actuator.change_mode(PulsarActuator.Mode.SPEED)\n    actuator.change_setpoint(1.0)  # rad/s\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre> Full code Torque<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n    actuator.setLowFreqFeedbackRate(actuator.Rates.DISABLED)\n\n    actuator.change_mode(PulsarActuator.Mode.TORQUE)\n    actuator.change_setpoint(2.0)  # Nm\n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre> Full code Position<pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n\nACTUATOR_ADDRESS = 0  # 0 to indicate direct USB connection, or use the PCP address if using CAN adapter\n\n\ndef actuator_feedback(address: int, feedback: dict):\n    print(feedback)\n    speed_fb = feedback.get(PulsarActuator.PCP_Items.SPEED_FB, None)\n    if speed_fb is not None:\n        print(f\"Actuator 0x{address:X} Speed feedback: {speed_fb:.2f} rad/s\")\n\n\nport = PCP_over_USB.get_port()  # auto-detect\n# port = \"COM1\"\nprint(f\"Connecting to {port}\")\nadapter = PCP_over_USB(port)\nactuator = PulsarActuator(adapter, ACTUATOR_ADDRESS)\n\nif not actuator.connect():\n    print(f\"Could not connect to the actuator {actuator.address}\")\n    adapter.close()\n    exit(1)\nprint(f\"Connected to the actuator {actuator.address} (model: {actuator.model}, firmware: {actuator.firmware_version})\")\ntry:\n    actuator.setHighFreqFeedbackItems([\n        PulsarActuator.PCP_Items.SPEED_FB,\n        PulsarActuator.PCP_Items.POSITION_FB,\n        PulsarActuator.PCP_Items.TORQUE_FB,\n    ])\n    actuator.setHighFreqFeedbackRate(actuator.Rates.RATE_10HZ)\n    actuator.set_feedback_callback(actuator_feedback)\n    # feedback_callback can be set to None to disable it\n    # and read the feedback manually with actuator.get_feedback()\n\n    actuator.setLowFreqFeedbackItems([\n        PulsarActuator.PCP_Items.VBUS,\n        PulsarActuator.PCP_Items.TEMP_MOTOR,\n    ])\n\n    actuator.change_mode(PulsarActuator.Mode.POSITION)\n    actuator.set_home_position()  # Sets the current position as the zero reference\n    actuator.change_setpoint(3.1416)  # (rad) target position at about 180 degrees from home \n\n    actuator.start()\n    print(\"Actuator started. Press Ctrl+C to stop.\")\n    while True:\n        sleep(0.1)  # actuator_feedback() should be triggered\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    actuator.disconnect()  # also stops the actuator\n    sleep(0.1)\n    adapter.close()\n</code></pre>"},{"location":"control/python_api/install_python_api/","title":"Install Python API","text":"<p>In this document we will guide you through the installation of the PULSAR HRI Python API, which allows you to programmatically control and interact with PULSAR actuators.</p>"},{"location":"control/python_api/install_python_api/#installation","title":"Installation","text":"<p>You can use a virtual environment to install this and other packages for your project. There are several ways to create a virtual environments. In this guide, we will skip the virtual environment and install the PULSAR HRI Python API globally.</p> <pre><code>pip install --upgrade pcp_api\n</code></pre>"},{"location":"control/python_api/install_python_api/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To confirm that the installation was successful, you can run the following command:</p> <p><pre><code>pip show pcp_api\n</code></pre> This should provide information about the installed package, including its version and location. If you see this information, the installation was successful.</p>"},{"location":"control/python_api/install_python_api/#next-steps","title":"Next Steps","text":"<p>Once the API is installed, you can:</p> <ul> <li>Use the Command line interface to quickly interact with the PULSAR hardware.</li> <li>Run the example scripts</li> <li>Explore the code documentation for detailed usage instructions.</li> <li>Integrate the API into your own applications or research workflows.</li> </ul> <p>If you encounter any issues, please open an issue issue.</p>"},{"location":"download/download_app/","title":"Download Desktop App","text":"WindowsLinux <p>Download PulsarApp-0.9.1.zip</p> <p>Download PulsarApp-0.9.1.deb</p> <p>The Desktop App used in the Quickstart No-Code guide.</p>"},{"location":"download/download_dtwin/","title":"Download AUGUR Digital Twin","text":"<p>In this page you can find the AUGUR Digital Twin library files to set up PULSAR HRI Virtual Actuators</p> <p>Coming soon.. contact our team for more info</p>"},{"location":"quickstarts/quickstart_desktop_app/","title":"Quickstart Tutorial: No-Code Desktop App for Real Actuator","text":"<p>This page walks you through running a Real Actuator connected via USB without needing to do any coding, using the PULSAR HRI Desktop App.</p>"},{"location":"quickstarts/quickstart_desktop_app/#step-by-step-guide","title":"\ud83d\udc63 Step-By-Step Guide","text":"<ol> <li> <p>Make sure your actuator is set up and connected via USB, as per the Quickstart Tutorial: Set up Real Actuator and connect via USB </p> </li> <li> <p>Launch the PULSAR Desktop App: you should be able to see the actuator connected via USB in the \"Devices\" dropdown. Upon selecting it, a popup will inform you of the successful connection and the actuator's address will be shown </p> <p>the Actuator Address is useful for example to connect via CAN Bus instead of USB, but this will be covered in another guide</p> <p> </p> <p>Warning</p> <p>You successfully connected to the actuator, which is now ready to move, that's great!! But, as they say, with great power come great responsibilities:  be mindful to keep the actuator's operating area clear of any object that might get caught or collide with any moving parts.</p> </li> <li> <p>As a first example, we'll run the actuator in Speed Control mode: </p> <ul> <li>select Speed Control mode under Control Type</li> <li>check that the setpoint in rad/s is currently zero</li> <li>hit the play button: the actuator won't move as you're telling it to move at zero speed.  </li> <li>you can now change the setpoint speed either by typing the desired rad/s value in the textbox, or by moving the slider</li> <li>you'll see the actuator moving and the live plot of the position at the bottom of the GUI being updated accordingly</li> </ul> </li> <li> <p>We can now move to try Position Control mode:</p> <ul> <li>select Positon Control mode under Control Type</li> <li>click on the SET 0 POSITION button, this will store the current position (output angle) of the actuator as the zero. <ul> <li>If you skip setting the zero position, it will use the latest zero position that was set and written to memory  </li> </ul> </li> <li>hit the play button: the actuator won't move as you're telling it to hold the zero position you just set. </li> <li>you can now change the setpoint position either by typing the desired rad value in the textbox, or by moving the slider</li> <li>you'll see the actuator moving and the live plot of the position at the bottom of the GUI being updated accordingly</li> </ul> </li> <li> <p>You can now try changing the values of actuator limits and of the control parameters associated to different available Actuator Control Modes</p> <ul> <li>Continuing from the previous point we can try changing the control parameter associated to Position control, Position Kp<ul> <li>increasing this parameter essentially makes the actuator more responsive but, if set too high, it will at some point lead to overshooting setpoints and eventually instable behaviour</li> </ul> </li> </ul> <p>Warning</p> <p>When changing control parameters such as Kp Position, introduce small gradual changes at a time to avoid unexpected and potentially unsafe behaviour of the actuator. For example you can try going from 0.5 to 1 and see how the change impact the behaviour of the actuator, don't go e.g. from 0.5 to 5</p> <ul> <li>Upon changing the value of Position Kp, for it to take effect you will need to click the Apply button</li> <li>This same process can be applied when selecting other modes, changing their respective control parameters.<ul> <li>The Torque and the Speed control loops also have some preset control parameters that can be simply sleected form the respective dropdown menus</li> </ul> </li> <li>You can then try to set some position and torque limts from Set Limits and see how that impacts the behaviour of the actuator.</li> </ul> </li> <li> <p>If you have a mechanical shaft that you can attach to the output shaft of the actuator (such as those printable from here)</p> <ul> <li>you could try fastening a shaft to the output of the actuator and try interacting with it in different contorl modes, for example:<ul> <li>get the actuator to hold a position setpoint in Position Control mode and try to move the output shaft manually: you will feel the actuator opposing your force, the highest the Position Kp, the stronger it will oppose you</li> <li>starting with a low value, e.g. 2Nm, set a torque setpoint in Torque Control: the actuator will start spinnging producing such torque at the output: if you grab the output shaft, this will stop as soon as you exert a countertorque of the same amount. You can try changing the torque setpoint from there or the torque loop control parameters.</li> </ul> </li> </ul> </li> </ol> <p>Success</p> <p>Well done! You\u2019ve successfully powered on a PULSAR actuator, switched control modes, and observed how it responds. You\u2019ve already covered a lot \ud83d\ude80</p> <p>Where can you go from here?</p> <ul> <li> <p>If you\u2019re comfortable with Python and want deeper control or multi-actuator setups, continue with the Quickstart Tutorial: Python API for Real Actuator </p> </li> <li> <p>If you're interested in simulating PULSAR actuators without needing hardware, explore how to create Virtual Actuators with the AUGUR Digital Twin.</p> </li> </ul> <p>Question</p> <p>Need help or something doesn\u2019t work? Head over to the Support page: we\u2019ve got your back.</p>"},{"location":"quickstarts/quickstart_python_api/","title":"Quickstart Tutorial: Python API for Real Actuator","text":"<p>This page walks you through running a Real Actuator connected via USB, and controlling it via Python scripting using PULSAR HRI's Python API </p>"},{"location":"quickstarts/quickstart_python_api/#step-by-step-guide","title":"\ud83d\udc63 Step-By-Step Guide","text":"<ol> <li>Make sure your actuator is set up and connected via USB, as per the Quickstart Tutorial: Set up Real Actuator and connect via USB </li> </ol> <p>Tip</p> <p>You are of course free to run this straight from the terminal and installing libraries globally, but for a better experience we do recommend to: </p> <ul> <li> <p>use an IDE such as Visual Studio Code</p> </li> <li> <p>up a virtual environment using tools such as venv or pipenv or poetry or uv</p> </li> </ul> <ol> <li> <p>Install the PULSAR HRI Python API (more details about it here) <pre><code>pip install --upgrade pcp_api\n</code></pre></p> </li> <li> <p>Check USB communication via the CLI tool (more details about it here): <pre><code>pulsar-cli scan\n</code></pre> You should see your actuator's ID and connection info.</p> </li> <li> <p>Run the following script, the actuator should rotate at a constant speed for 5 seconds <pre><code>from pcp_api import PCP_over_USB, PulsarActuator\nfrom time import sleep\n\n# Auto-detect the USB port and create the adapter\nport = PCP_over_USB.get_port()\nadapter = PCP_over_USB(port)\n\n# Connect to actuator at address 0 (USB)\nactuator = PulsarActuator(adapter, 0)\nactuator.connect()\n\n# Set control mode and target speed\nactuator.change_mode(PulsarActuator.Mode.SPEED)\nactuator.change_setpoint(1.0)  # rad/s\n\n# Start and run for 5 seconds\nactuator.start()\nsleep(5)\nactuator.disconnect()\nadapter.close()\n</code></pre></p> </li> </ol> <p>Success</p> <p>You\u2019ve just sent your first command via the PULSAR Python API! Now you can explore doing much more by:</p> <ul> <li> <p>checkin out more example scripts starting with this one and trying other communication methods beyond usb such as CAN</p> </li> <li> <p>get intimate with the Python API code reference starting from understanding the actuator classes and methods </p> </li> <li> <p>If you're interested in simulating PULSAR actuators without needing hardware, explore how to create Virtual Actuators with the AUGUR Digital Twin.</p> </li> </ul> <p>Question</p> <p>Need help or something doesn\u2019t work? Head over to the Support page: we\u2019ve got your back.</p>"},{"location":"quickstarts/quickstart_set_up_usb/","title":"Quickstart Tutorial: Set up Real Actuator and connect via USB","text":"<p>Follow this tutorial for the fastest way to set up a PULSAR actuator out of the box connected via USB, you will then be able to get it running in no time with the PULSAR HRI Desktop App next.</p>"},{"location":"quickstarts/quickstart_set_up_usb/#what-youll-need","title":"\ud83e\uddf0 What You\u2019ll Need","text":"<p>Usually provided by PULSAR HRI:</p> <ul> <li>1x PULSAR HRI actuator </li> <li>1x Power Bus Cable (more details here)</li> <li>1x standard USB-A to USB-C cable</li> </ul> <p>Usually NOT provided by PULSAR HRI:</p> <ul> <li>A mechanical support and screws to secure the actuator (more details and some designs you can 3D-print here)</li> <li>A 48V Power Supply Unit (more details here)</li> <li>A Computer </li> </ul> <p>Operating-system-compatibility</p> <p>Currently the ecosystem is mainly compatible with, and tested on Windows and Linux Ubuntu operaing systems</p>"},{"location":"quickstarts/quickstart_set_up_usb/#step-by-step-guide","title":"\ud83d\udc63 Step-By-Step Guide","text":"<ol> <li>Connect the the Power Bus Cable to the Power Supply Unit, plug it into the actuator.</li> <li>Activate the Power Supply Unit to power the actuator on, see the actuator status led switch on</li> <li>Plug the USB-C cable into your computer, and then into the actuator USB connector, the actuator status led will change colour </li> </ol> <p>Success</p> <p>Your actuator is now connected! Move to the next Quickstart Tutorial: No-Code Desktop App for Real Actuator to get it to run in minutes!</p> <p>Question</p> <p>Need help or something doesn\u2019t work? Head over to the Support page: we\u2019ve got your back.</p>"},{"location":"set_up/set_up_real/","title":"Set Up Real Actuators","text":"<p>This page walks you through the mechanical and electrical setup of a real PULSAR actuator, excluding communication. For guidance on connecting via USB or CAN, see the next section: Communicate with Real Actuators.</p>"},{"location":"set_up/set_up_real/#what-youll-need","title":"\ud83e\uddf0 What You\u2019ll Need","text":"<p>Usually provided by PULSAR HRI:</p> <ul> <li>1x PULSAR HRI actuator</li> <li>1x Power Bus Cable (more details here)</li> </ul> <p>Usually NOT provided by PULSAR HRI:</p> <ul> <li>A mechanical support and screws to secure the actuator (see mounting hole patterns and printable designs)</li> <li>A 48V Power Supply Unit (more details here)</li> <li>A Computer (only needed later for communication setup)</li> </ul> <p>Operating-system-compatibility</p> <p>Currently the ecosystem is mainly compatible with, and tested on Windows and Linux Ubuntu operating systems</p>"},{"location":"set_up/set_up_real/#step-by-step-guide","title":"\ud83d\udc63 Step-By-Step Guide","text":"<ol> <li> <p>Mechanically mount the actuator using the recommended fixture or a custom support. Refer to Mechanical Interfaces for guidance.</p> </li> <li> <p>Connect the Power Bus Cable:</p> </li> <li> <p>Plug the Power Bus Cable into the actuator\u2019s power port.</p> </li> <li> <p>Connect the other end to the 48V Power Supply Unit.</p> </li> <li> <p>Power on the actuator:</p> </li> <li> <p>Switch on the PSU.</p> </li> <li>The actuator status LED should light up, confirming it is receiving power.</li> </ol> <p>Success</p> <p>Your actuator is now powered and mounted correctly. You\u2019re ready to move on to the next step: Communicate with Real Actuators to establish a connection for sending commands and reading telemetry!</p> <p>Question</p> <p>Need help or something doesn\u2019t work? Head over to the Support page: we\u2019ve got your back.</p>"},{"location":"set_up/set_up_virtual/","title":"Set Up Virtual Actuators","text":"<p>Coming soon.. contact our team for more info</p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/","title":"Electrical Interfaces","text":""},{"location":"set_up/hardware_interfaces/electrical_interfaces/#power-bus","title":"Power Bus","text":"<p>The power bus requirements are:</p> <ul> <li>Voltage: 48V DC</li> <li>Current: up to 30A</li> </ul> <p>Keep in mind that the actuators usually draw much less current (less than 1A without load), but you should still ensure that your power supply can provide the maximum current, or limit the current if the device is demanding more than the power supply can provide.</p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#power-bus-cable","title":"Power Bus Cable","text":"<p>The device has an XT30 male connector for power input. The pinout is as follows:</p> <p></p> <p>To power an actuator you will need a power cable with an XT30 female connector at one end, as shown in the example picture below</p> <p></p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#usb","title":"USB","text":"<p>Pulsar devices also include a USB connector. </p> <p>This allows to connect one actuator directly to a computer via a standard USB-A to USB-C cable.</p> <p>Such USB interface is intended for configuration, single actuator testing and firmware updates.</p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#can-bus","title":"CAN bus","text":"<p>Pulsar devices are compatible with CAN-FD 1Mbit/s|5Mbit/s.  This is the communication mode currently available to connect and control multiple actuators within a robotic system: all PULSAR HRI devices have dual CAN connectors, so you can daisy-chain them easily. </p> <p>An example of CAN bus is depicted in the diagram below, showing CAN bus connection between two daisy-chained Pulsar actuators and a Pulsar CAN to USB adapter, with Termination Resistors (TR) at the two ends of the bus.</p> <p></p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#can-communication-adapter","title":"CAN Communication Adapter","text":"<p>A dedicated device is required in order to enable communicating to PULSAR HRI actuators via CAN communication protocol.</p> <p>Different devices are available on the market to do so, and we provide a CAN to USB adapter, shown below from both sides.</p> <p></p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#can-bus-cables","title":"CAN bus Cables","text":"<p>The cables for realizing the CAN bus connections compatible with PULSAR HRI actuators are characterized by having 3-pin Molex PicoBlade connectors at the two ends. Such cables are available on the market, and can provided by PULSAR HRI, with an example shown below.</p> <p></p> <p>Their pinout is as follows:</p> <p></p> <p>When purchasing or making one such cable, ensure that the pinout at both ends of teh cable is respected, as indicated below</p> <p></p>"},{"location":"set_up/hardware_interfaces/electrical_interfaces/#can-bus-termination-resistors-tr","title":"CAN bus Termination Resistors (TR)","text":"<p>Industry standard CAN specifications require Termination Resistors (TR)  at both ends of the bus (usually 120 Ohm) to ensure a stable data transmission on the CAN bus. This is particularly important for high-speed communication. </p> <p>Warning</p> <p>Ensure to connect the termination resistors at both ends of the CAN bus to avoid communication issues.</p> <p>Such TRs simply consist of a 3-way Molex picoblade connector with a 120 Ohm resistor between the CAN-H and CAN_L pins.</p> <p>These TRs are not usually found on the market: they can be either self-made, or provided by PULSAR HRI, one example shown below. </p> <p></p>"},{"location":"set_up/hardware_interfaces/led/","title":"LED Status Indicators","text":"<p>PULSAR HRI devices features a simple RGB LED that provides visual feedback about their current operational state. This LED helps users quickly identify a device's status without needing to connect to a computer.</p> <p>Below is a simple reference of what the led colours mean on each device </p>"},{"location":"set_up/hardware_interfaces/led/#can-adapter-led-color-codes","title":"CAN Adapter Led Color Codes","text":"<p>\u25cf White: Device is powered up and working.</p>"},{"location":"set_up/hardware_interfaces/led/#actuator-led-color-codes","title":"Actuator Led Color Codes","text":"<p>\u25cf White: Device is powering up and initializing systems.</p> <p>\u25cf Blue: Device is idle and ready, waiting for PCP commands over CAN bus.</p> <p>\u25cf Purple: USB connection established, device is waiting for commands via USB interface.</p> <p>\u25cf Green: Device is actively following the setpoint and operating normally.</p> <p>\u25cf Red: Device has encountered an error and requires attention.</p> <p>\u25cf Off: Device is in firmware update mode.</p> <p>Note: LED colors transition automatically based on device state changes. If the LED remains red, consult the troubleshooting guide.</p>"},{"location":"set_up/hardware_interfaces/mechanical_interfaces/","title":"Mechanical Interfaces","text":""},{"location":"set_up/hardware_interfaces/mechanical_interfaces/#pulse98-actuator","title":"PULSE98 Actuator","text":""},{"location":"set_up/hardware_interfaces/mechanical_interfaces/#pulse115-actuator","title":"PULSE115 Actuator","text":"<p>coming soon</p>"},{"location":"set_up/hardware_interfaces/mechanical_interfaces/#3d-models","title":"3D Models","text":"<p>Before running a Pulsar Actuator, we recommend attaching it to a generic bracket.</p> <p>In this way you can get some hands-on understanding on how to best integrate them mechanically and electrically in your robotics system, and perform some tests safely starting for example with following the steps in the no-code quickstart tutorial. </p> <p>Below we provide some 3D printable files.</p> Base Bracket Shaft Download Download Download"}]}